# ============================================================================
# Si Statement (Conditionals)
# ============================================================================
#
# The 'si' statement provides conditional execution. It supports block form,
# one-liner form (ergo), else-if chains (sin), else clauses (secus), and
# inline error handling (cape).
#
# ----------------------------------------------------------------------------
# GRAMMAR: Si Statement
# ----------------------------------------------------------------------------
#
#   ifStmt := 'si' expression (blockStmt | 'ergo' statement)
#             ('cape' IDENTIFIER blockStmt)?
#             (elseClause | 'sin' ifStmt)?
#
#   elseClause := 'secus' (ifStmt | blockStmt | statement)
#
# Components:
#   - 'si' expression { }        — basic conditional
#   - 'si' expression ergo stmt  — one-liner form
#   - 'cape' err { }             — inline error handling
#   - 'sin' expression { }       — else-if branch
#   - 'secus' { }                — else branch
#
# ----------------------------------------------------------------------------
# KEYWORDS
# ----------------------------------------------------------------------------
#
#   si     = "if" (Latin: "if")
#   sin    = "else if" (Latin: "but if", contraction of 'si' + 'non')
#   secus  = "else" (Latin: "otherwise")
#   ergo   = "therefore" (Latin: enables one-liner consequent)
#   cape   = "catch" (Latin: "seize", inline error handling)
#
# ----------------------------------------------------------------------------
# READING THE CHAIN
# ----------------------------------------------------------------------------
#
# A complete conditional chain reads as classical Latin:
#
#   si x > 0 { positive() }      — "if x > 0..."
#   sin x < 0 { negative() }     — "but if x < 0..."
#   secus { zero() }             — "otherwise..."
#
# 'sin' is a contraction of 'si non' (if not / but if), common in Latin prose.
#
# ============================================================================
# LLM GUIDANCE
# ============================================================================
#
# ALWAYS use Latin keywords:
#   - 'si' not 'if'
#   - 'sin' not 'else if' or 'elif'
#   - 'secus' not 'else'
#   - 'ergo' for one-liners (no equivalent in JS/TS)
#
# NEVER use JavaScript/TypeScript patterns:
#   - 'if' does not exist
#   - 'else if' does not exist — use 'sin'
#   - 'else' does not exist — use 'secus'
#   - Parentheses around condition are NOT required: si x > 5 { }
#
# PREFER:
#   - Block form for multiple statements
#   - 'ergo' form for simple one-liners
#   - 'sin' chains over nested 'si' when checking related conditions
#
# ============================================================================
# EXAMPLES
# ============================================================================

incipit {
    # ==========================================================================
    # SECTION: Basic Conditionals
    # ==========================================================================
    #
    # si <condition> { <body> }
    #
    # The simplest form. Condition is evaluated, block executes if truthy.
    # No parentheses required around the condition.

    fixum x = 10

    si x > 5 {
        scribe "x is greater than 5"
    }

    si x > 20 {
        scribe "x is greater than 20"
    }

    # Multiple statements in block
    fixum age = 25

    si age >= 18 {
        scribe "Adult"
        scribe "Can vote"
    }

    # ==========================================================================
    # SECTION: One-liner Form (ergo)
    # ==========================================================================
    #
    # si <condition> ergo <statement>
    # si <condition> ergo <statement> secus <statement>
    #
    # 'ergo' (therefore) enables concise single-statement consequents.
    # Can be combined with 'secus' for one-liner if-else.

    # Simple one-liner
    si x > 5 ergo scribe "x is big"

    # One-liner if-else
    si age >= 18 ergo scribe "Adult" secus scribe "Minor"

    # Multiple conditions with ergo
    fixum score = 85
    si score >= 90 ergo scribe "A" secus scribe "Not A"

    # Simple validation
    fixum valid = verum
    si valid ergo scribe "OK"

    # ==========================================================================
    # SECTION: If-Else (secus)
    # ==========================================================================
    #
    # si <condition> { } secus { }
    #
    # 'secus' (otherwise) provides the else branch.

    si score >= 90 {
        scribe "Grade: A"
    }
    secus {
        scribe "Grade: B or lower"
    }

    # Multiple statements in branches
    fixum temperature = 22

    si temperature > 30 {
        scribe "Hot"
        scribe "Stay hydrated"
    }
    secus {
        scribe "Comfortable"
        scribe "Enjoy the weather"
    }

    # ==========================================================================
    # SECTION: If-Elseif-Else Chain (sin/secus)
    # ==========================================================================
    #
    # si <cond1> { } sin <cond2> { } sin <cond3> { } secus { }
    #
    # 'sin' (but if) chains multiple conditions. More readable than nested si.
    # Evaluates top-to-bottom, first match wins.

    fixum grade = 75

    si grade >= 90 {
        scribe "A - Excellent"
    }
    sin grade >= 80 {
        scribe "B - Good"
    }
    sin grade >= 70 {
        scribe "C - Satisfactory"
    }
    sin grade >= 60 {
        scribe "D - Passing"
    }
    secus {
        scribe "F - Failing"
    }

    # Time of day example
    fixum hour = 14

    si hour < 6 {
        scribe "Late night"
    }
    sin hour < 12 {
        scribe "Morning"
    }
    sin hour < 18 {
        scribe "Afternoon"
    }
    sin hour < 22 {
        scribe "Evening"
    }
    secus {
        scribe "Night"
    }

    # ==========================================================================
    # SECTION: Type Checking (est / non est)
    # ==========================================================================
    #
    # 'est' performs type/identity checks (like === for primitives).
    # 'non est' negates the check.
    # For null checks, prefer 'nihil x' or 'nonnihil x' unary forms.

    fixum textus? maybeName = nihil

    si maybeName est nihil {
        scribe "Name is null"
    }

    fixum active = verum

    si verum active {
        scribe "Is exactly true"
    }

    si non falsum active {
        scribe "Is not false"
    }

    # ==========================================================================
    # SECTION: Nested Conditionals
    # ==========================================================================
    #
    # Conditionals can be nested, but prefer sin chains when checking
    # related conditions to reduce nesting depth.

    fixum isLoggedIn = verum
    fixum hasPermission = verum

    si isLoggedIn {
        si hasPermission {
            scribe "Access granted"
        }
        secus {
            scribe "Permission denied"
        }
    }
    secus {
        scribe "Please log in"
    }

    # Better: use 'et' to combine conditions when possible
    si isLoggedIn et hasPermission {
        scribe "Access granted (combined check)"
    }

    # ==========================================================================
    # SECTION: Inline Error Handling (cape)
    # ==========================================================================
    #
    # si <condition> { } cape <error> { }
    #
    # 'cape' (catch/seize) provides inline error handling for expressions
    # that might throw. The error is bound to the identifier.

    si riskyOperation() {
        scribe "Operation succeeded"
    }
    cape err {
        scribe "Operation failed"
        scribe err
    }

    # Combined with else
    si anotherRiskyOp() {
        scribe "Success"
    }
    cape err {
        scribe "Caught error"
    }
    secus {
        scribe "Condition was falsy but no error"
    }

    # ==========================================================================
    # SECTION: Unary Condition Operators
    # ==========================================================================
    #
    # Faber provides Latin unary operators for common condition patterns.
    # These read more naturally and reduce symbolic noise.
    #
    # GRAMMAR (from unary):
    #   unary := ('non' | 'nulla' | 'nonnulla' | 'nihil' | 'nonnihil'
    #           | 'negativum' | 'positivum' | ...) unary
    #
    # Operators:
    #   non x       — logical not (replaces !x)
    #   nihil x     — x is null (replaces x === null)
    #   nonnihil x  — x is not null (replaces x !== null)
    #   nulla x     — x is empty/none (empty string, empty list, 0)
    #   nonnulla x  — x is non-empty/some
    #   negativum x — x < 0
    #   positivum x — x > 0

    fixum value = 42

    # Numeric sign checks
    si positivum value {
        scribe "value is positive"
    }

    si negativum value {
        scribe "value is negative"
    }

    # Compare: si value > 0 vs si positivum value
    # The unary form is more declarative

    # Null checks
    fixum textus? optionalName = nihil

    si nihil optionalName {
        scribe "name is null"
    }

    si nonnihil optionalName {
        scribe "name has a value"
    }

    # Empty checks
    fixum items = [] qua lista<numerus>

    si nulla items {
        scribe "list is empty"
    }

    fixum message = "hello"

    si nonnulla message {
        scribe "message is not empty"
    }

    # ==========================================================================
    # SECTION: Logical Operators in Conditions
    # ==========================================================================
    #
    # Use 'et' (and), 'aut' (or), 'non' (not) in conditions.
    # PREFER Latin operators over && || !

    fixum a = verum
    fixum b = falsum

    si a et b {
        scribe "Both true"
    }

    si a aut b {
        scribe "At least one true"
    }

    si non b {
        scribe "b is false"
    }

    # Combined conditions
    fixum userAge = 25
    fixum hasID = verum

    si userAge >= 21 et hasID {
        scribe "Can purchase alcohol"
    }

    si userAge < 13 aut userAge >= 65 {
        scribe "Eligible for discount"
    }
}

# ==========================================================================
# Helper functions for error handling examples
# ==========================================================================

functio riskyOperation() -> bivalens {
    redde verum
}

functio anotherRiskyOp() -> bivalens {
    redde falsum
}
