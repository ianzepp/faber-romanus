# Proba - Test syntax codegen tests
# Covers: probandum, proba, cura ante/post, cura statement (resource management)
# Note: These are TS-specific since test frameworks differ by target

# =============================================================================
# Probandum (describe)
# =============================================================================

# probandum creates a test suite (describe block)
- name: simple probandum
  input: 'probandum "Suite" { }'
  ts:
      - 'describe("Suite"'
      - '() => {'

# probandum containing proba tests
- name: probandum with proba
  input: |
      probandum "Math" {
        proba "adds" { adfirma 1 + 1 est 2 }
      }
  ts:
      - 'describe("Math"'
      - 'test("adds"'

# Nested probandum blocks
- name: nested probandum
  input: |
      probandum "Outer" {
        probandum "Inner" {
          proba "test" { adfirma verum }
        }
      }
  ts:
      - 'describe("Outer"'
      - 'describe("Inner"'
      - 'test("test"'

# =============================================================================
# Proba (test)
# =============================================================================

# proba creates a test case
- name: simple proba
  input: 'proba "test name" { adfirma verum }'
  ts:
      - 'test("test name"'
      - '() => {'

# proba omitte creates a skipped test
- name: proba omitte
  input: 'proba omitte "reason" "skipped" { adfirma verum }'
  ts:
      - 'test.skip("reason: skipped"'

# proba futurum creates a todo test
- name: proba futurum
  input: 'proba futurum "later" "pending" { }'
  ts:
      - 'test.todo("later: pending"'

# adfirma in proba generates assertion
- name: proba with adfirma
  input: 'proba "math" { adfirma 1 + 1 est 2 }'
  ts:
      - 'test("math"'
      - 'if (!('
      - 'throw new Error'

# =============================================================================
# Cura Ante/Post (beforeEach/afterEach)
# =============================================================================

# cura ante runs before each test
- name: cura ante
  input: |
      probandum "Suite" {
        cura ante { x = 0 }
      }
  ts:
      - 'beforeEach(() => {'
      - 'x = 0'

# cura ante omnia runs before all tests
- name: cura ante omnia
  input: |
      probandum "Suite" {
        cura ante omnia { db = connect() }
      }
  ts:
      - 'beforeAll(() => {'
      - 'db = connect()'

# cura post runs after each test
- name: cura post
  input: |
      probandum "Suite" {
        cura post { cleanup() }
      }
  ts:
      - 'afterEach(() => {'
      - 'cleanup()'

# cura post omnia runs after all tests
- name: cura post omnia
  input: |
      probandum "Suite" {
        cura post omnia { db.close() }
      }
  ts:
      - 'afterAll(() => {'
      - 'db.close()'

# =============================================================================
# Full Test Suite
# =============================================================================

# Complete suite with all lifecycle hooks
- name: complete probandum with all hooks
  input: |
      probandum "Database" {
        cura ante omnia { db = connect() }
        cura ante { db.reset() }
        proba "inserts" { adfirma db.count() est 0 }
        cura post { db.rollback() }
        cura post omnia { db.close() }
      }
  ts:
      - 'describe("Database"'
      - 'beforeAll(() => {'
      - 'beforeEach(() => {'
      - 'test("inserts"'
      - 'afterEach(() => {'
      - 'afterAll(() => {'

# Multiple tests in one suite
- name: multiple tests in suite
  input: |
      probandum "Math" {
        proba "adds" { adfirma 1 + 1 est 2 }
        proba "subtracts" { adfirma 5 - 3 est 2 }
        proba "multiplies" { adfirma 3 * 4 est 12 }
      }
  ts:
      - 'test("adds"'
      - 'test("subtracts"'
      - 'test("multiplies"'

# Mixed skip and todo tests
- name: mixed skip and todo tests
  input: |
      probandum "Suite" {
        proba "works" { adfirma verum }
        proba omitte "broken" "skip this" { }
        proba futurum "later" "todo this" { }
      }
  ts:
      - 'test("works"'
      - 'test.skip("broken: skip this"'
      - 'test.todo("later: todo this"'

# =============================================================================
# Standalone proba and cura
# =============================================================================

# proba at top level (not in probandum)
- name: proba at top level
  input: 'proba "standalone" { adfirma 1 est 1 }'
  ts:
      - 'test("standalone"'

# cura at top level
- name: cura at top level
  input: cura ante { setup() }
  ts:
      - 'beforeEach(() => {'

# =============================================================================
# Cura Statement (Resource Management)
# =============================================================================

# cura fit creates try/finally for resource cleanup
- name: cura fit try finally
  input: 'cura aperi("file.txt") fit fd { lege(fd) }'
  ts:
      - 'const fd = aperi("file.txt")'
      - 'try {'
      - 'lege(fd)'
      - 'finally {'
      - 'fd.solve?.()'

# cura with async acquisition
- name: cura with async
  input: cura cede connect(url) fit conn { query(conn) }
  ts:
      - 'const conn = await connect(url)'
      - 'try {'
      - 'finally {'
      - 'conn.solve?.()'

# cura with cape adds catch block
- name: cura with cape
  input: cura lock() fit guard { work() } cape err { mone(err) }
  ts:
      - 'const guard = lock()'
      - 'try {'
      - 'work()'
      - 'catch (err) {'
      - 'console.warn(err)'
      - 'finally {'
      - 'guard.solve?.()'

# cura with method call resource
- name: cura method call resource
  input: cura mutex.lock() fit guard { counter = counter + 1 }
  ts:
      - 'const guard = mutex.lock()'
      - 'guard.solve?.()'

# Nested cura statements
- name: nested cura
  input: |
      cura aperi("input.txt") fit input {
        cura aperi("output.txt") fit output {
          copy(input, output)
        }
      }
  ts:
      - 'const input = aperi("input.txt")'
      - 'const output = aperi("output.txt")'
      - 'input.solve?.()'
      - 'output.solve?.()'

# cura with async and cape
- name: cura async with cape
  input: |
      cura cede connect(db_url) fit conn {
        cede conn.query(sql)
      } cape err {
        scribe "Error:", err
      }
  ts:
      - 'const conn = await connect(db_url)'
      - 'await conn.query(sql)'
      - 'catch (err) {'
      - 'console.log("Error:", err)'
      - 'finally {'
      - 'conn.solve?.()'
