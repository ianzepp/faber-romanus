# Typi - Type system codegen tests
# Covers: type aliases, ordo (enum), union types, nullable, numeric types

# =============================================================================
# Type Aliases
# =============================================================================

# typus creates a type alias
- name: simple type alias
  input: typus ID = textus
  ts: 'type ID = string;'
  py: 'ID = str'

# Generic type aliases preserve type parameters
- name: generic type alias
  input: typus StringList = lista<textus>
  ts: 'type StringList = Array<string>;'
  py: 'StringList = list[str]'

# typeof captures the type of a value (TS only - Python uses Any)
- name: typeof type alias
  input: |
      fixum config = { debug: verum }
      typus ConfigTypus = typus config
  ts:
      - 'type ConfigTypus = typeof config;'

# Numeric type parameters are ignored in TS (no fixed-width integers)
- name: type with numeric parameter ignored
  input: typus SmallNum = numerus<32>
  ts: 'type SmallNum = number;'

# Size type parameters (i32, u64) preserved but ignored in TS
- name: type with size type parameter
  input: typus Int32 = numerus<i32>
  ts: 'type Int32 = number<i32>;'

# =============================================================================
# Primitive Type Mappings
# =============================================================================

# fractus is floating point (number in TS, float in Python)
- name: fractus maps to number
  input: typus Ratio = fractus
  ts: 'type Ratio = number;'
  py: 'Ratio = float'

# decimus is arbitrary precision decimal (requires import)
- name: decimus maps to Decimal
  input: typus Price = decimus
  ts:
      - "import type Decimal from 'decimal.js';"
      - 'type Price = Decimal;'
  py:
      - 'from decimal import Decimal'
      - 'Price = Decimal'

# octeti is byte array
- name: octeti maps to Uint8Array
  input: typus Buffer = octeti
  ts: 'type Buffer = Uint8Array;'
  py: 'Buffer = bytes'

# magnus is arbitrary precision integer (bigint in TS, int in Python)
- name: magnus maps to bigint
  input: typus BigNum = magnus
  ts: 'type BigNum = bigint;'
  py: 'BigNum = int'

# magnus variable with bigint literal
- name: magnus variable with literal
  input: fixum magnus huge = 99999999999999999999n
  ts: 'const huge: bigint = 99999999999999999999n;'
  py: 'huge: int = 99999999999999999999'

# numquam is the never type (function never returns)
- name: numquam maps to never
  input: 'functio moritur() -> numquam { iace novum Erratum("fatal") }'
  ts:
      - 'function moritur(): never'
  py:
      - 'def moritur() -> NoReturn:'

# ignotum is the unknown type
- name: ignotum maps to unknown
  input: typus Mystery = ignotum
  ts: 'type Mystery = unknown;'
  py: 'Mystery = Any'

# ignotum variable accepts any value
- name: ignotum variable
  input: varia ignotum x = 42
  ts: 'let x: unknown = 42;'
  py: 'x: Any = 42'

# =============================================================================
# Union Types
# =============================================================================

# unio<A, B> creates union type
- name: union type with two members
  input: 'fixum unio<textus, numerus> value = "hello"'
  ts: 'const value: string | number = "hello";'
  py: 'value: str | int = "hello"'

# unio can have multiple members
- name: union type with three members
  input: fixum unio<textus, numerus, nihil> value = nihil
  ts: 'const value: string | number | null = null;'
  py: 'value: str | int | None = None'

# Type alias with union type
- name: type alias with union
  input: typus Json = unio<textus, numerus, bivalens, nihil>
  ts: 'type Json = string | number | boolean | null;'
  py: 'Json = str | int | bool | None'

# =============================================================================
# Nullable Types
# =============================================================================

# ? suffix makes type nullable (| null in TS, | None in Python)
- name: nullable type
  input: fixum textus? name = nihil
  ts:
      - 'string | null'
  py:
      - 'str | None'

# =============================================================================
# Enums (ordo)
# =============================================================================

# ordo declares an enum - TS uses native enum, Python uses Enum class
- name: simple enum
  input: 'ordo color { rubrum, viridis, caeruleum }'
  ts: 'enum color { rubrum, viridis, caeruleum }'
  py:
      - 'class color(Enum):'
      - 'rubrum = auto()'
      - 'viridis = auto()'

# Enum with explicit numeric values
- name: enum with numeric values
  input: 'ordo status { pendens = 0, actum = 1, finitum = 2 }'
  ts: 'enum status { pendens = 0, actum = 1, finitum = 2 }'
  py:
      - 'class status(Enum):'
      - 'pendens = 0'
      - 'actum = 1'

# Enum with string values
- name: enum with string values
  input: 'ordo direction { north = "N", south = "S" }'
  ts: 'enum direction { north = "N", south = "S" }'
  py:
      - 'class direction(Enum):'
      - 'north = "N"'
      - 'south = "S"'

# Enum with mixed auto and explicit values
- name: enum with mixed values
  input: 'ordo mixed { a, b = 5, c }'
  ts: 'enum mixed { a, b = 5, c }'
  py:
      - 'class mixed(Enum):'
      - 'a = auto()'
      - 'b = 5'
      - 'c = auto()'

# Accessing enum members via dot notation
- name: enum member access
  input: |
      ordo color { rubrum, viridis }
      scribe color.rubrum
  ts:
      - 'enum color { rubrum, viridis }'
      - 'console.log(color.rubrum)'
  py:
      - 'class color(Enum):'
      - 'print(color.rubrum)'

# =============================================================================
# Type Checks (est)
# =============================================================================

# est with primitive uses typeof in TS, isinstance in Python
- name: est with primitive
  input: fixum check = x est textus
  ts:
      - 'typeof x === "string"'
  py:
      - 'isinstance(x, str)'

# non est negates the type check
- name: non est with primitive
  input: fixum check = x non est numerus
  ts:
      - 'typeof x !== "number"'
  py:
      - 'not isinstance(x, int)'

# est with user type uses instanceof in both targets
- name: est with user type
  input: fixum check = obj est Persona
  ts:
      - 'instanceof Persona'
  py:
      - 'isinstance(obj, Persona)'
