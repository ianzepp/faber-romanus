# Operatores - Operator codegen tests
# Covers: binary, logical, bitwise, compound assignment, ternary

# Binary operators
- name: addition
  input: 1 + 2
  ts: '(1 + 2);'
  py: '(1 + 2)'

- name: function call
  input: salve(nomen)
  ts: 'salve(nomen);'
  py: 'salve(nomen)'

- name: method call
  input: lista.filter(f)
  ts: 'lista.filter(f);'
  py: 'lista.filter(f)'

- name: member access
  input: usuario.nomen
  ts: 'usuario.nomen;'
  py: 'usuario.nomen'

# Logical operators
- name: et becomes and
  input: a et b
  ts: '(a && b);'
  py: '(a and b)'

- name: aut becomes or
  input: a aut b
  ts: '(a || b);'
  py: '(a or b)'

- name: vel becomes nullish coalescing
  input: a vel b
  ts: '(a ?? b);'
  py:
      - 'a if a is not None else b'

- name: vel chains correctly
  input: a vel b vel c
  ts: '((a ?? b) ?? c);'
  py:
      - 'if'
      - 'is not None'

# Bitwise operators
- name: bitwise AND
  input: 5 & 3
  ts: '(5 & 3);'
  py: '(5 & 3)'

- name: bitwise OR
  input: 5 | 3
  ts: '(5 | 3);'
  py: '(5 | 3)'

- name: bitwise XOR
  input: 5 ^ 3
  ts: '(5 ^ 3);'
  py: '(5 ^ 3)'

- name: bitwise NOT
  input: '~5'
  ts: '~5;'
  py: '~5'

- name: left shift
  input: 1 << 4
  ts: '(1 << 4);'
  py: '(1 << 4)'

- name: right shift
  input: 16 >> 2
  ts: '(16 >> 2);'
  py: '(16 >> 2)'

# Compound assignment
- name: compound add
  input: |
      varia x = 0
      x += 1
  ts:
      - 'x += 1'
  py:
      - 'x += 1'

- name: compound subtract
  input: |
      varia x = 10
      x -= 1
  ts:
      - 'x -= 1'
  py:
      - 'x -= 1'

# Ternary operator
- name: ternary with symbols
  input: 'verum ? 1 : 0'
  ts: 'true ? 1 : 0;'
  py: '1 if True else 0'

- name: ternary with sic secus
  input: verum sic 1 secus 0
  ts: 'true ? 1 : 0;'
  py: '1 if True else 0'

- name: ternary in variable
  input: 'varia x = verum ? 1 : 0'
  ts: 'let x = true ? 1 : 0;'
  py: 'x = 1 if True else 0'

# Comparison operators
- name: equality
  input: a == b
  ts: '(a == b);'
  py: '(a == b)'

- name: inequality
  input: a != b
  ts: '(a != b);'
  py: '(a != b)'

- name: less than
  input: a < b
  ts: '(a < b);'
  py: '(a < b)'

- name: greater than
  input: a > b
  ts: '(a > b);'
  py: '(a > b)'

# Spread operator
- name: spread in array
  input: fixum combined = [sparge a, sparge b]
  ts: 'const combined = [...a, ...b];'
  py: 'combined = [*a, *b]'

- name: spread in function call
  input: fn(sparge args)
  ts: 'fn(...args);'
  py: 'fn(*args)'

- name: spread in object
  input: 'fixum merged = { sparge defaults, x: 1 }'
  ts: 'const merged = { ...defaults, x: 1 };'
  py: 'merged = {**defaults, "x": 1}'

# Rest operator
- name: rest in array destructuring
  input: fixum [first, ceteri rest] = items
  ts: 'const [first, ...rest] = items;'
  py: 'first, *rest = items'

- name: rest in function params
  input: 'functio sum(ceteri lista<numerus> nums) { redde 0 }'
  ts:
      - '...nums: Array<number>'
  py:
      - '*nums: list[int]'

# Optional chaining
- name: optional property access
  input: user?.name
  ts: 'user?.name;'
  py:
      - 'user.name if user is not None else None'

- name: optional computed access
  input: arr?[0]
  ts: 'arr?.[0];'
  py:
      - 'arr[0] if arr is not None else None'

- name: optional call
  input: 'callback?()'
  ts: 'callback?.();'
  py:
      - 'callback() if callback is not None else None'

# Non-null assertion (Python just ignores it)
- name: non-null property access
  input: user!.name
  ts: 'user!.name;'
  py: 'user.name'

- name: non-null computed access
  input: arr![0]
  ts: 'arr![0];'
  py: 'arr[0]'

# Computed member access
- name: computed access with variable
  input: obj[key]
  ts: 'obj[key];'
  py: 'obj[key]'

- name: computed access with literal
  input: arr[0]
  ts: 'arr[0];'
  py: 'arr[0]'

# Negative index
- name: negative index uses at
  input: fixum x = nums[-1]
  ts: 'const x = nums.at(-1);'
  py: 'x = nums[-1]'

# Slicing
- name: slice with exclusive range
  input: fixum x = nums[1..3]
  ts: 'const x = nums.slice(1, 3);'
  py: 'x = nums[1:3]'

- name: slice with inclusive range
  input: fixum x = nums[0 usque 2]
  ts: 'const x = nums.slice(0, 3);'
  py: 'x = nums[0:3]'
