# Function declarations - functio with modifiers futura, cursor, curata
# Maps Faber function syntax to target-language equivalents
#
# Syntax:
#   functio name(params) -> ReturnType { body }
#   functio name(params) futura { body }         -- async (modifier after params)
#   functio name(params) cursor -> Type { body } -- generator
#   functio name(params) curata alloc -> Type    -- managed (allocator context)
#   functio name() fiet Type { body }            -- async via verb (implies futura)
#   functio name() fiunt Type { body }           -- generator via verb (implies cursor)
#   functio name() fient Type { body }           -- async generator via verb
#
# Note: ts/py use contains (function body spans lines); rs/cpp/zig also use contains

# =============================================================================
# Simple Functions
# =============================================================================

# Basic function with untyped parameter
- name: simple function with param
  source: |
      functio salve(nomen) {
        redde nomen
      }
  expect:
      ts:
          - 'function salve(nomen)'
          - 'return nomen;'
      py:
          - 'def salve(nomen):'
          - 'return nomen'
      rs:
          - 'fn salve(nomen: _)'
          - 'return nomen;'
      cpp:
          - 'void salve(auto nomen)'
          - 'return nomen;'
      zig:
          - 'fn salve(nomen: anytype) void'
          - 'return nomen;'
      fab:
          - 'functio salve(nomen)'
          - 'redde nomen'

# Function with explicit return type annotation
- name: function with return type
  source: 'functio greet() -> textus { redde "hello" }'
  expect:
      ts:
          - 'function greet(): string'
          - 'return "hello"'
      py:
          - 'def greet() -> str:'
          - 'return "hello"'
      rs:
          - 'fn greet() -> String'
          - 'return String::from("hello");'
      cpp:
          - 'std::string greet()'
          - 'return std::string("hello")'
      zig:
          - 'fn greet() []const u8'
          - 'return "hello";'
      fab:
          - 'functio greet() -> textus'
          - 'redde "hello"'

# Empty function body - Python requires pass, others allow {}
- name: empty function body
  source: 'functio noop() {}'
  expect:
      ts: 'function noop() {}'
      py:
          - 'def noop():'
          - 'pass'
      rs:
          - 'fn noop() {}'
      cpp:
          - 'void noop() {}'
      zig:
          - 'fn noop() void {}'
      fab:
          - 'functio noop()'

# =============================================================================
# Typed Parameters
# =============================================================================

# Function with typed parameter (type-first syntax)
- name: typed parameter
  source: 'functio greet(textus name) { redde name }'
  expect:
      ts:
          - 'function greet(name: string)'
      py:
          - 'def greet(name: str):'
      rs:
          - 'fn greet(name: &str)'
      cpp:
          - 'void greet(const std::string& name)'
      zig:
          - 'fn greet(name: []const u8)'
      fab:
          - 'functio greet(textus name)'
          - 'redde name'

# Function with multiple typed parameters
- name: multiple typed parameters
  source: 'functio add(numerus a, numerus b) -> numerus { redde a + b }'
  expect:
      ts:
          - 'function add(a: number, b: number): number'
      py:
          - 'def add(a: int, b: int) -> int:'
      rs:
          - 'fn add(a: i64, b: i64) -> i64'
      cpp:
          - 'int64_t add(int64_t a, int64_t b)'
      zig:
          - 'fn add(a: i64, b: i64) i64'
      fab:
          - 'functio add(numerus a, numerus b) -> numerus'
          - 'redde a + b'

# Function with user-defined array type parameter (Point[] syntax)
- name: user-defined array type parameter
  source: 'functio process(Point[] points) { scribe points }'
  expect:
      ts:
          - 'function process(points: Array<Point>)'
      py:
          - 'def process(points: list[Point]):'
      rs:
          - 'fn process(points: Vec<Point>)'
      cpp:
          - 'void process(const std::vector<Point>& points)'
      zig:
          - 'fn process(points: Lista(Point))'
      fab:
          - 'functio process(Point[] points)'
          - 'scribe points'

# Nested array type (matrix)
- name: nested array type parameter
  source: 'functio process(textus[][] matrix) { scribe matrix }'
  expect:
      ts:
          - 'function process(matrix: Array<Array<string>>)'
      py:
          - 'def process(matrix: list[list[str]]):'
      rs:
          - 'fn process(matrix: Vec<Vec<String>>)'
      cpp:
          - 'void process(const std::vector<std::vector<std::string>>& matrix)'
      zig:
          - 'fn process(matrix: Lista(Lista([]const u8)))'
      fab:
          - 'functio process(textus[][] matrix)'
          - 'scribe matrix'

# Array type with de preposition (borrowed)
- name: array type with de preposition
  source: 'functio read(de Point[] points) { scribe points }'
  expect:
      ts:
          - 'function read(points: Array<Point>)'
      py:
          - 'def read(points: list[Point]):'
      rs:
          - 'fn read(points: &Vec<Point>)'
      cpp:
          - 'void read(const std::vector<Point>& points)'
      zig:
          - 'fn read(points: []const Point)'
      fab:
          - 'functio read(de Point[] points)'
          - 'scribe points'

# Array type with in preposition (mutable borrow)
- name: array type with in preposition
  source: 'functio modify(in numerus[] items) { scribe items }'
  expect:
      ts:
          - 'function modify(items: Array<number>)'
      py:
          - 'def modify(items: list[int]):'
      rs:
          - 'fn modify(items: &mut Vec<i64>)'
      cpp:
          - 'void modify(std::vector<int64_t>& items)'
      zig:
          - 'fn modify(items: *std.ArrayList(i64))'
      fab:
          - 'functio modify(in numerus[] items)'
          - 'scribe items'

# Array type with ut alias
- name: array type with ut alias
  source: 'functio process(Point[] points ut p) { scribe p }'
  expect:
      ts:
          - 'function process(p: Array<Point>)'
      py:
          - 'def process(p: list[Point]):'
      rs:
          - 'fn process(p: Vec<Point>)'
      cpp:
          - 'void process(const std::vector<Point>& p)'
      zig:
          - 'fn process(p: Lista(Point))'
      fab:
          - 'functio process(Point[] points ut p)'
          - 'scribe p'

# Array type with vel default
- name: array type with vel default
  source: 'functio process(textus[] items vel []) { scribe items }'
  expect:
      ts:
          - 'function process(items: Array<string> = [])'
      py:
          - 'def process(items: list[str] = []):'
      rs:
          - 'fn process(items: Vec<String>)'
      cpp:
          - 'void process(const std::vector<std::string>& items = {})'
      zig:
          - 'fn process(items: Lista([]const u8))'
      fab:
          - 'functio process(textus[] items vel [])'
          - 'scribe items'

# Generic type with array type parameter (copia<textus[]>)
- name: generic type with array type parameter
  source: 'functio process(copia<textus[]> items) { scribe items }'
  expect:
      ts:
          - 'function process(items: Set<Array<string>>)'
      py:
          - 'def process(items: set[list[str]]):'
      rs:
          - 'fn process(items: HashSet<Vec<String>>)'
      cpp:
          - 'void process(const std::unordered_set<std::vector<std::string>>& items)'
      zig:
          - 'fn process(items: std.AutoHashMap(Lista([]const u8), void))'
      fab:
          - 'functio process(copia<textus[]> items)'
          - 'scribe items'

# Map type with array value (tabula<textus, numerus[]>)
- name: map type with array value
  source: 'functio process(tabula<textus, numerus[]> map) { scribe map }'
  expect:
      ts:
          - 'function process(map: Map<string, Array<number>>)'
      py:
          - 'def process(map: dict[str, list[int]]):'
      rs:
          - 'fn process(map: HashMap<String, Vec<i64>>)'
      cpp:
          - 'void process(const std::unordered_map<std::string, std::vector<int64_t>>& map)'
      zig:
          - 'fn process(map: std.StringHashMap(Lista(i64)))'
      fab:
          - 'functio process(tabula<textus, numerus[]> map)'
          - 'scribe map'

# Array of generic type (copia<textus>[])
- name: array of generic type
  source: 'functio process(copia<textus>[] items) { scribe items }'
  expect:
      ts:
          - 'function process(items: Array<Set<string>>)'
      py:
          - 'def process(items: list[set[str]]):'
      rs:
          - 'fn process(items: Vec<HashSet<String>>)'
      cpp:
          - 'void process(const std::vector<std::unordered_set<std::string>>& items)'
      zig:
          - 'fn process(items: Lista(std.StringHashMap(void)))'
      fab:
          - 'functio process(copia<textus>[] items)'
          - 'scribe items'

# =============================================================================
# Async Functions
# =============================================================================

# @ futura annotation makes a function async
- name: async function with futura annotation
  source: |
      @ futura
      functio fetch(url) {
        redde data
      }
  expect:
      ts:
          - 'async function fetch(url)'
      py:
          - 'async def fetch(url):'
      rs:
          - 'async fn fetch(url: _)'
      cpp:
          - 'void fetch(auto url)'
      zig:
          - '!void'
      fab:
          - '@ futura'
          - 'functio fetch(url)'
          - 'redde data'

# fiet = async + return type (wraps in Promise/Awaitable)
- name: async function with fiet return type
  source: 'functio fetch() fiet textus { redde "data" }'
  expect:
      ts:
          - 'async function fetch(): Promise<string>'
      py:
          - 'async def fetch() -> Awaitable[str]:'
      rs:
          - 'async fn fetch() -> String'
      cpp:
          - 'std::string fetch()'
      zig:
          - 'fn fetch() ![]const u8'
      fab:
          - 'functio fetch() -> textus'
          - 'redde "data"'

# =============================================================================
# Generator Functions
# =============================================================================

# fiunt makes a function a generator (wraps return in Generator/Iterator)
- name: generator function with fiunt
  source: 'functio range() fiunt numerus { redde 1 }'
  expect:
      ts:
          - 'function* range(): Generator<number>'
      py:
          - 'def range() -> Iterator[int]:'
      rs:
          - 'fn range() -> i64'
      cpp:
          - 'int64_t range()'
      zig:
          - 'fn range() i64'
      fab:
          - 'functio range() cursor -> numerus'
          - 'redde 1'

# fient = async generator (wraps in AsyncGenerator/AsyncIterator)
- name: async generator function with fient
  source: 'functio stream() fient textus { redde "chunk" }'
  expect:
      ts:
          - 'async function* stream(): AsyncGenerator<string>'
      py:
          - 'async def stream() -> AsyncIterator[str]:'
      rs:
          - 'async fn stream() -> String'
      cpp:
          - 'std::string stream()'
      zig:
          - 'fn stream() ![]const u8'
      fab:
          - 'functio stream() futura cursor -> textus'
          - 'redde "chunk"'

# =============================================================================
# Yield/Await (cede keyword)
# =============================================================================

# cede in generator context becomes yield respond.item() (Responsum protocol)
- name: cede as yield in generator
  source: 'functio range() fiunt numerus { cede 1 }'
  expect:
      ts:
          - 'yield respond.item(1)'
          - 'yield respond.done()'
      py:
          - 'yield 1'
      rs:
          - '1.await;'
      cpp:
          - 'int64_t range()'
      zig:
          - '_ = try 1;'
      fab:
          - 'cursor functio range() -> numerus'
          - 'cede 1'

# cede in async context becomes await
- name: cede as await in async function
  source: 'functio fetch() fiet textus { cede getData() }'
  expect:
      ts:
          - 'await getData()'
      py:
          - 'await getData()'
      rs:
          - 'getData().await;'
      cpp:
          - 'getData();'
      zig:
          - 'try getData()'
      fab:
          - 'functio fetch() -> textus'
          - 'cede getData()'

# =============================================================================
# Rest Parameters (ceteri)
# =============================================================================

# ceteri collects variadic arguments
- name: rest parameter with ceteri
  source: 'functio sum(ceteri numerus[] nums) { redde 0 }'
  expect:
      ts:
          - '...nums: Array<number>'
      py:
          - '*nums: list[int]'
      rs:
          - 'fn sum(nums: Vec<i64>)'
      cpp:
          - 'void sum(const std::vector<int64_t>& nums)'
      fab:
          - 'functio sum(ceteri numerus[] nums)'
          - 'redde 0'

# =============================================================================
# Parameter Prepositions (de, in, ex)
# =============================================================================
# de = from/concerning (borrowed, read-only)
# in = in/into (mutable borrow)
# ex = from/out of (source) -- not yet implemented in codegen
#
# These map to ownership semantics in systems languages:
#   de -> Rust &T, C++ const T&, Zig []const T
#   in -> Rust &mut T, C++ T&, Zig *T

# de = borrowed, read-only parameter
- name: de preposition (read-only borrow)
  source: 'functio process(de textus source) { redde source }'
  expect:
      ts:
          - 'function process(source: string)'
      py:
          - 'def process(source: str):'
      rs:
          - 'fn process(source: &str)'
      cpp:
          - 'const std::string& source'
      zig:
          - 'source: []const u8'
      fab:
          - 'functio process(de textus source)'
          - 'redde source'

# in = mutable borrow parameter
- name: in preposition (mutable borrow)
  source: 'functio mutate(in textus target) { redde target }'
  expect:
      ts:
          - 'function mutate(target: string)'
      py:
          - 'def mutate(target: str):'
      rs:
          - 'fn mutate(target: &mut String)'
      cpp:
          - 'std::string& target'
      zig:
          - 'target: *[]u8'
      fab:
          - 'functio mutate(in textus target)'
          - 'redde target'

# Mixed: regular and prepositional parameters
- name: mixed regular and prepositional parameters
  source: 'functio update(de textus source, in textus target) { redde target }'
  expect:
      ts:
          - 'function update(source: string, target: string)'
      py:
          - 'def update(source: str, target: str):'
      rs:
          # de = &str (borrowed), in = &mut String (mutable borrow)
          - 'fn update(source: &str, target: &mut String)'
      cpp:
          - 'const std::string& source'
          - 'std::string& target'
      zig:
          - 'source: []const u8'
          - 'target: *[]u8'
      fab:
          - 'functio update(de textus source, in textus target)'
          - 'redde target'

# =============================================================================
# Edge Cases
# =============================================================================

# Function with optional parameter and default value
# WHY: Tests si (optional) + vel (default) syntax
- name: function with default parameter
  source: 'functio greet(si textus name vel "World") -> textus { redde name }'
  expect:
      ts:
          - 'function greet(name: string = "World")'
          - 'return name'
      py:
          - 'def greet(name: str = "World")'
          - 'return name'
      rs:
          - 'fn greet(name'
          - 'return name'
      cpp:
          - 'greet('
          - 'return name'
      zig:
          - 'fn greet(name'
          - 'return name'
      fab:
          - 'functio greet(si textus name vel "World")'
          - 'redde name'

# Recursive function (factorial)
# WHY: Tests self-referential function calls
- name: recursive function
  source: |
      functio factorial(numerus n) -> numerus {
        si n <= 1 {
          redde 1
        }
        redde n * factorial(n - 1)
      }
  expect:
      ts:
          - 'function factorial(n: number): number'
          - 'if ((n <= 1))'
          - 'return 1'
          - 'return (n * factorial((n - 1)))'
      py:
          - 'def factorial(n: int) -> int:'
          - 'if (n <= 1):'
          - 'return 1'
          - 'return (n * factorial((n - 1)))'
      rs:
          - 'fn factorial(n: i64) -> i64'
          - 'if (n <= 1)'
          - 'return 1'
          - 'return (n * factorial((n - 1)))'
      cpp:
          - 'int64_t factorial(int64_t n)'
          - 'if ((n <= 1))'
          - 'return 1'
          - 'return (n * factorial((n - 1)))'
      zig:
          - 'fn factorial(n: i64) i64'
          - 'if ((n <= 1))'
          - 'return 1'
          - 'return (n * factorial((n - 1)))'
      fab:
          - 'functio factorial(numerus n) -> numerus'
          - 'si n <= 1'
          - 'redde 1'
          - 'redde n * factorial(n - 1)'

# Function with many parameters (6+)
# WHY: Stress test for parameter lists
- name: function with many parameters
  source: 'functio many(a, b, c, d, e, f) { redde a }'
  expect:
      ts:
          - 'function many(a, b, c, d, e, f)'
          - 'return a'
      py:
          - 'def many(a, b, c, d, e, f):'
          - 'return a'
      rs:
          - 'fn many(a: _, b: _, c: _, d: _, e: _, f: _)'
          - 'return a'
      cpp:
          - 'void many(auto a, auto b, auto c, auto d, auto e, auto f)'
          - 'return a'
      zig:
          - 'fn many(a: anytype, b: anytype, c: anytype, d: anytype, e: anytype, f: anytype)'
          - 'return a'
      fab:
          - 'functio many(a, b, c, d, e, f)'
          - 'redde a'

# Generic function with type parameter
# WHY: Tests prae typus (type parameter) syntax
- name: generic function
  source: 'functio identity(prae typus T, T value) -> T { redde value }'
  expect:
      ts:
          - 'function identity<T>(value: T): T'
          - 'return value'
      py:
          - "T = TypeVar('T')"
          - 'def identity(value: T) -> T'
          - 'return value'
      rs:
          - 'fn identity<T>(value: T) -> T'
          - 'return value'
      cpp:
          - 'T identity('
          - 'return value'
      zig:
          - 'fn identity(comptime T: type, value: T) T'
          - 'return value'
      fab:
          - 'functio identity(prae typus T, T value) -> T'
          - 'redde value'

# Function returning lambda
# WHY: Tests lambda expression as return value
- name: function returning lambda
  source: 'functio makeAdder(numerus x) { redde pro y: x + y }'
  expect:
      ts:
          - 'function makeAdder(x: number)'
          - 'return (y) => (x + y)'
      py:
          - 'def makeAdder(x: int):'
          - 'return lambda y: (x + y)'
      rs:
          - 'fn makeAdder(x: i64)'
          - 'return |y| (x + y)'
      cpp:
          - 'void makeAdder(int64_t x)'
          - 'return [&](auto y) { return (x + y); }'
      zig:
          - 'fn makeAdder(x: i64)'
          - 'struct { fn call(y: anytype) i64 { return (x + y); } }.call'
      fab:
          - 'functio makeAdder(numerus x)'
          - 'redde pro y: x + y'

# Nested function definition
# WHY: Tests function declarations inside function bodies
- name: nested function
  source: |
      functio outer(numerus x) -> numerus {
        functio inner(numerus y) -> numerus {
          redde y * 2
        }
        redde inner(x)
      }
  expect:
      ts:
          - 'function outer(x: number): number'
          - 'function inner(y: number): number'
          - 'return (y * 2)'
          - 'return inner(x)'
      py:
          - 'def outer(x: int) -> int:'
          - 'def inner(y: int) -> int:'
          - 'return (y * 2)'
          - 'return inner(x)'
      rs:
          - 'fn outer(x: i64) -> i64'
          - 'fn inner(y: i64) -> i64'
          - 'return (y * 2)'
          - 'return inner(x)'
      cpp:
          - 'int64_t outer(int64_t x)'
          - 'int64_t inner(int64_t y)'
          - 'return (y * 2)'
          - 'return inner(x)'
      zig:
          - 'fn outer(x: i64) i64'
          - 'fn inner(y: i64) i64'
          - 'return (y * 2)'
          - 'return inner(x)'
      fab:
          - 'functio outer(numerus x) -> numerus'
          - 'functio inner(numerus y) -> numerus'
          - 'redde y * 2'
          - 'redde inner(x)'

# Function with optional (nullable) parameter
# WHY: Tests nullable type syntax (textus?)
- name: function with optional parameter
  source: 'functio process(textus? input) { redde input }'
  expect:
      ts:
          - 'function process(input: string | null)'
          - 'return input'
      py:
          - 'def process(input: str | None):'
          - 'return input'
      rs:
          - 'fn process(input: Option<String>)'
          - 'return input'
      cpp:
          - 'void process(const std::optional<std::string>& input)'
          - 'return input'
      zig:
          - 'fn process(input: ?[]const u8)'
          - 'return input'
      fab:
          - 'functio process(textus? input)'
          - 'redde input'

# Function with both regular and rest params
# WHY: Tests mixed regular and variadic parameters
- name: function with regular and rest params
  source: 'functio log(textus prefix, ceteri args) { scribe prefix }'
  expect:
      ts:
          - 'function log(prefix: string, ...args)'
          - 'console.log(prefix)'
      py:
          - 'def log(prefix: str, *args):'
          - 'print(prefix)'
      rs:
          - 'println!("{}", prefix)'
      cpp:
          - 'void log(const std::string& prefix, auto args)'
          - 'std::print("{}'
      zig:
          - 'fn log(prefix: []const u8, args: anytype)'
          - 'print("{s}\n", .{ prefix });'
      fab:
          - 'functio log(textus prefix, ceteri args)'
          - 'scribe prefix'

# =============================================================================
# Dual Parameter Naming (ut alias)
# =============================================================================
# Swift-style external/internal naming: textus location ut loc
# External name (location) is for callsite, internal name (loc) is used in body.
# All targets use the internal name in generated code.

# Basic dual naming - internal name used in body
- name: dual parameter naming with ut
  source: 'functio greet(textus location ut loc) { scribe loc }'
  expect:
      ts:
          - 'function greet(loc: string)'
          - 'console.log(loc)'
      py:
          - 'def greet(loc: str):'
          - 'print(loc)'
      rs:
          - 'fn greet(loc: &str)'
          - 'println!("{}", loc)'
      cpp:
          - 'void greet(const std::string& loc)'
          - 'std::print("{}'
      zig:
          - 'fn greet(loc: []const u8)'
          - 'print("{s}\n", .{ loc });'
      fab:
          - 'functio greet(textus location ut loc)'
          - 'scribe loc'

# Dual naming with preposition
- name: dual parameter naming with preposition
  source: 'functio process(de textus source ut src) { redde src }'
  expect:
      ts:
          - 'function process(src: string)'
          - 'return src'
      py:
          - 'def process(src: str):'
          - 'return src'
      rs:
          - 'fn process(src: &str)'
          - 'return src'
      cpp:
          - 'const std::string& src'
          - 'return src'
      zig:
          - 'src: []const u8'
          - 'return src'
      fab:
          - 'functio process(de textus source ut src)'
          - 'redde src'

# Mixed aliased and non-aliased params
- name: mixed aliased and non-aliased parameters
  source: 'functio copy(textus from ut source, textus to) { scribe source }'
  expect:
      ts:
          - 'function copy(source: string, to: string)'
          - 'console.log(source)'
      py:
          - 'def copy(source: str, to: str):'
          - 'print(source)'
      rs:
          - 'fn copy(source: &str, to: &str)'
      cpp:
          - 'void copy(const std::string& source, const std::string& to)'
      zig:
          - 'fn copy(source: []const u8, to: []const u8)'
      fab:
          - 'functio copy(textus from ut source, textus to)'
          - 'scribe source'

# =============================================================================
# Default Parameter Values (vel)
# =============================================================================
# Default values use 'vel' (Latin "or"): textus name vel "World"
# TS/Py/C++ support native defaults; Rust/Zig do not (ignored)

# Basic default value - string
- name: default parameter value string
  source: 'functio greet(textus name vel "World") { scribe name }'
  expect:
      ts:
          - 'function greet(name: string = "World")'
          - 'console.log(name)'
      py:
          - 'def greet(name: str = "World"):'
          - 'print(name)'
      rs:
          # Rust doesn't support default params - value ignored
          - 'fn greet(name: &str)'
      cpp:
          - 'void greet(const std::string& name = std::string("World"))'
      zig:
          # Zig doesn't support default params - value ignored
          - 'fn greet(name: []const u8)'
      fab:
          - 'functio greet(textus name vel "World")'
          - 'scribe name'

# Default value - numeric
- name: default parameter value numeric
  source: 'functio count(numerus n vel 10) -> numerus { redde n }'
  expect:
      ts:
          - 'function count(n: number = 10): number'
          - 'return n'
      py:
          - 'def count(n: int = 10) -> int:'
          - 'return n'
      rs:
          - 'fn count(n: i64) -> i64'
      cpp:
          - 'int64_t count(int64_t n = 10)'
      zig:
          - 'fn count(n: i64) i64'
      fab:
          - 'functio count(numerus n vel 10) -> numerus'
          - 'redde n'

# Default with dual naming
- name: default with dual naming
  source: 'functio greet(textus location ut loc vel "Roma") { scribe loc }'
  expect:
      ts:
          - 'function greet(loc: string = "Roma")'
          - 'console.log(loc)'
      py:
          - 'def greet(loc: str = "Roma"):'
          - 'print(loc)'
      rs:
          - 'fn greet(loc: &str)'
      cpp:
          - 'void greet(const std::string& loc = std::string("Roma"))'
      zig:
          - 'fn greet(loc: []const u8)'
      fab:
          - 'functio greet(textus location ut loc vel "Roma")'
          - 'scribe loc'

# Mixed default and non-default params
- name: mixed default and non-default parameters
  source: 'functio greet(textus greeting, textus name vel "World") { scribe greeting }'
  expect:
      ts:
          - 'function greet(greeting: string, name: string = "World")'
      py:
          - 'def greet(greeting: str, name: str = "World"):'
      rs:
          - 'fn greet(greeting: &str, name: &str)'
      cpp:
          - 'void greet(const std::string& greeting, const std::string& name = std::string("World"))'
      zig:
          - 'fn greet(greeting: []const u8, name: []const u8)'
      fab:
          - 'functio greet(textus greeting, textus name vel "World")'
          - 'scribe greeting'

# =============================================================================
# Optional Parameters (si)
# =============================================================================
# si marks a parameter as optional
# - Without vel default: becomes nullable (?T for TS/Zig, Option<T> for Rust, T | None for Py)
# - With vel default: parameter has default value

# Optional parameter without default (becomes nullable)
- name: optional parameter without default
  source: 'functio greet(textus name, si textus title) { scribe name }'
  expect:
      ts:
          - 'function greet(name: string, title?: string)'
      py:
          - 'def greet(name: str, title: str | None = None):'
      rs:
          - 'fn greet(name: &str, title: Option<&str>)'
      cpp:
          - 'void greet(const std::string& name, std::optional<std::string> title = std::nullopt)'
      zig:
          - 'fn greet(name: []const u8, title: ?[]const u8)'
      fab:
          - 'functio greet(textus name, si textus title)'
          - 'scribe name'

# Optional parameter with default value
- name: optional parameter with default value
  source: 'functio greet(si textus name vel "World") { scribe name }'
  expect:
      ts:
          - 'function greet(name: string = "World")'
      py:
          - 'def greet(name: str = "World"):'
      rs:
          # Rust: si with vel becomes Option<T> (caller must pass Some/None)
          - 'fn greet(name: Option<&str>)'
      cpp:
          - 'void greet(const std::string& name = std::string("World"))'
      zig:
          # Zig: si wraps in optional regardless of default
          - 'fn greet(name: ?[]const u8)'
      fab:
          - 'functio greet(si textus name vel "World")'
          - 'scribe name'

# Optional numeric parameter with default
- name: optional numeric parameter with default
  source: 'functio paginate(si numerus page vel 1, si numerus limit vel 10) -> textus { redde "ok" }'
  expect:
      ts:
          - 'function paginate(page: number = 1, limit: number = 10): string'
      py:
          - 'def paginate(page: int = 1, limit: int = 10) -> str:'
      rs:
          - 'fn paginate(page: Option<i64>, limit: Option<i64>) -> String'
      cpp:
          - 'std::string paginate(int64_t page = 1, int64_t limit = 10)'
      zig:
          - 'fn paginate(page: ?i64, limit: ?i64)'
      fab:
          - 'functio paginate(si numerus page vel 1, si numerus limit vel 10) -> textus'
          - 'redde "ok"'

# Mixed required and optional parameters
- name: mixed required and optional parameters
  source: 'functio create(textus name, si numerus age, si bivalens active vel verum) { scribe name }'
  expect:
      ts:
          - 'function create(name: string, age?: number, active: boolean = true)'
      py:
          - 'def create(name: str, age: int | None = None, active: bool = True):'
      rs:
          - 'fn create(name: &str, age: Option<i64>, active: Option<bool>)'
      cpp:
          - 'void create(const std::string& name, std::optional<int64_t> age = std::nullopt, bool active = true)'
      zig:
          - 'fn create(name: []const u8, age: ?i64, active: ?bool)'
      fab:
          - 'functio create(textus name, si numerus age, si bivalens active vel verum)'
          - 'scribe name'

# Preposition with optional (de si - borrowed optional)
- name: preposition with optional parameter
  source: 'functio analyze(textus source, de si numerus depth) { scribe source }'
  expect:
      ts:
          - 'function analyze(source: string, depth?: number)'
      py:
          - 'def analyze(source: str, depth: int | None = None):'
      rs:
          # de si = borrowed optional -> Option<&T>
          - 'fn analyze(source: &str, depth: Option<&i64>)'
      cpp:
          # de = const ref, si = optional
          - 'void analyze(const std::string& source, std::optional<int64_t> depth = std::nullopt)'
      zig:
          # de = borrowed (const pointer), si = optional -> ?*const T
          - 'fn analyze(source: []const u8, depth: ?*const i64)'
      fab:
          - 'functio analyze(textus source, de si numerus depth)'
          - 'scribe source'
