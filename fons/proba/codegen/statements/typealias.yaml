# Type alias declarations - typus
# Maps Faber type alias syntax to target-language equivalents
#
# Syntax:
#   typus Name = Type              -- basic type alias
#   typus UserID = numerus         -- primitive alias
#   typus ConfigType = typus obj   -- typeof expression

# =============================================================================
# Basic Type Aliases
# =============================================================================

# Simple type alias for string
- name: type alias for string
  source: 'typus ID = textus'
  expect:
      ts:
          - 'type ID = string;'
      py:
          - 'ID = str'
      rs:
          - 'type ID = String;'
      cpp:
          - 'using ID = std::string;'
      zig:
          - 'const ID = []const u8;'
      fab:
          - 'typus ID = textus'

# Type alias for number
- name: type alias for number
  source: 'typus Count = numerus'
  expect:
      ts:
          - 'type Count = number;'
      py:
          - 'Count = int'
      rs:
          - 'type Count = i64;'
      cpp:
          - 'using Count = int64_t;'
      zig:
          - 'const Count = i64;'
      fab:
          - 'typus Count = numerus'

# Type alias for boolean
- name: type alias for boolean
  source: 'typus Flag = bivalens'
  expect:
      ts:
          - 'type Flag = boolean;'
      py:
          - 'Flag = bool'
      rs:
          - 'type Flag = bool;'
      cpp:
          - 'using Flag = bool;'
      zig:
          - 'const Flag = bool;'
      fab:
          - 'typus Flag = bivalens'

# =============================================================================
# Generic Type Aliases
# =============================================================================

# Type alias for array/list
- name: type alias for array
  source: 'typus Items = lista<textus>'
  expect:
      ts:
          - 'type Items = Array<string>;'
      py:
          - 'Items = list[str]'
      rs:
          - 'type Items = Vec<String>;'
      cpp:
          - 'using Items = std::vector<std::string>;'
      zig:
          - 'const Items = Lista([]const u8);'
      fab:
          - 'typus Items = lista<textus>'

# Type alias for map/dictionary (StringHashMap for string keys)
- name: type alias for map
  source: 'typus Cache = tabula<textus, numerus>'
  expect:
      ts:
          - 'type Cache = Map<string, number>;'
      py:
          - 'Cache = dict[str, int]'
      rs:
          - 'type Cache = HashMap<String, i64>;'
      cpp:
          - 'using Cache = std::unordered_map<std::string, int64_t>;'
      zig:
          - 'const Cache = std.StringHashMap(i64);'
      fab:
          - 'typus Cache = tabula<textus, numerus>'

# =============================================================================
# Typeof Aliases (TypeScript-specific feature)
# =============================================================================

# Type alias using typeof (not yet implemented for Python/Rust/C++/Zig, falls back to ignotum/anytype)
- name: type alias with typeof
  source: 'typus ConfigType = typus config'
  expect:
      ts:
          - 'type ConfigType = typeof config;'
      py:
          - 'ConfigType = Any'
      rs:
          - 'type ConfigType = ignotum;'
      cpp:
          - 'using ConfigType = ignotum;'
      zig:
          - 'const ConfigType = anytype;'
      fab:
          - 'typus ConfigType = typus config'

# =============================================================================
# Union Type Aliases
# =============================================================================

# Type alias for union type
# TODO: Parser doesn't yet support union types in type expressions
- name: type alias for union
  skip: [ts, py, rs, cpp, zig] # Parser limitation
  source: 'typus StringOrNumber = textus | numerus'
  expect:
      ts:
          - 'type StringOrNumber = string | number;'
      py:
          - 'StringOrNumber = str | int'
      fab:
          - 'typus StringOrNumber = textus | numerus'

# =============================================================================
# Function Type Aliases
# =============================================================================

# Type alias for function type
# TODO: Parser doesn't yet support function types in type expressions
- name: type alias for function type
  skip: [ts, py, rs, cpp, zig] # Parser limitation
  source: 'typus Handler = (textus, numerus) -> vacuum'
  expect:
      ts:
          - 'type Handler = (arg0: string, arg1: number) => void;'
      py:
          - 'Handler = Callable[[str, int], None]'
      fab:
          - 'typus Handler = (textus, numerus) -> vacuum'

# =============================================================================
# Nullable Type Aliases
# =============================================================================

# Type alias for nullable type
- name: type alias for nullable
  source: 'typus OptionalString = textus?'
  expect:
      ts:
          - 'type OptionalString = string | null;'
      py:
          - 'OptionalString = str | None'
      fab:
          - 'typus OptionalString = textus?'

# =============================================================================
# Array Type Aliases
# =============================================================================

# Type alias for list/array (additional test case)
- name: type alias for string list
  source: 'typus StringList = lista<textus>'
  expect:
      ts:
          - 'type StringList = Array<string>;'
      py:
          - 'StringList = list[str]'
      fab:
          - 'typus StringList = lista<textus>'

# =============================================================================
# Generic Type Aliases with Multiple Parameters
# =============================================================================

# Type alias with multiple generic parameters
# TODO: Parser doesn't yet support generic parameters on type alias definitions
- name: type alias with multiple generics
  skip: [ts, py, rs, cpp, zig] # Parser limitation
  source: 'typus Pair<A, B> = (A, B)'
  expect:
      ts:
          - 'type Pair<A, B> = [A, B];'
      py:
          - 'Pair = tuple[A, B]'
      fab:
          - 'typus Pair<A, B> = (A, B)'

# =============================================================================
# Object Shape Type Aliases
# =============================================================================

# Type alias for object shape
# TODO: Parser doesn't yet support inline object shape types
- name: type alias for object shape
  skip: [ts, py, rs, cpp, zig] # Parser limitation
  source: 'typus Config = { host: textus, port: numerus }'
  expect:
      ts:
          - 'type Config = { host: string; port: number };'
      py:
          - 'Config = TypedDict("Config", {"host": str, "port": int})'
      fab:
          - 'typus Config = { host: textus, port: numerus }'
