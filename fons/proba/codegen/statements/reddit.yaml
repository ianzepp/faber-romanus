# Reddit statements - syntactic sugar for ergo redde
# Maps Faber 'reddit' to target return statements
#
# Syntax:
#   si condition reddit expression
#   casu value reddit expression
#   dum condition reddit expression
#   ex items pro item reddit expression (early return from loop)
#   de obj pro k reddit expression
#   discerne expr { casu Variant reddit expression }
#
# 'reddit' (it returns) is syntactic sugar for 'ergo redde'
# It parses an expression and wraps it in a return statement

# =============================================================================
# Si with Reddit (Early Return)
# =============================================================================

- name: si with reddit - simple
  source: |
      functio check(numerus x) -> bivalens {
          si x < 0 reddit falsum
          redde verum
      }
  expect:
      ts:
          - 'if ((x < 0))'
          - 'return false'
          - 'return true'
      py:
          - 'if (x < 0):'
          - 'return False'
          - 'return True'
      rs:
          - 'if (x < 0)'
          - 'return false'
          - 'return true'
      cpp:
          - 'if ((x < 0))'
          - 'return false'
          - 'return true'
      zig:
          - 'if ((x < 0))'
          - 'return false'
          - 'return true'
      fab:
          - 'si x < 0'
          - 'redde falsum'
          - 'redde verum'

- name: si with reddit - expression
  source: |
      functio double(numerus x) -> numerus {
          si x > 100 reddit x * 2
          redde x
      }
  expect:
      ts:
          - 'if ((x > 100))'
          - 'return (x * 2)'
          - 'return x'
      py:
          - 'if (x > 100):'
          - 'return (x * 2)'
          - 'return x'
      fab:
          - 'si x > 100'
          - 'redde x * 2'
          - 'redde x'

- name: si chain with reddit
  source: |
      functio grade(numerus score) -> textus {
          si score >= 90 reddit "A"
          si score >= 80 reddit "B"
          si score >= 70 reddit "C"
          redde "F"
      }
  expect:
      ts:
          - 'if ((score >= 90))'
          - 'return "A"'
          - 'if ((score >= 80))'
          - 'return "B"'
          - 'if ((score >= 70))'
          - 'return "C"'
          - 'return "F"'
      py:
          - 'if (score >= 90):'
          - 'return "A"'
          - 'if (score >= 80):'
          - 'return "B"'
          - 'if (score >= 70):'
          - 'return "C"'
          - 'return "F"'
      fab:
          - 'si score >= 90'
          - 'redde "A"'
          - 'si score >= 80'
          - 'redde "B"'
          - 'si score >= 70'
          - 'redde "C"'
          - 'redde "F"'

# =============================================================================
# Elige with Reddit (Switch Cases)
# =============================================================================

- name: elige with reddit cases
  source: |
      functio getType(textus name) -> numerus {
          elige name {
              casu "textus" reddit 1
              casu "numerus" reddit 2
              ceterum reddit 0
          }
      }
  expect:
      ts:
          - 'if (name === "textus")'
          - 'return 1'
          - 'if (name === "numerus")'
          - 'return 2'
          - 'return 0'
      py:
          - 'match name:'
          - 'case "textus":'
          - 'return 1'
          - 'case "numerus":'
          - 'return 2'
          - 'case _:'
          - 'return 0'
      fab:
          - 'elige name'
          - 'casu "textus"'
          - 'redde 1'
          - 'casu "numerus"'
          - 'redde 2'
          - 'ceterum'
          - 'redde 0'

- name: elige with mixed reddit and blocks
  source: |
      functio process(numerus code) -> textus {
          elige code {
              casu 1 reddit "one"
              casu 2 {
                  scribe "two"
                  redde "two"
              }
              casu 3 reddit "three"
              ceterum reddit "unknown"
          }
      }
  expect:
      ts:
          - 'if (code === 1)'
          - 'return "one"'
          - 'if (code === 2)'
          - 'console.log("two")'
          - 'return "two"'
          - 'if (code === 3)'
          - 'return "three"'
          - 'return "unknown"'
      fab:
          - 'casu 1'
          - 'redde "one"'
          - 'casu 2'
          - 'scribe "two"'
          - 'redde "two"'
          - 'casu 3'
          - 'redde "three"'
          - 'ceterum'
          - 'redde "unknown"'

# =============================================================================
# Loops with Reddit (Early Exit)
# =============================================================================

- name: ex pro with reddit - find first
  source: |
      functio findFirst(lista<numerus> items, numerus target) -> numerus? {
          ex items pro item {
              si item == target reddit item
          }
          redde nihil
      }
  expect:
      ts:
          - 'for (const item of items)'
          - 'if ((item == target))'
          - 'return item'
          - 'return null'
      py:
          - 'for item in items:'
          - 'if (item == target):'
          - 'return item'
          - 'return None'
      fab:
          - 'ex items pro item'
          - 'si item == target'
          - 'redde item'
          - 'redde nihil'

- name: de pro with reddit - has key
  source: |
      functio hasKey(tabula<textus, numerus> obj, textus key) -> bivalens {
          de obj pro k {
              si k == key reddit verum
          }
          redde falsum
      }
  expect:
      ts:
          - 'for (const k in obj)'
          - 'if ((k == key))'
          - 'return true'
          - 'return false'
      py:
          - 'for k in obj:'
          - 'if (k == key):'
          - 'return True'
          - 'return False'
      fab:
          - 'de obj pro k'
          - 'si k == key'
          - 'redde verum'
          - 'redde falsum'

# =============================================================================
# Discerne with Reddit (Pattern Matching)
# =============================================================================

- name: discerne with reddit
  source: |
      discretio Option {
          Some(numerus)
          None
      }
      functio unwrap(Option opt) -> numerus {
          discerne opt {
              casu Some pro value reddit value
              casu None ergo iace "Cannot unwrap None"
          }
      }
  expect:
      ts:
          - "if (opt.tag === 'Some')"
          - 'return value'
          - "if (opt.tag === 'None')"
          - 'throw "Cannot unwrap None"'
      fab:
          - 'discretio Option'
          - 'casu Some pro value'
          - 'redde value'
          - 'casu None'
          - 'iace "Cannot unwrap None"'

# =============================================================================
# Sin/Secus with Reddit
# =============================================================================

- name: sin secus chain with reddit
  source: |
      functio classify(numerus x) -> textus {
          si x < 0 reddit "negative"
          sin x == 0 reddit "zero"
          secus reddit "positive"
      }
  expect:
      ts:
          - 'if ((x < 0))'
          - 'return "negative"'
          - 'else if ((x == 0))'
          - 'return "zero"'
          - 'else'
          - 'return "positive"'
      py:
          - 'if (x < 0):'
          - 'return "negative"'
          - 'elif (x == 0):'
          - 'return "zero"'
          - 'else:'
          - 'return "positive"'
      fab:
          - 'si x < 0'
          - 'redde "negative"'
          - 'sin x == 0'
          - 'redde "zero"'
          - 'secus'
          - 'redde "positive"'

# =============================================================================
# Incipit with Reddit (Exit Code)
# =============================================================================

- name: incipit reddit exit code
  source: 'incipit reddit 0'
  expect:
      ts:
          - 'return 0'
      py:
          - 'return 0'
      rs:
          - 'fn main()'
          - 'return 0'
      zig:
          - 'pub fn main()'
          - 'return 0'
      fab:
          - 'incipit'
          - 'redde 0'

# =============================================================================
# Nullable Return with Reddit
# =============================================================================

- name: reddit nihil for nullable return
  source: |
      functio divide(numerus a, numerus b) -> numerus? {
          si b == 0 reddit nihil
          redde a / b
      }
  expect:
      ts:
          - 'if ((b == 0))'
          - 'return null'
          - 'return (a / b)'
      py:
          - 'if (b == 0):'
          - 'return None'
          - 'return (a / b)'
      fab:
          - 'si b == 0'
          - 'redde nihil'
          - 'redde a / b'
