# Discerne statements - pattern matching on discretio tagged unions
# Maps Faber discerne syntax to target-language pattern matching
#
# Syntax:
#   discerne value {
#     casu VariantName { body }
#     casu VariantName pro field1, field2 { body }
#   }
#
# Target mappings:
#   TypeScript: if/else chain on tag property with destructuring
#   Python: match/case (Python 3.10+)
#   Rust: match expression
#   C++: TODO placeholder (std::visit is complex)
#   Zig: switch on tagged union

# =============================================================================
# Unit Variants
# =============================================================================

# Pattern matching unit variants (no bindings)
- name: discerne with unit variants
  faber: |
      discerne status {
        casu Active { scribe "active" }
        casu Inactive { scribe "inactive" }
      }
  expect:
      ts:
          - "if (status.tag === 'Active')"
          - 'console.log("active")'
          - "else if (status.tag === 'Inactive')"
          - 'console.log("inactive")'
      py:
          - 'match status:'
          - "case {'tag': 'Active'}:"
          - 'print("active")'
          - "case {'tag': 'Inactive'}:"
          - 'print("inactive")'
      rs:
          - 'match status'
          - 'Active =>'
          - 'println!("{}", String::from("active"))'
          - 'Inactive =>'
      cpp:
          - '// TODO: discerne on status'
          - '// casu Active: { ... }'
          - '// casu Inactive: { ... }'
      zig:
          - 'switch (status)'
          - '.active =>'
          - '.inactive =>'
      fab:
          - 'discerne status'
          - 'casu Active'
          - 'casu Inactive'
          - 'scribe "active"'
          - 'scribe "inactive"'

# =============================================================================
# Variants with Bindings
# =============================================================================

# Pattern matching with field extraction
- name: discerne with bindings
  faber: |
      discerne event {
        casu Click pro x, y {
          scribe x
          scribe y
        }
        casu Quit {
          scribe "quit"
        }
      }
  expect:
      ts:
          - "if (event.tag === 'Click')"
          - 'const { x, y } = event;'
          - 'console.log(x)'
          - 'console.log(y)'
          - "else if (event.tag === 'Quit')"
          - 'console.log("quit")'
      py:
          - 'match event:'
          - "case {'tag': 'Click', x, y}:"
          - 'print(x)'
          - 'print(y)'
          - "case {'tag': 'Quit'}:"
          - 'print("quit")'
      rs:
          - 'match event'
          - 'Click { x, y } =>'
          - 'println!'
          - 'Quit =>'
      cpp:
          - '// TODO: discerne on event'
          - '// casu Click pro x, y: { ... }'
          - '// casu Quit: { ... }'
      zig:
          - 'switch (event)'
          - '.click => |payload|'
          - 'const x = payload.x;'
          - 'const y = payload.y;'
          - '.quit =>'
      fab:
          - 'discerne event'
          - 'casu Click pro x, y'
          - 'scribe x'
          - 'scribe y'
          - 'casu Quit'
          - 'scribe "quit"'

# =============================================================================
# Single Binding
# =============================================================================

# Pattern match with single field binding
- name: discerne with single binding
  faber: |
      discerne result {
        casu Success pro message {
          scribe message
        }
        casu Failure pro error {
          mone error
        }
      }
  expect:
      ts:
          - "if (result.tag === 'Success')"
          - 'const { message } = result;'
          - 'console.log(message)'
          - "else if (result.tag === 'Failure')"
          - 'const { error } = result;'
          - 'console.warn(error)'
      py:
          - 'match result:'
          - "case {'tag': 'Success', message}:"
          - 'print(message)'
          - "case {'tag': 'Failure', error}:"
          - 'print("[WARN]", error)'
      rs:
          - 'match result'
          - 'Success { message } =>'
          - 'Failure { error } =>'
      cpp:
          - '// TODO: discerne on result'
      zig:
          - 'switch (result)'
          - '.success => |payload|'
          - 'const message = payload.message;'
      fab:
          - 'discerne result'
          - 'casu Success pro message'
          - 'scribe message'
          - 'casu Failure pro error'
          - 'mone error'

# =============================================================================
# Alias Binding (ut)
# =============================================================================

# Pattern matching with alias binding - bind whole variant to a name
- name: discerne with alias binding
  faber: |
      discerne event {
        casu Click ut c {
          scribe c.x
          scribe c.y
        }
        casu Quit {
          scribe "quit"
        }
      }
  expect:
      ts:
          - "if (event.tag === 'Click')"
          - 'const c = event;'
          - 'console.log(c.x)'
          - 'console.log(c.y)'
          - "else if (event.tag === 'Quit')"
      py:
          - 'match event:'
          - "case {'tag': 'Click'} as c:"
          - 'print(c.x)'
          - 'print(c.y)'
      rs:
          - 'match event'
          - 'c @ Click { .. } =>'
          - 'Quit =>'
      cpp:
          - '// TODO: discerne on event'
          - '// casu Click ut c: { ... }'
          - '// casu Quit: { ... }'
      zig:
          - 'switch (event)'
          - '.click => |c|'
          - '.quit =>'
      fab:
          - 'discerne event'
          - 'casu Click ut c'
          - 'scribe c.x'
          - 'scribe c.y'
          - 'casu Quit'

# =============================================================================
# Multiple Cases
# =============================================================================

# Three or more variant cases
- name: discerne with multiple cases
  faber: |
      discerne action {
        casu Move pro x, y { scribe x }
        casu Rotate pro angle { scribe angle }
        casu Scale pro factor { scribe factor }
        casu Reset { scribe "reset" }
      }
  expect:
      ts:
          - "if (action.tag === 'Move')"
          - "else if (action.tag === 'Rotate')"
          - "else if (action.tag === 'Scale')"
          - "else if (action.tag === 'Reset')"
      py:
          - 'match action:'
          - "case {'tag': 'Move', x, y}:"
          - "case {'tag': 'Rotate', angle}:"
          - "case {'tag': 'Scale', factor}:"
          - "case {'tag': 'Reset'}:"
      rs:
          - 'match action'
          - 'Move { x, y } =>'
          - 'Rotate { angle } =>'
          - 'Scale { factor } =>'
          - 'Reset =>'
      cpp:
          - '// TODO: discerne on action'
      zig:
          - 'switch (action)'
          - '.move => |payload|'
          - '.rotate => |payload|'
          - '.scale => |payload|'
          - '.reset =>'
      fab:
          - 'discerne action'
          - 'casu Move pro x, y'
          - 'casu Rotate pro angle'
          - 'casu Scale pro factor'
          - 'casu Reset'
          - 'scribe "reset"'

# =============================================================================
# Wildcard Pattern
# =============================================================================

# Wildcard pattern for catch-all cases
- name: discerne with wildcard pattern
  faber: |
      discerne status {
        casu Active { scribe "active" }
        casu _ { scribe "other" }
      }
  expect:
      ts:
          - "if (status.tag === 'Active')"
          - 'console.log("active")'
          - 'else {'
          - 'console.log("other")'
      py:
          - 'match status:'
          - "case {'tag': 'Active'}:"
          - 'case _:'
          - 'print("other")'
      rs:
          - 'match status'
          - 'Active =>'
          - '_ =>'
      zig:
          - 'switch (status)'
          - '.active =>'
          - 'else =>'
      fab:
          - 'discerne status'
          - 'casu Active'
          - 'casu _'
          - 'scribe "other"'

# =============================================================================
# Multi-Discriminant Matching
# =============================================================================

# Two discriminants with matching types
- name: discerne with two discriminants
  faber: |
      discerne left, right {
        casu A ut l, A ut r { scribe "both A" }
        casu B ut l, B ut r { scribe "both B" }
        casu _, _ { scribe "different" }
      }
  expect:
      ts:
          - "if (left.tag === 'A' && right.tag === 'A')"
          - 'const l = left;'
          - 'const r = right;'
          - 'console.log("both A")'
          - "else if (left.tag === 'B' && right.tag === 'B')"
          - 'console.log("both B")'
          - 'else {'
          - 'console.log("different")'
      fab:
          - 'discerne left, right'
          - 'casu A ut l, A ut r'
          - 'casu B ut l, B ut r'
          - 'casu _, _'

# Mixed patterns - one specific, one wildcard
- name: discerne with mixed wildcard
  faber: |
      discerne a, b {
        casu Active, _ { scribe "a is active" }
        casu _, Active { scribe "b is active" }
        casu _, _ { scribe "neither active" }
      }
  expect:
      ts:
          - "if (a.tag === 'Active')"
          - 'console.log("a is active")'
          - "else if (b.tag === 'Active')"
          - 'console.log("b is active")'
          - 'else {'
          - 'console.log("neither active")'
      fab:
          - 'discerne a, b'
          - 'casu Active, _'
          - 'casu _, Active'
          - 'casu _, _'
