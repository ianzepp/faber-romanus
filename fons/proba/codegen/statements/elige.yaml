# Elige statement - Switch/match on values
# Maps Faber elige to target-specific switch or match expressions
#
# Syntax:
#   elige discriminant {
#     casu value1 { consequent }
#     casu value2 { consequent }
#     ceterum { default }
#   }
#
# Target behaviors:
#   - TypeScript: if/else-if chain with === comparison
#   - Python: match/case statement (Python 3.10+)
#   - Rust: match expression
#   - C++: switch statement with break
#   - Zig: if/else-if chain (== or std.mem.eql for strings)

# =============================================================================
# Basic Elige with Cases
# =============================================================================

# Simple elige with numeric cases
- name: elige with numeric cases
  source: |
      elige x {
        casu 1 { a() }
        casu 2 { b() }
      }
  expect:
      ts:
          - 'if (x === 1)'
          - 'a();'
          - 'else if (x === 2)'
          - 'b();'
      py:
          - 'match x:'
          - 'case 1:'
          - 'a()'
          - 'case 2:'
          - 'b()'
      rs:
          - 'match x {'
          - '1 => a(),'
          - '2 => b(),'
      cpp:
          - 'switch (x) {'
          - 'case 1: {'
          - 'a();'
          - 'break;'
          - 'case 2: {'
          - 'b();'
          - 'break;'
      zig:
          - 'if ((x == 1))'
          - 'a();'
          - 'else if ((x == 2))'
          - 'b();'
      fab:
          - 'elige x'
          - 'casu 1'
          - 'a()'
          - 'casu 2'
          - 'b()'

# Elige with default case (ceterum)
- name: elige with default case
  source: |
      elige status {
        casu 1 { active() }
        ceterum { inactive() }
      }
  expect:
      ts:
          - 'if (status === 1)'
          - 'active();'
          - 'else {'
          - 'inactive();'
      py:
          - 'match status:'
          - 'case 1:'
          - 'active()'
          - 'case _:'
          - 'inactive()'
      rs:
          - 'match status {'
          - '1 => active(),'
          - '_ => inactive(),'
      cpp:
          - 'switch (status) {'
          - 'case 1: {'
          - 'active();'
          - 'break;'
          - 'default: {'
          - 'inactive();'
          - 'break;'
      zig:
          - 'if ((status == 1))'
          - 'active();'
          - 'else {'
          - 'inactive();'
      fab:
          - 'elige status'
          - 'casu 1'
          - 'active()'
          - 'ceterum'
          - 'inactive()'

# =============================================================================
# String Cases
# =============================================================================

# Elige with string literals
- name: elige with string cases
  source: |
      elige cmd {
        casu "start" { begin() }
        casu "stop" { end() }
        ceterum { unknown() }
      }
  expect:
      ts:
          - 'if (cmd === "start")'
          - 'begin();'
          - 'else if (cmd === "stop")'
          - 'end();'
          - 'else {'
          - 'unknown();'
      py:
          - 'match cmd:'
          - 'case "start":'
          - 'begin()'
          - 'case "stop":'
          - 'end()'
          - 'case _:'
          - 'unknown()'
      rs:
          - 'match cmd {'
          - 'String::from("start") => begin(),'
          - 'String::from("stop") => end(),'
          - '_ => unknown(),'
      cpp:
          - 'switch (cmd) {'
          - 'case std::string("start"): {'
          - 'begin();'
          - 'case std::string("stop"): {'
          - 'end();'
          - 'default: {'
          - 'unknown();'
      zig:
          - 'if (std.mem.eql(u8, cmd, "start"))'
          - 'begin();'
          - 'else if (std.mem.eql(u8, cmd, "stop"))'
          - 'end();'
          - 'else {'
          - 'unknown();'
      fab:
          - 'elige cmd'
          - 'casu "start"'
          - 'begin()'
          - 'casu "stop"'
          - 'end()'
          - 'ceterum'
          - 'unknown()'

# =============================================================================
# Multiple Statements in Cases
# =============================================================================

# Case with multiple statements
- name: elige case with multiple statements
  source: |
      elige mode {
        casu 1 {
          varia x = init()
          process(x)
          redde x
        }
        ceterum {
          redde nihil
        }
      }
  expect:
      ts:
          - 'if (mode === 1)'
          - 'let x = init();'
          - 'process(x);'
          - 'return x;'
          - 'else {'
          - 'return null;'
      py:
          - 'match mode:'
          - 'case 1:'
          - 'x = init()'
          - 'process(x)'
          - 'return x'
          - 'case _:'
          - 'return None'
      rs:
          - 'match mode {'
          - '1 => {'
          - 'let mut x = init();'
          - 'process(x);'
          - 'return x;'
          - '_ => None,'
      cpp:
          - 'switch (mode) {'
          - 'case 1: {'
          - 'auto x = init();'
          - 'process(x);'
          - 'return x;'
          - 'default: {'
          - 'return nullptr;'
      zig:
          - 'if ((mode == 1))'
          # WHY: anytype not valid for var declarations - Zig infers type
          - 'var x = init();'
          - 'process(x);'
          - 'return x;'
          - 'else {'
          - 'return null;'
      fab:
          - 'elige mode'
          - 'casu 1'
          - 'varia x = init()'
          - 'process(x)'
          - 'redde x'
          - 'ceterum'
          - 'redde nihil'

# =============================================================================
# Elige with Expressions
# =============================================================================

# Discriminant is expression, not just variable
- name: elige with expression discriminant
  source: |
      elige getValue() {
        casu 0 { zero() }
        casu 1 { one() }
      }
  expect:
      ts:
          - 'if (getValue() === 0)'
          - 'zero();'
          - 'else if (getValue() === 1)'
          - 'one();'
      py:
          - 'match getValue():'
          - 'case 0:'
          - 'zero()'
          - 'case 1:'
          - 'one()'
      rs:
          - 'match getValue() {'
          - '0 => zero(),'
          - '1 => one(),'
      cpp:
          - 'switch (getValue()) {'
          - 'case 0: {'
          - 'zero();'
          - 'case 1: {'
          - 'one();'
      zig:
          - 'if ((getValue() == 0))'
          - 'zero();'
          - 'else if ((getValue() == 1))'
          - 'one();'
      fab:
          - 'elige getValue()'
          - 'casu 0'
          - 'zero()'
          - 'casu 1'
          - 'one()'

# =============================================================================
# Elige with Cape (Catch Clause)
# =============================================================================

# Elige wrapped in try/catch
- name: elige with cape clause
  source: |
      elige riskyValue() {
        casu 1 { action() }
      }
      cape err {
        handleError(err)
      }
  expect:
      ts:
          - 'try {'
          - 'if (riskyValue() === 1)'
          - 'action();'
          - '} catch (err) {'
          - 'handleError(err);'
      py:
          - 'try:'
          - 'match riskyValue():'
          - 'case 1:'
          - 'action()'
          - 'except Exception as err:'
          - 'handleError(err)'
      fab:
          - 'elige riskyValue()'
          - 'casu 1'
          - 'action()'
          - 'cape err'
          - 'handleError(err)'

# =============================================================================
# Edge Cases
# =============================================================================

# Elige with only default case
- name: elige with only default case
  source: |
      elige x {
        ceterum { fallback() }
      }
  expect:
      ts:
          - '{'
          - 'fallback();'
      py:
          - 'match x:'
          - 'case _:'
          - 'fallback()'
      rs:
          - 'match x {'
          - '_ => fallback(),'
      cpp:
          - 'switch (x) {'
          - 'default: {'
          - 'fallback();'
      zig:
          - '{'
          - 'fallback();'
      fab:
          - 'elige x'
          - 'ceterum'
          - 'fallback()'

# Empty case body
- name: elige with empty case
  source: |
      elige x {
        casu 1 { }
        ceterum { action() }
      }
  expect:
      ts:
          - 'if (x === 1)'
          - 'else {'
          - 'action();'
      py:
          - 'match x:'
          - 'case 1:'
          - 'pass'
          - 'case _:'
          - 'action()'
      rs:
          - 'match x {'
          - '1 => {},'
          - '_ => action(),'
      cpp:
          - 'switch (x) {'
          - 'case 1: {'
          - 'break;'
          - 'default: {'
          - 'action();'
      zig:
          - 'if ((x == 1))'
          - 'else {'
          - 'action();'
      fab:
          - 'elige x'
          - 'casu 1'
          - 'ceterum'
          - 'action()'

# Elige with many cases (10+)
- name: elige with many cases month mapping
  source: |
      elige month {
        casu 1 { redde "Jan" }
        casu 2 { redde "Feb" }
        casu 3 { redde "Mar" }
        casu 4 { redde "Apr" }
        casu 5 { redde "May" }
        casu 6 { redde "Jun" }
        casu 7 { redde "Jul" }
        casu 8 { redde "Aug" }
        casu 9 { redde "Sep" }
        casu 10 { redde "Oct" }
        casu 11 { redde "Nov" }
        casu 12 { redde "Dec" }
        ceterum { redde "Unknown" }
      }
  expect:
      ts:
          - 'if (month === 1)'
          - 'return "Jan";'
          - 'else if (month === 2)'
          - 'return "Feb";'
          - 'else if (month === 12)'
          - 'return "Dec";'
          - 'else {'
          - 'return "Unknown";'
      py:
          - 'match month:'
          - 'case 1:'
          - 'return "Jan"'
          - 'case 12:'
          - 'return "Dec"'
          - 'case _:'
          - 'return "Unknown"'
      rs:
          - 'match month {'
          - '1 => String::from("Jan"),'
          - '12 => String::from("Dec"),'
          - '_ => String::from("Unknown"),'
      cpp:
          - 'switch (month) {'
          - 'case 1: {'
          - 'return std::string("Jan");'
          - 'case 12: {'
          - 'return std::string("Dec");'
          - 'default: {'
          - 'return std::string("Unknown");'
      fab:
          - 'elige month'
          - 'casu 1'
          - 'redde "Jan"'
          - 'casu 12'
          - 'redde "Dec"'
          - 'ceterum'
          - 'redde "Unknown"'

# Elige as potential expression (return in every case)
- name: elige with return in every case
  source: |
      elige level {
        casu 1 { redde "low" }
        casu 2 { redde "medium" }
        casu 3 { redde "high" }
        ceterum { redde "unknown" }
      }
  expect:
      ts:
          - 'if (level === 1)'
          - 'return "low";'
          - 'else if (level === 2)'
          - 'return "medium";'
          - 'else if (level === 3)'
          - 'return "high";'
          - 'else {'
          - 'return "unknown";'
      py:
          - 'match level:'
          - 'case 1:'
          - 'return "low"'
          - 'case 2:'
          - 'return "medium"'
          - 'case 3:'
          - 'return "high"'
          - 'case _:'
          - 'return "unknown"'
      rs:
          - 'match level {'
          - '1 => String::from("low"),'
          - '2 => String::from("medium"),'
          - '3 => String::from("high"),'
          - '_ => String::from("unknown"),'
      cpp:
          - 'switch (level) {'
          - 'case 1: {'
          - 'return std::string("low");'
          - 'case 2: {'
          - 'return std::string("medium");'
          - 'case 3: {'
          - 'return std::string("high");'
          - 'default: {'
          - 'return std::string("unknown");'
      fab:
          - 'elige level'
          - 'casu 1'
          - 'redde "low"'
          - 'casu 2'
          - 'redde "medium"'
          - 'casu 3'
          - 'redde "high"'
          - 'ceterum'
          - 'redde "unknown"'

# Elige with boolean cases
- name: elige with boolean cases
  source: 'elige flag { casu verum { yes() } casu falsum { no() } }'
  expect:
      ts:
          - 'if (flag === true)'
          - 'yes();'
          - 'else if (flag === false)'
          - 'no();'
      py:
          - 'match flag:'
          - 'case True:'
          - 'yes()'
          - 'case False:'
          - 'no()'
      rs:
          - 'match flag {'
          - 'true => yes(),'
          - 'false => no(),'
      cpp:
          - 'switch (flag) {'
          - 'case true: {'
          - 'yes();'
          - 'case false: {'
          - 'no();'
      fab:
          - 'elige flag'
          - 'casu verum'
          - 'yes()'
          - 'casu falsum'
          - 'no()'

# Elige with nested conditionals
- name: elige with nested si inside case
  source: |
      elige mode {
        casu 1 {
          si x > 0 {
            positive()
          } secus {
            nonPositive()
          }
        }
        casu 2 {
          action()
        }
      }
  expect:
      ts:
          - 'if (mode === 1)'
          - 'if ((x > 0))'
          - 'positive();'
          - 'else {'
          - 'nonPositive();'
          - 'else if (mode === 2)'
          - 'action();'
      py:
          - 'match mode:'
          - 'case 1:'
          - 'if (x > 0):'
          - 'positive()'
          - 'else:'
          - 'nonPositive()'
          - 'case 2:'
          - 'action()'
      rs:
          - 'match mode {'
          - '1 => {'
          - 'if (x > 0)'
          - 'positive();'
          - 'else {'
          - 'nonPositive();'
          - '2 => action(),'
      cpp:
          - 'switch (mode) {'
          - 'case 1: {'
          - 'if ((x > 0))'
          - 'positive();'
          - 'else {'
          - 'nonPositive();'
          - 'case 2: {'
          - 'action();'
      fab:
          - 'elige mode'
          - 'casu 1'
          - 'si x > 0'
          - 'positive()'
          - 'secus'
          - 'nonPositive()'
          - 'casu 2'
          - 'action()'

# Elige with member expression discriminant
- name: elige with member expression discriminant
  source: 'elige obj.status { casu 1 { active() } casu 0 { inactive() } }'
  expect:
      ts:
          - 'if (obj.status === 1)'
          - 'active();'
          - 'else if (obj.status === 0)'
          - 'inactive();'
      py:
          - 'match obj.status:'
          - 'case 1:'
          - 'active()'
          - 'case 0:'
          - 'inactive()'
      rs:
          - 'match obj.status {'
          - '1 => active(),'
          - '0 => inactive(),'
      cpp:
          - 'switch (obj.status) {'
          - 'case 1: {'
          - 'active();'
          - 'case 0: {'
          - 'inactive();'
      fab:
          - 'elige obj.status'
          - 'casu 1'
          - 'active()'
          - 'casu 0'
          - 'inactive()'

# Elige with call returning each case
- name: elige with function calls returning in cases
  source: |
      elige priority {
        casu 1 { redde getLow() }
        casu 2 { redde getMedium() }
        casu 3 { redde getHigh() }
      }
  expect:
      ts:
          - 'if (priority === 1)'
          - 'return getLow();'
          - 'else if (priority === 2)'
          - 'return getMedium();'
          - 'else if (priority === 3)'
          - 'return getHigh();'
      py:
          - 'match priority:'
          - 'case 1:'
          - 'return getLow()'
          - 'case 2:'
          - 'return getMedium()'
          - 'case 3:'
          - 'return getHigh()'
      rs:
          - 'match priority {'
          - '1 => getLow(),'
          - '2 => getMedium(),'
          - '3 => getHigh(),'
      cpp:
          - 'switch (priority) {'
          - 'case 1: {'
          - 'return getLow();'
          - 'case 2: {'
          - 'return getMedium();'
          - 'case 3: {'
          - 'return getHigh();'
      fab:
          - 'elige priority'
          - 'casu 1'
          - 'redde getLow()'
          - 'casu 2'
          - 'redde getMedium()'
          - 'casu 3'
          - 'redde getHigh()'

# Consecutive elige statements (single-line avoids parser issue with multiline consecutive elige)
- name: consecutive elige statements
  source: "elige a { casu 1 { first() } casu 2 { second() } }\nelige b { casu 3 { third() } casu 4 { fourth() } }"
  expect:
      ts:
          - 'if (a === 1)'
          - 'first();'
          - 'else if (a === 2)'
          - 'second();'
          - 'if (b === 3)'
          - 'third();'
          - 'else if (b === 4)'
          - 'fourth();'
      py:
          - 'match a:'
          - 'case 1:'
          - 'first()'
          - 'case 2:'
          - 'second()'
          - 'match b:'
          - 'case 3:'
          - 'third()'
          - 'case 4:'
          - 'fourth()'
      rs:
          - 'match a {'
          - '1 => first(),'
          - '2 => second(),'
          - 'match b {'
          - '3 => third(),'
          - '4 => fourth(),'
      cpp:
          - 'switch (a) {'
          - 'case 1: {'
          - 'first();'
          - 'case 2: {'
          - 'second();'
          - 'switch (b) {'
          - 'case 3: {'
          - 'third();'
          - 'case 4: {'
          - 'fourth();'
      fab:
          - 'elige a'
          - 'casu 1'
          - 'first()'
          - 'casu 2'
          - 'second()'
          - 'elige b'
          - 'casu 3'
          - 'third()'
          - 'casu 4'
          - 'fourth()'
