# Importa declaration - Module import statements
# Maps Faber ex...importa to target-specific import syntax
#
# Syntax:
#   ex source importa name1, name2
#   ex source importa name ut alias
#   ex source importa *
#
# Target behaviors:
#   - TypeScript: import { } from ""; norma imports suppressed
#   - Python: from import
#   - Rust: use ::{}; norma imports suppressed
#   - C++: Tracked for #include generation (rendered at top)
#   - Zig: const _ = @import(); const name = _.name;

# =============================================================================
# External Package Imports
# =============================================================================

# Basic named imports
- name: basic named imports
  source: 'ex "@hono/hono" importa Hono, Context'
  expect:
      ts:
          - 'import { Hono, Context } from "@hono/hono";'
      py:
          - 'from @hono/hono import Hono, Context'
      rs:
          - 'use @hono/hono::{Hono, Context};'
      cpp: [] # C++ renders includes at top of file, not inline
      zig:
          - 'const _@hono/hono = @import("@hono/hono");'
          - 'const Hono = _@hono/hono.Hono;'
          - 'const Context = _@hono/hono.Context;'
      fab:
          - 'importa { Hono, Context } ex "@hono/hono"'

# Single named import
- name: single named import
  source: 'ex "lodash" importa map'
  expect:
      ts:
          - 'import { map } from "lodash";'
      py:
          - 'from lodash import map'
      rs:
          - 'use lodash::map;'
      cpp: []
      zig:
          - 'const _lodash = @import("lodash");'
          - 'const map = _lodash.map;'
      fab:
          - 'importa { map } ex "lodash"'

# Wildcard import (without alias - passes through literally)
- name: wildcard import
  source: 'ex "@std/crypto" importa *'
  expect:
      ts:
          - 'import * from "@std/crypto";'
      py:
          - 'import @std/crypto'
      rs:
          - 'use @std/crypto::*;'
      cpp: []
      zig:
          - 'const @std/crypto = @import("@std/crypto");'
      fab:
          - 'importa * ex "@std/crypto"'

# Wildcard import with alias (required for TypeScript)
- name: wildcard import with alias
  source: 'ex "@std/crypto" importa * ut crypto'
  expect:
      ts:
          - 'import * as crypto from "@std/crypto";'
      py:
          - 'import @std/crypto as crypto'
      rs:
          - 'use @std/crypto::* as crypto;'
      cpp: []
      zig:
          - 'const crypto = @import("@std/crypto");'
      fab:
          - 'importa * ut crypto ex "@std/crypto"'

# =============================================================================
# Import with Aliases (ut keyword)
# =============================================================================

# Single import with alias
- name: import with alias
  source: 'ex "utils" importa helper ut h'
  expect:
      ts:
          - 'import { helper as h } from "utils";'
      py:
          - 'from utils import helper as h'
      rs:
          - 'use utils::helper as h;'
      cpp: []
      zig:
          - 'const _utils = @import("utils");'
          - 'const h = _utils.helper;'
      fab:
          - 'importa { helper ut h } ex "utils"'

# Multiple imports with mixed aliases
- name: imports with mixed aliases
  source: 'ex "db" importa connect, query ut q, close'
  expect:
      ts:
          - 'import { connect, query as q, close } from "db";'
      py:
          - 'from db import connect, query as q, close'
      rs:
          - 'use db::{connect, query as q, close};'
      cpp: []
      zig:
          - 'const _db = @import("db");'
          - 'const connect = _db.connect;'
          - 'const q = _db.query;'
          - 'const close = _db.close;'
      fab:
          - 'importa { connect, query ut q, close } ex "db"'

# =============================================================================
# Norma Intrinsic Imports (TypeScript/Rust only)
# =============================================================================

# norma imports are suppressed in TS and Rust (handled as intrinsics)
- name: norma import suppressed in ts and rs
  source: 'ex "norma/tempus" importa nunc, SECUNDUM'
  expect:
      ts: [] # Empty - norma imports are suppressed
      py:
          - 'from norma/tempus import nunc, SECUNDUM'
      rs: [] # Empty - norma imports are suppressed
      cpp: []
      zig:
          - 'const _norma/tempus = @import("norma/tempus");'
          - 'const nunc = _norma/tempus.nunc;'
          - 'const SECUNDUM = _norma/tempus.SECUNDUM;'
      fab:
          - 'importa { nunc, SECUNDUM } ex "norma/tempus"'

# norma wildcard import
- name: norma wildcard import
  source: 'ex "norma" importa *'
  expect:
      ts: []
      py:
          - 'import norma'
      rs: []
      cpp: []
      zig:
          - 'const norma = @import("norma");'
      fab:
          - 'importa * ex "norma"'

# =============================================================================
# Multiple Import Statements
# =============================================================================

# Two separate imports from different sources
- name: multiple imports from different sources
  source: |
      ex "@oak/oak" importa Application
      ex "std/path" importa join, resolve
  expect:
      ts:
          - 'import { Application } from "@oak/oak";'
          - 'import { join, resolve } from "std/path";'
      py:
          - 'from @oak/oak import Application'
          - 'from std/path import join, resolve'
      rs:
          - 'use @oak/oak::Application;'
          - 'use std/path::{join, resolve};'
      cpp: []
      zig:
          - 'const _@oak/oak = @import("@oak/oak");'
          - 'const Application = _@oak/oak.Application;'
          - 'const _std/path = @import("std/path");'
          - 'const join = _std/path.join;'
          - 'const resolve = _std/path.resolve;'
      fab:
          - 'importa { Application } ex "@oak/oak"'
          - 'importa { join, resolve } ex "std/path"'

# =============================================================================
# Edge Cases
# =============================================================================

# Import with special characters in source
- name: import with scoped package
  source: 'ex "@types/node" importa Process'
  expect:
      ts:
          - 'import { Process } from "@types/node";'
      py:
          - 'from @types/node import Process'
      rs:
          - 'use @types/node::Process;'
      cpp: []
      zig:
          - 'const _@types/node = @import("@types/node");'
          - 'const Process = _@types/node.Process;'
      fab:
          - 'importa { Process } ex "@types/node"'

# Relative import path
- name: relative import
  source: 'ex "./utils" importa helper'
  expect:
      ts:
          - 'import { helper } from "./utils";'
      py:
          - 'from ./utils import helper'
      rs:
          - 'use ./utils::helper;'
      cpp: []
      zig:
          - 'const _./utils = @import("./utils");'
          - 'const helper = _./utils.helper;'
      fab:
          - 'importa { helper } ex "./utils"'

# All names aliased
- name: all imports aliased
  source: 'ex "lib" importa foo ut f, bar ut b'
  expect:
      ts:
          - 'import { foo as f, bar as b } from "lib";'
      py:
          - 'from lib import foo as f, bar as b'
      rs:
          - 'use lib::{foo as f, bar as b};'
      cpp: []
      zig:
          - 'const _lib = @import("lib");'
          - 'const f = _lib.foo;'
          - 'const b = _lib.bar;'
      fab:
          - 'importa { foo ut f, bar ut b } ex "lib"'

# Import with very long path
- name: import with very long path
  source: 'ex "@organization/package-name/deeply/nested/module" importa thing'
  expect:
      ts:
          - 'import { thing } from "@organization/package-name/deeply/nested/module";'
      py:
          - 'from @organization/package-name/deeply/nested/module import thing'
      rs:
          - 'use @organization/package-name/deeply/nested/module::thing;'
      cpp: []
      zig:
          - 'const _@organization/package-name/deeply/nested/module = @import("@organization/package-name/deeply/nested/module");'
          - 'const thing = _@organization/package-name/deeply/nested/module.thing;'
      fab:
          - 'importa { thing } ex "@organization/package-name/deeply/nested/module"'

# Import many named items (5+)
- name: import many named items
  source: 'ex "utils" importa a, b, c, d, e, f'
  expect:
      ts:
          - 'import { a, b, c, d, e, f } from "utils";'
      py:
          - 'from utils import a, b, c, d, e, f'
      rs:
          - 'use utils::{a, b, c, d, e, f};'
      cpp: []
      zig:
          - 'const _utils = @import("utils");'
          - 'const a = _utils.a;'
          - 'const b = _utils.b;'
          - 'const c = _utils.c;'
          - 'const d = _utils.d;'
          - 'const e = _utils.e;'
          - 'const f = _utils.f;'
      fab:
          - 'importa { a, b, c, d, e, f } ex "utils"'

# Import with multiple aliases
- name: import with multiple aliases
  source: 'ex "mod" importa foo ut f, bar ut b, baz ut z'
  expect:
      ts:
          - 'import { foo as f, bar as b, baz as z } from "mod";'
      py:
          - 'from mod import foo as f, bar as b, baz as z'
      rs:
          - 'use mod::{foo as f, bar as b, baz as z};'
      cpp: []
      zig:
          - 'const _mod = @import("mod");'
          - 'const f = _mod.foo;'
          - 'const b = _mod.bar;'
          - 'const z = _mod.baz;'
      fab:
          - 'importa { foo ut f, bar ut b, baz ut z } ex "mod"'

# Import from parent directory
- name: import from parent directory
  source: 'ex "../shared/utils" importa helper'
  expect:
      ts:
          - 'import { helper } from "../shared/utils";'
      py:
          - 'from ../shared/utils import helper'
      rs:
          - 'use ../shared/utils::helper;'
      cpp: []
      zig:
          - 'const _../shared/utils = @import("../shared/utils");'
          - 'const helper = _../shared/utils.helper;'
      fab:
          - 'importa { helper } ex "../shared/utils"'

# Import from sibling directory
- name: import from sibling directory
  source: 'ex "./sibling/module" importa Component'
  expect:
      ts:
          - 'import { Component } from "./sibling/module";'
      py:
          - 'from ./sibling/module import Component'
      rs:
          - 'use ./sibling/module::Component;'
      cpp: []
      zig:
          - 'const _./sibling/module = @import("./sibling/module");'
          - 'const Component = _./sibling/module.Component;'
      fab:
          - 'importa { Component } ex "./sibling/module"'

# Multiple imports from same source
- name: multiple imports from same source
  source: |
      ex "common" importa foo
      ex "common" importa bar
  expect:
      ts:
          - 'import { foo } from "common";'
          - 'import { bar } from "common";'
      py:
          - 'from common import foo'
          - 'from common import bar'
      rs:
          - 'use common::foo;'
          - 'use common::bar;'
      cpp: []
      zig:
          - 'const _common = @import("common");'
          - 'const foo = _common.foo;'
          - 'const _common = @import("common");'
          - 'const bar = _common.bar;'
      fab:
          - 'importa { foo } ex "common"'
          - 'importa { bar } ex "common"'
