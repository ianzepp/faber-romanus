# Pactum declarations - interface/protocol/trait definitions
# Maps Faber pactum syntax to target-language interface mechanisms
#
# Syntax:
#   pactum Name { functio methodName(params) -> returnType }
#   pactum Name<T> { ... }  -- generic interfaces
#
# Target mappings:
#   TypeScript: interface
#   Python: Protocol (from typing)
#   Rust: trait
#   C++: concept (C++20)
#   Zig: comment (duck typing)

# =============================================================================
# Simple Pactum
# =============================================================================

# Basic interface with one method
- name: simple pactum with one method
  source: 'pactum Greeter { functio greet() -> textus }'
  expect:
      ts:
          - 'interface Greeter'
          - 'greet(): string'
      py:
          - 'class Greeter(Protocol):'
          - 'def greet(self) -> str: ...'
      rs:
          - 'trait Greeter'
          - 'fn greet(&self) -> String;'
      cpp:
          - 'template<typename T>'
          - 'concept Greeter'
          - 't.greet()'
      zig:
          - '// pactum Greeter'
          - '//   requires fn greet() []const u8'
      fab:
          - 'pactum Greeter'
          - 'functio greet() -> textus'

# Multiple methods
# WHY: 'lege' is now a reserved keyword for stdin reading, using 'accipe' (receive) instead
- name: pactum with multiple methods
  source: |
      pactum Readable {
        functio accipe() -> textus
        functio claude() -> vacuum
      }
  expect:
      ts:
          - 'interface Readable'
          - 'accipe(): string'
          - 'claude(): void'
      py:
          - 'class Readable(Protocol):'
          - 'def accipe(self) -> str: ...'
          - 'def claude(self) -> None: ...'
      rs:
          - 'trait Readable'
          - 'fn accipe(&self) -> String;'
          - 'fn claude(&self) -> ();'
      cpp:
          - 'concept Readable'
      zig:
          - '// pactum Readable'
      fab:
          - 'pactum Readable'
          - 'functio accipe() -> textus'
          - 'functio claude() -> vacuum'

# =============================================================================
# Method Parameters
# =============================================================================

# Method with typed parameter
- name: pactum method with parameter
  source: 'pactum Comparable { functio compare(numerus other) -> numerus }'
  expect:
      ts:
          - 'interface Comparable'
          - 'compare(other: number): number'
      py:
          - 'class Comparable(Protocol):'
          - 'def compare(self, other: int) -> int: ...'
      rs:
          - 'trait Comparable'
          - 'fn compare(&self, other: i64) -> i64;'
      cpp:
          - 'concept Comparable'
      zig:
          - '// pactum Comparable'
      fab:
          - 'pactum Comparable'
          - 'functio compare(numerus other) -> numerus'

# =============================================================================
# Type Parameters (Generics)
# =============================================================================

# Generic pactum with type parameter
- name: pactum with type parameter
  source: 'pactum Container<T> { functio adde(T item) -> vacuum }'
  expect:
      ts:
          - 'interface Container<T>'
          - 'adde(item: T): void'
      py:
          - 'class Container[T](Protocol):'
          - 'def adde(self, item: T) -> None: ...'
      rs:
          - 'trait Container<T>'
          - 'fn adde(&self, item: T) -> ();'
      cpp:
          - 'concept Container'
      zig:
          - '// pactum Container'
      fab:
          - 'pactum Container<T>'
          - 'functio adde(T item) -> vacuum'

# =============================================================================
# Async Methods
# =============================================================================

# Async method (@ futura annotation)
- name: pactum with async method
  source: |
      pactum Fetcher {
          @ futura
          functio fetch() -> textus
      }
  expect:
      ts:
          - 'interface Fetcher'
          - 'fetch(): Promise<string>'
      py:
          - 'class Fetcher(Protocol):'
          - 'async def fetch(self) -> Awaitable[str]: ...'
      rs:
          - 'trait Fetcher'
          - 'async fn fetch(&self) -> String;'
      cpp:
          - 'concept Fetcher'
      zig:
          - '// pactum Fetcher'
      fab:
          - 'pactum Fetcher'
          - '@ futura'
          - 'functio fetch() -> textus'

# =============================================================================
# Empty Pactum
# =============================================================================

# Empty pactum (marker interface)
- name: empty pactum
  source: 'pactum Marker { }'
  expect:
      ts:
          - 'interface Marker {'
          - '}'
      py:
          - 'class Marker(Protocol):'
          - 'pass'
      rs:
          - 'trait Marker {'
          - '}'
      cpp:
          - 'concept Marker'
      zig:
          - '// pactum Marker'
      fab:
          - 'pactum Marker'

# =============================================================================
# Edge Cases
# =============================================================================

# Pactum with getter method (simulates property access)
- name: pactum with getter method
  source: |
      pactum Entity {
        functio id() -> textus
      }
  expect:
      ts:
          - 'interface Entity'
          - 'id(): string'
      py:
          - 'class Entity(Protocol):'
          - 'def id(self) -> str: ...'
      rs:
          - 'trait Entity'
          - 'fn id(&self) -> String;'
      cpp:
          - 'concept Entity'
      zig:
          - '// pactum Entity'
      fab:
          - 'pactum Entity'
          - 'functio id() -> textus'

# Pactum with multiple type parameters
- name: pactum with multiple type parameters
  source: 'pactum Mapper<K, V> { functio map(K key) -> V }'
  expect:
      ts:
          - 'interface Mapper<K, V>'
          - 'map(key: K): V'
      py:
          - 'class Mapper[K, V](Protocol):'
          - 'def map(self, key: K) -> V: ...'
      rs:
          - 'trait Mapper<K, V>'
          - 'fn map(&self, key: K) -> V;'
      cpp:
          - 'concept Mapper'
      zig:
          - '// pactum Mapper'
      fab:
          - 'pactum Mapper<K, V>'
          - 'functio map(K key) -> V'

# Pactum with many methods (CRUD operations)
# WHY: 'lege' is now a reserved keyword for stdin reading, using 'accipe' (receive) instead
- name: pactum with many methods
  source: |
      pactum Repository {
        functio crea() -> vacuum
        functio accipe() -> textus
        functio renova() -> vacuum
        functio dele() -> vacuum
        functio inveni() -> textus
      }
  expect:
      ts:
          - 'interface Repository'
          - 'crea(): void'
          - 'accipe(): string'
          - 'renova(): void'
          - 'dele(): void'
          - 'inveni(): string'
      py:
          - 'class Repository(Protocol):'
          - 'def crea(self) -> None: ...'
          - 'def accipe(self) -> str: ...'
          - 'def renova(self) -> None: ...'
          - 'def dele(self) -> None: ...'
          - 'def inveni(self) -> str: ...'
      rs:
          - 'trait Repository'
          - 'fn crea(&self) -> ();'
          - 'fn accipe(&self) -> String;'
          - 'fn renova(&self) -> ();'
          - 'fn dele(&self) -> ();'
          - 'fn inveni(&self) -> String;'
      cpp:
          - 'concept Repository'
      zig:
          - '// pactum Repository'
      fab:
          - 'pactum Repository'
          - 'functio crea() -> vacuum'
          - 'functio accipe() -> textus'
          - 'functio renova() -> vacuum'
          - 'functio dele() -> vacuum'
          - 'functio inveni() -> textus'

# Pactum with mixed async and sync methods
- name: pactum with mixed async and sync methods
  source: |
      pactum DataService {
        functio sync() -> textus
        @ futura
        functio async() -> textus
      }
  expect:
      ts:
          - 'interface DataService'
          - 'sync(): string'
          - 'async(): Promise<string>'
      py:
          - 'class DataService(Protocol):'
          - 'def sync(self) -> str: ...'
          - 'async def async(self) -> Awaitable[str]: ...'
      rs:
          - 'trait DataService'
          - 'fn sync(&self) -> String;'
          - 'async fn async(&self) -> String;'
      cpp:
          - 'concept DataService'
      zig:
          - '// pactum DataService'
      fab:
          - 'pactum DataService'
          - 'functio sync() -> textus'
          - '@ futura'
          - 'functio async() -> textus'

# Pactum with generic constraint
- name: pactum with generic constraint
  source: 'pactum Comparable<T> { functio compare(T other) -> numerus }'
  expect:
      ts:
          - 'interface Comparable<T>'
          - 'compare(other: T): number'
      py:
          - 'class Comparable[T](Protocol):'
          - 'def compare(self, other: T) -> int: ...'
      rs:
          - 'trait Comparable<T>'
          - 'fn compare(&self, other: T) -> i64;'
      cpp:
          - 'concept Comparable'
      zig:
          - '// pactum Comparable'
      fab:
          - 'pactum Comparable<T>'
          - 'functio compare(T other) -> numerus'

# Pactum with void and value-returning methods
- name: pactum with void and value-returning methods
  source: |
      pactum Service {
        functio start() -> vacuum
        functio status() -> textus
        functio stop() -> vacuum
        functio config() -> textus
      }
  expect:
      ts:
          - 'interface Service'
          - 'start(): void'
          - 'status(): string'
          - 'stop(): void'
          - 'config(): string'
      py:
          - 'class Service(Protocol):'
          - 'def start(self) -> None: ...'
          - 'def status(self) -> str: ...'
          - 'def stop(self) -> None: ...'
          - 'def config(self) -> str: ...'
      rs:
          - 'trait Service'
          - 'fn start(&self) -> ();'
          - 'fn status(&self) -> String;'
          - 'fn stop(&self) -> ();'
          - 'fn config(&self) -> String;'
      cpp:
          - 'concept Service'
      zig:
          - '// pactum Service'
      fab:
          - 'pactum Service'
          - 'functio start() -> vacuum'
          - 'functio status() -> textus'
          - 'functio stop() -> vacuum'
          - 'functio config() -> textus'
