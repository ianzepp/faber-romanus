# Object expressions - object literals
# Maps Faber object syntax to target-language equivalents
#
# Note: ts/py use exact match; rs/cpp/zig use contains (they wrap in main)

- name: empty object
  source: 'fixum obj = {}'
  expect:
      ts: 'const obj = {};'
      py: 'obj = {}'
      rs:
          - 'let obj = {};'
      cpp:
          - '{}'
      zig:
          - '.{}'
      fab:
          - 'fixum obj = {}'

- name: object with string property
  source: |
      fixum user = { nomen: "Marcus" }
  expect:
      ts: 'const user = { nomen: "Marcus" };'
      py: 'user = {"nomen": "Marcus"}'
      rs:
          - 'nomen: String::from("Marcus")'
      cpp:
          - '.nomen = std::string("Marcus")'
      zig:
          - '.nomen = "Marcus"'
      fab:
          - 'fixum user = { nomen: "Marcus" }'

- name: object with multiple properties
  source: |
      fixum data = { x: 1, y: 2, z: 3 }
  expect:
      ts: 'const data = { x: 1, y: 2, z: 3 };'
      py: 'data = {"x": 1, "y": 2, "z": 3}'
      rs:
          - 'x: 1'
          - 'y: 2'
          - 'z: 3'
      cpp:
          - '.x = 1'
          - '.y = 2'
          - '.z = 3'
      zig:
          - '.x = 1'
          - '.y = 2'
          - '.z = 3'
      fab:
          - 'fixum data = { x: 1, y: 2, z: 3 }'

- name: object with expression values
  source: |
      fixum calc = { sum: 1 + 2, active: verum }
  expect:
      ts:
          - 'sum: (1 + 2)'
          - 'active: true'
      py:
          - '"sum": (1 + 2)'
          - '"active": True'
      rs:
          - 'sum: (1 + 2)'
          - 'active: true'
      cpp:
          - '.sum = (1 + 2)'
          - '.active = true'
      zig:
          - '.sum = (1 + 2)'
          - '.active = true'
      fab:
          - 'sum: 1 + 2'
          - 'active: verum'

- name: object with spread
  source: |
      fixum merged = { sparge defaults, extra: 42 }
  expect:
      ts: 'const merged = { ...defaults, extra: 42 };'
      py: 'merged = {**defaults, "extra": 42}'
      rs:
          - '..defaults'
          - 'extra: 42'
      fab:
          - 'sparge defaults'
          - 'extra: 42'

- name: method in object (lambda as property)
  source: |
      fixum obj = { greet: pro name: name }
  expect:
      ts:
          - 'greet: (name) => name'
      py:
          - '"greet": lambda name: name'
      fab:
          - 'greet: pro name: name'

- name: deeply nested objects (4 levels)
  source: |
      fixum deep = { a: { b: { c: { d: 1 } } } }
  expect:
      ts: 'const deep = { a: { b: { c: { d: 1 } } } };'
      py: 'deep = {"a": {"b": {"c": {"d": 1}}}}'
      fab:
          - 'a: { b: { c: { d: 1 } } }'

- name: multiple spreads in object
  source: |
      fixum obj = { a: 1, sparge middle, b: 2, sparge end }
  expect:
      ts: 'const obj = { a: 1, ...middle, b: 2, ...end };'
      py: 'obj = {"a": 1, **middle, "b": 2, **end}'
      fab:
          - 'a: 1'
          - 'sparge middle'
          - 'b: 2'
          - 'sparge end'

- name: object with many properties (6+)
  source: |
      fixum obj = { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6 }
  expect:
      ts: 'const obj = { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6 };'
      py: 'obj = {"a": 1, "b": 2, "c": 3, "d": 4, "e": 5, "f": 6}'
      fab:
          - 'a: 1, b: 2, c: 3, d: 4, e: 5, f: 6'

- name: object with arithmetic expression values
  source: |
      fixum obj = { sum: a + b, product: a * b }
  expect:
      ts:
          - 'sum: (a + b)'
          - 'product: (a * b)'
      py:
          - '"sum": (a + b)'
          - '"product": (a * b)'
      fab:
          - 'sum: a + b'
          - 'product: a * b'
