# Assignment expressions - simple and compound assignment
# Maps Faber assignment syntax to target-language equivalents

- name: simple assignment
  source: x = 5
  expect:
      ts: 'x = 5;'
      py: 'x = 5'
      rs:
          - 'x = 5;'
      cpp:
          - 'x = 5;'
      zig:
          - 'x = 5;'
      fab:
          - 'x = 5'

- name: addition assignment
  source: x += 1
  expect:
      ts: 'x += 1;'
      py: 'x += 1'
      rs:
          - 'x += 1;'
      cpp:
          - 'x += 1;'
      zig:
          - 'x += 1;'
      fab:
          - 'x += 1'

- name: subtraction assignment
  source: x -= 1
  expect:
      ts: 'x -= 1;'
      py: 'x -= 1'
      rs:
          - 'x -= 1;'
      cpp:
          - 'x -= 1;'
      zig:
          - 'x -= 1;'
      fab:
          - 'x -= 1'

- name: multiplication assignment
  source: x *= 2
  expect:
      ts: 'x *= 2;'
      py: 'x *= 2'
      rs:
          - 'x *= 2;'
      cpp:
          - 'x *= 2;'
      zig:
          - 'x *= 2;'
      fab:
          - 'x *= 2'

- name: division assignment
  source: x /= 2
  expect:
      ts: 'x /= 2;'
      py: 'x /= 2'
      rs:
          - 'x /= 2;'
      cpp:
          - 'x /= 2;'
      zig:
          - 'x = @divTrunc(x, 2)'
      fab:
          - 'x /= 2'

- name: member assignment
  source: obj.prop = value
  expect:
      ts: 'obj.prop = value;'
      py: 'obj.prop = value'
      rs:
          - 'obj.prop = value;'
      cpp:
          - 'obj.prop = value;'
      zig:
          - 'obj.prop = value;'
      fab:
          - 'obj.prop = value'

- name: modulo assignment
  source: x %= 3
  expect:
      ts: 'x %= 3;'
      py: 'x %= 3'
      rs:
          - 'x %= 3;'
      cpp:
          - 'x %= 3;'
      zig:
          - 'x = @mod(x, 3)'
      fab:
          - 'x %= 3'

- name: deeply nested member assignment
  source: a.b.c.d.e = 5
  expect:
      ts: 'a.b.c.d.e = 5;'
      py: 'a.b.c.d.e = 5'
      rs:
          - 'a.b.c.d.e = 5;'
      cpp:
          - 'a.b.c.d.e = 5;'
      zig:
          - 'a.b.c.d.e = 5;'
      fab:
          - 'a.b.c.d.e = 5'

- name: assignment to array index
  source: arr[i] = newValue
  expect:
      ts: 'arr[i] = newValue;'
      py: 'arr[i] = newValue'
      rs:
          - 'arr[i] = newValue;'
      cpp:
          - 'arr[i] = newValue;'
      zig:
          - 'arr[i] = newValue;'
      fab:
          - 'arr[i] = newValue'

- name: assignment to tabula index (typed)
  source: 'm["a"] = 1'
  wrap: 'functio f(tabula<textus, numerus> m) { $ }'
  expect:
      ts:
          - 'function f(m: Map<string, number>)'
          - 'm.set("a", __next)'

- name: assignment with expression index
  source: arr[i + 1] = value
  expect:
      ts: 'arr[i + 1] = value;'
      py: 'arr[i + 1] = value'
      rs:
          - 'arr[i + 1] = value;'
      cpp:
          - 'arr[i + 1] = value;'
      zig:
          - 'arr[i + 1] = value;'
      fab:
          - 'arr[i + 1] = value'

- name: assignment with call on right side
  source: result = compute()
  expect:
      ts: 'result = compute();'
      py: 'result = compute()'
      rs:
          - 'result = compute();'
      cpp:
          - 'result = compute();'
      zig:
          - 'result = compute();'
      fab:
          - 'result = compute()'

- name: assignment with binary expression
  source: total = a + b + c
  expect:
      ts: 'total = a + b + c;'
      py: 'total = a + b + c'
      rs:
          - 'total = a + b + c;'
      cpp:
          - 'total = a + b + c;'
      zig:
          - 'total = a + b + c;'
      fab:
          - 'total = a + b + c'

- name: compound with member
  source: obj.count += 1
  expect:
      ts: 'obj.count += 1;'
      py: 'obj.count += 1'
      rs:
          - 'obj.count += 1;'
      cpp:
          - 'obj.count += 1;'
      zig:
          - 'obj.count += 1;'
      fab:
          - 'obj.count += 1'
