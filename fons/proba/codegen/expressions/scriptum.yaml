# Scriptum expressions - format string functionality
# Maps Faber scriptum() to target-language format string equivalents
#
# Faber supports two placeholder syntaxes:
#   {} - traditional placeholder (compatible with most format string libraries)
#   §  - section sign placeholder (preferred, avoids escaping issues with braces)

- name: scriptum with single argument
  faber: 'scriptum("Hello, {}", name)'
  wrap: 'cura arena fit alloc { $ }'
  expect:
      ts:
          - '`Hello, ${name}`'
      py:
          - '"Hello, {}".format(name)'
      rs:
          - 'format!("Hello, {}", name)'
      cpp:
          - 'std::format("Hello, {}", name)'
      zig:
          - 'std.fmt.allocPrint(alloc, "Hello, {}", .{ name }) catch @panic("OOM")'
      fab:
          - 'scriptum("Hello, {}", name)'

- name: scriptum with multiple arguments
  faber: 'scriptum("{} + {} = {}", a, b, c)'
  wrap: 'cura arena fit alloc { $ }'
  expect:
      ts:
          - '`${a} + ${b} = ${c}`'
      py:
          - '"{} + {} = {}".format(a, b, c)'
      rs:
          - 'format!("{} + {} = {}", a, b, c)'
      cpp:
          - 'std::format("{} + {} = {}", a, b, c)'
      zig:
          - 'std.fmt.allocPrint(alloc, "{} + {} = {}", .{ a, b, c }) catch @panic("OOM")'
      fab:
          - 'scriptum("{} + {} = {}", a, b, c)'

- name: scriptum with no arguments (constant string)
  faber: 'scriptum("Hello, World!")'
  wrap: 'cura arena fit alloc { $ }'
  expect:
      ts:
          - '"Hello, World!"'
      py:
          - '"Hello, World!"'
      rs:
          - '"Hello, World!".to_string()'
      cpp:
          - '"Hello, World!"'
      zig:
          - '"Hello, World!"'
      fab:
          - 'scriptum("Hello, World!")'

- name: scriptum in variable assignment
  faber: 'fixum greeting = scriptum("Hello, {}", name)'
  wrap: 'cura arena fit alloc { $ }'
  expect:
      ts:
          - 'const greeting = `Hello, ${name}`'
      py:
          - 'greeting = "Hello, {}".format(name)'
      rs:
          - 'let greeting = format!("Hello, {}", name)'
      cpp:
          - 'const auto greeting = std::format("Hello, {}", name)'
      zig:
          - 'const greeting = std.fmt.allocPrint(alloc, "Hello, {}", .{ name }) catch @panic("OOM")'
      fab:
          - 'fixum greeting = scriptum("Hello, {}", name)'

- name: scriptum with expression argument
  faber: 'scriptum("Result: {}", a + b)'
  wrap: 'cura arena fit alloc { $ }'
  expect:
      ts:
          - '`Result: ${(a + b)}`'
      py:
          - '"Result: {}".format((a + b))'
      rs:
          - 'format!("Result: {}", (a + b))'
      cpp:
          - 'std::format("Result: {}", (a + b))'
      zig:
          - 'std.fmt.allocPrint(alloc, "Result: {}", .{ (a + b) }) catch @panic("OOM")'
      fab:
          - 'scriptum("Result: {}", a + b)'

# Section sign (§) placeholder tests

- name: scriptum with section sign placeholder
  faber: 'scriptum("Hello, §!", name)'
  wrap: 'cura arena fit alloc { $ }'
  expect:
      ts:
          - '`Hello, ${name}!`'
      py:
          - '"Hello, {}!".format(name)'
      rs:
          - 'format!("Hello, {}!", name)'
      cpp:
          - 'std::format("Hello, {}!", name)'
      zig:
          - 'std.fmt.allocPrint(alloc, "Hello, {any}!", .{ name }) catch @panic("OOM")'
      fab:
          - 'scriptum("Hello, §!", name)'

- name: scriptum with multiple section sign placeholders
  faber: 'scriptum("§ + § = §", a, b, c)'
  wrap: 'cura arena fit alloc { $ }'
  expect:
      ts:
          - '`${a} + ${b} = ${c}`'
      py:
          - '"{} + {} = {}".format(a, b, c)'
      rs:
          - 'format!("{} + {} = {}", a, b, c)'
      cpp:
          - 'std::format("{} + {} = {}", a, b, c)'
      zig:
          - 'std.fmt.allocPrint(alloc, "{any} + {any} = {any}", .{ a, b, c }) catch @panic("OOM")'
      fab:
          - 'scriptum("§ + § = §", a, b, c)'
