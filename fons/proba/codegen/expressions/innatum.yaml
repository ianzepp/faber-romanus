# Innatum expressions - native type construction
# Maps Faber innatum to target-language native constructors
#
# Note: ts uses new Map() for tabula, Python uses {} (dict)
# Note: Rust uses HashMap::new(), Zig uses std.AutoHashMap().init()
# Note: C++ uses std::map{} and std::vector{}

- name: empty tabula with types
  source: varia x = {} innatum tabula<textus, numerus>
  expect:
      ts: 'let x = new Map<string, number>();'
      py: 'x = {}'
      rs:
          - 'let mut x = HashMap::new();'
      cpp:
          - 'std::map<std::string, int64_t>{}'
      zig:
          - 'std.AutoHashMap([]const u8, i64).init(alloc)'
      fab:
          - 'varia x = {} innatum tabula<textus, numerus>'

- name: empty lista with type
  source: varia items = [] innatum lista<textus>
  expect:
      ts: 'let items = ([] as string[]);'
      py: 'items = []'
      rs:
          - 'let mut items = Vec::new();'
      cpp:
          - 'std::vector<std::string>{}'
      zig:
          - 'Lista([]const u8).init(alloc)'
      fab:
          - 'varia items = [] innatum lista<textus>'

- name: const tabula
  source: fixum cache = {} innatum tabula<textus, bivalens>
  expect:
      ts: 'const cache = new Map<string, boolean>();'
      py: 'cache = {}'
      rs:
          - 'let cache = HashMap::new();'
      cpp:
          - 'std::map<std::string, bool>{}'
      zig:
          - 'std.AutoHashMap([]const u8, bool).init(alloc)'
      fab:
          - 'fixum cache = {} innatum tabula<textus, bivalens>'

- name: const lista
  source: fixum names = [] innatum lista<textus>
  expect:
      ts: 'const names = ([] as string[]);'
      py: 'names = []'
      rs:
          - 'let names = Vec::new();'
      cpp:
          - 'std::vector<std::string>{}'
      zig:
          - 'Lista([]const u8).init(alloc)'
      fab:
          - 'fixum names = [] innatum lista<textus>'

- name: tabula with fractus value type
  source: varia scores = {} innatum tabula<textus, fractus>
  expect:
      ts: 'let scores = new Map<string, number>();'
      py: 'scores = {}'
      rs:
          - 'let mut scores = HashMap::new();'
      cpp:
          - 'std::map<std::string, double>{}'
      zig:
          - 'std.AutoHashMap([]const u8, f64).init(alloc)'
      fab:
          - 'varia scores = {} innatum tabula<textus, fractus>'

- name: lista of numerus
  source: varia numbers = [] innatum lista<numerus>
  expect:
      ts: 'let numbers = ([] as number[]);'
      py: 'numbers = []'
      rs:
          - 'let mut numbers = Vec::new();'
      cpp:
          - 'std::vector<int64_t>{}'
      zig:
          - 'Lista(i64).init(alloc)'
      fab:
          - 'varia numbers = [] innatum lista<numerus>'

- name: non-empty tabula
  source: 'varia data = {a: 1, b: 2} innatum tabula<textus, numerus>'
  expect:
      ts: 'let data = new Map<string, number>([["a", 1], ["b", 2]]);'
      py: 'data = {"a": 1, "b": 2}'
      rs:
          - 'HashMap::from([("a".to_string(), 1), ("b".to_string(), 2)])'
      cpp:
          - 'std::map<std::string, int64_t>{{"a", 1}, {"b", 2}}'
      zig:
          - 'std.AutoHashMap'
          - '.put("a", 1)'
          - '.put("b", 2)'
      fab:
          - 'varia data = {a: 1, b: 2} innatum tabula<textus, numerus>'

- name: non-empty lista
  source: varia items = [1, 2, 3] innatum lista<numerus>
  expect:
      ts: 'let items = [1, 2, 3];'
      py: 'items = [1, 2, 3]'
      rs:
          - 'vec![1, 2, 3]'
      cpp:
          - 'std::vector<int64_t>{1, 2, 3}'
      zig:
          - 'Lista(i64).init(alloc)'
          - '.append(1)'
          - '.append(2)'
      fab:
          - 'varia items = [1, 2, 3] innatum lista<numerus>'
