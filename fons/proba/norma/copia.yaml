# File-level metadata: skip in rivus tests (stdlib not yet implemented)
- rivus: false

# Copia - Set collection method codegen tests
# Covers: adde, habet, dele, longitudo, vacua, purga, unio, intersectio,
#         differentia, symmetrica, subcopia, supercopia, inLista, perambula

# =============================================================================
# Core Operations
# =============================================================================

# adde inserts an element into the set
- name: 'adde -> insert'
  source: |
      varia copia<numerus> set = {}
      set.adde(5)
  wrap: 'cura arena fit alloc { $ }'
  cpp:
      - '.insert(5)'
  rs:
      - 'HashSet<i64>'
      - '.insert(5)'
  ts:
      - '.add('
  zig:
      - '.adde(alloc, 5)'
  fab:
      - 'varia copia<numerus> set = {}'
      - 'set.adde(5)'

# habet checks if element exists in set
- name: 'habet -> contains'
  source: |
      fixum copia<numerus> set = {}
      set.habet(5)
  cpp:
      - '.contains(5)'
  rs:
      - 'HashSet<i64>'
      - '.contains(&5)'
  ts:
      - '.has('
  zig:
      - '.habet(5)'
  fab:
      - 'fixum copia<numerus> set = {}'
      - 'set.habet(5)'

# dele removes an element from the set
- name: 'dele -> erase'
  source: |
      varia copia<numerus> set = {}
      set.dele(5)
  cpp:
      - '.erase(5)'
  rs:
      - 'HashSet<i64>'
      - '.remove(&5)'
  ts:
      - '.delete('
  zig:
      - '.dele(5)'
  fab:
      - 'varia copia<numerus> set = {}'
      - 'set.dele(5)'

# longitudo returns the number of elements
- name: 'longitudo -> size'
  source: |
      fixum copia<numerus> set = {}
      set.longitudo()
  cpp:
      - '.size()'
  rs:
      - 'HashSet<i64>'
      - '.len()'
  ts:
      - '.size'
  zig:
      - '.longitudo()'
  fab:
      - 'fixum copia<numerus> set = {}'
      - 'set.longitudo()'

# vacua checks if the set is empty
- name: 'vacua -> empty'
  source: |
      fixum copia<numerus> set = {}
      set.vacua()
  cpp:
      - '.empty()'
  rs:
      - 'HashSet<i64>'
      - '.is_empty()'
  ts:
      - '.size === 0'
  zig:
      - '.vacua()'
  fab:
      - 'fixum copia<numerus> set = {}'
      - 'set.vacua()'

# purga clears the entire set
- name: 'purga -> clear'
  source: |
      varia copia<numerus> set = {}
      set.purga()
  cpp:
      - '.clear()'
  rs:
      - 'HashSet<i64>'
      - '.clear()'
  ts:
      - '.clear('
  zig:
      - '.purga()'
  fab:
      - 'varia copia<numerus> set = {}'
      - 'set.purga()'

# =============================================================================
# Set Operations
# =============================================================================

# unio returns the union of two sets
- name: 'unio -> set union'
  source: |
      fixum copia<numerus> setA = {}
      fixum copia<numerus> setB = {}
      setA.unio(setB)
  cpp:
      - 'std::unordered_set'
      - 'faber::copia_unio(setA, setB)'
  rs:
      - 'HashSet<i64>'
      - 'faber::copia_unio(&setA, &setB)'
  ts:
      - '[...'
  fab:
      - 'fixum copia<numerus> setA = {}'
      - 'fixum copia<numerus> setB = {}'
      - 'setA.unio(setB)'

# intersectio returns the intersection of two sets
- name: 'intersectio -> set intersection'
  source: |
      fixum copia<numerus> setA = {}
      fixum copia<numerus> setB = {}
      setA.intersectio(setB)
  cpp:
      - 'faber::copia_intersectio(setA, setB)'
  rs:
      - 'HashSet<i64>'
      - 'faber::copia_intersectio(&setA, &setB)'
  ts:
      - '.filter('
  fab:
      - 'fixum copia<numerus> setA = {}'
      - 'fixum copia<numerus> setB = {}'
      - 'setA.intersectio(setB)'

# differentia returns elements in A but not in B
- name: 'differentia -> set difference'
  source: |
      fixum copia<numerus> setA = {}
      fixum copia<numerus> setB = {}
      setA.differentia(setB)
  cpp:
      - 'faber::copia_differentia(setA, setB)'
  rs:
      - 'HashSet<i64>'
      - 'faber::copia_differentia(&setA, &setB)'
  ts:
      - '.filter('
  fab:
      - 'fixum copia<numerus> setA = {}'
      - 'fixum copia<numerus> setB = {}'
      - 'setA.differentia(setB)'

# symmetrica returns elements in either set but not both
- name: 'symmetrica -> symmetric difference'
  source: |
      fixum copia<numerus> setA = {}
      fixum copia<numerus> setB = {}
      setA.symmetrica(setB)
  cpp:
      - 'faber::copia_symmetrica(setA, setB)'
  rs:
      - 'HashSet<i64>'
      - 'faber::copia_symmetrica(&setA, &setB)'
  ts:
      - '.filter('
  fab:
      - 'fixum copia<numerus> setA = {}'
      - 'fixum copia<numerus> setB = {}'
      - 'setA.symmetrica(setB)'

# =============================================================================
# Predicates
# =============================================================================

# subcopia checks if A is a subset of B
- name: 'subcopia -> all_of with contains'
  source: |
      fixum copia<numerus> setA = {}
      fixum copia<numerus> setB = {}
      setA.subcopia(setB)
  cpp:
      - 'faber::copia_subcopia(setA, setB)'
  rs:
      - 'HashSet<i64>'
      - '.is_subset(&setB)'
  ts:
      - '.every('
  fab:
      - 'fixum copia<numerus> setA = {}'
      - 'fixum copia<numerus> setB = {}'
      - 'setA.subcopia(setB)'

# supercopia checks if A is a superset of B
- name: 'supercopia -> all_of reversed'
  source: |
      fixum copia<numerus> setA = {}
      fixum copia<numerus> setB = {}
      setA.supercopia(setB)
  cpp:
      - 'faber::copia_supercopia(setA, setB)'
  rs:
      - 'HashSet<i64>'
      - '.is_superset(&setB)'
  ts:
      - '.every('
  fab:
      - 'fixum copia<numerus> setA = {}'
      - 'fixum copia<numerus> setB = {}'
      - 'setA.supercopia(setB)'

# =============================================================================
# Conversions
# =============================================================================

# inLista converts the set to a vector
- name: 'inLista -> vector from set'
  source: |
      fixum copia<numerus> set = {}
      set.inLista()
  cpp:
      - 'faber::copia_in_lista(set)'
  rs:
      - 'HashSet<i64>'
      - 'faber::copia_in_lista(&set)'
  ts:
      - '[...'
  fab:
      - 'fixum copia<numerus> set = {}'
      - 'set.inLista()'

# =============================================================================
# Iteration
# =============================================================================

# perambula iterates over all elements
- name: 'perambula -> ranges::for_each'
  source: |
      fixum copia<numerus> set = {}
      set.perambula(pro x { scribe x })
  cpp:
      - 'std::ranges::for_each('
  rs:
      - 'HashSet<i64>'
      - '.iter().for_each(|x|'
  ts:
      - '.forEach('
  fab:
      - 'fixum copia<numerus> set = {}'
      - 'set.perambula(pro x { scribe x })'
