# File-level metadata: skip in rivus tests (stdlib not yet implemented)
- rivus: false

# Tabula - Map/dictionary collection method codegen tests
# Covers: pone, accipe, habet, dele, longitudo, vacua, purga, claves, valores,
#         accipeAut, conflata, inLista

# =============================================================================
# Core Operations
# =============================================================================

# pone inserts or updates a key-value pair
- name: 'pone -> insert_or_assign'
  source: |
      fixum tabula<textus, numerus> map = {}
      map.pone("key", 42)
  wrap: 'cura arena fit alloc { $ }'
  cpp:
      - '.insert_or_assign('
  ts:
      - '.set('
  rs:
      - 'HashMap<String, i64>'
      - '.insert('
  zig:
      - '.pone(alloc, "key", 42)'
  fab:
      - 'fixum tabula<textus, numerus> map = {}'
      - 'map.pone("key", 42)'

# accipe retrieves a value by key (throws if not found)
- name: 'accipe -> at'
  source: |
      fixum tabula<textus, numerus> map = {}
      map.accipe("key")
  cpp:
      - '.at('
  ts:
      - '.get('
  rs:
      - 'HashMap<String, i64>'
      - '.get(&String::from("key")'
  zig:
      - '.accipe("key")'
  fab:
      - 'fixum tabula<textus, numerus> map = {}'
      - 'map.accipe("key")'

# habet checks if key exists
- name: 'habet -> contains'
  source: |
      fixum tabula<textus, numerus> map = {}
      map.habet("key")
  cpp:
      - '.contains('
  ts:
      - '.has('
  rs:
      - 'HashMap<String, i64>'
      - '.contains_key(&String::from("key")'
  zig:
      - '.habet("key")'
  fab:
      - 'fixum tabula<textus, numerus> map = {}'
      - 'map.habet("key")'

# dele removes a key-value pair
- name: 'dele -> erase'
  source: |
      fixum tabula<textus, numerus> map = {}
      map.dele("key")
  cpp:
      - '.erase('
  ts:
      - '.delete('
  rs:
      - 'HashMap<String, i64>'
      - '.remove(&String::from("key")'
  zig:
      - '.dele("key")'
  fab:
      - 'fixum tabula<textus, numerus> map = {}'
      - 'map.dele("key")'

# longitudo returns the number of entries
- name: 'longitudo -> size'
  source: |
      fixum tabula<textus, numerus> map = {}
      map.longitudo()
  cpp:
      - '.size()'
  ts:
      - '.size'
  rs:
      - 'HashMap<String, i64>'
      - '.len()'
  zig:
      - '.longitudo()'
  fab:
      - 'fixum tabula<textus, numerus> map = {}'
      - 'map.longitudo()'

# vacua checks if the map is empty
- name: 'vacua -> empty'
  source: |
      fixum tabula<textus, numerus> map = {}
      map.vacua()
  cpp:
      - '.empty()'
  ts:
      - '.size === 0'
  rs:
      - 'HashMap<String, i64>'
      - '.is_empty()'
  zig:
      - '.vacua()'
  fab:
      - 'fixum tabula<textus, numerus> map = {}'
      - 'map.vacua()'

# purga clears the entire map
- name: 'purga -> clear'
  source: |
      varia tabula<textus, numerus> map = {}
      map.purga()
  cpp:
      - '.clear()'
  ts:
      - '.clear('
  rs:
      - 'HashMap<String, i64>'
      - '.clear()'
  zig:
      - '.purga()'
  fab:
      - 'varia tabula<textus, numerus> map = {}'
      - 'map.purga()'

# =============================================================================
# Iteration
# =============================================================================

# claves returns a view of all keys
- name: 'claves -> views::keys'
  source: |
      fixum tabula<textus, numerus> map = {}
      map.claves()
  cpp:
      - 'std::views::keys'
  ts:
      - '.keys('
  rs:
      - 'HashMap<String, i64>'
      - '.keys()'
  zig:
      - '.claves()'
  fab:
      - 'fixum tabula<textus, numerus> map = {}'
      - 'map.claves()'

# valores returns a view of all values
- name: 'valores -> views::values'
  source: |
      fixum tabula<textus, numerus> map = {}
      map.valores()
  cpp:
      - 'std::views::values'
  ts:
      - '.values('
  rs:
      - 'HashMap<String, i64>'
      - '.values()'
  zig:
      - '.valores()'
  fab:
      - 'fixum tabula<textus, numerus> map = {}'
      - 'map.valores()'

# =============================================================================
# Extended Methods
# =============================================================================

# accipeAut returns value if exists, otherwise default
- name: 'accipeAut -> contains + at with default'
  source: |
      fixum tabula<textus, numerus> map = {}
      map.accipeAut("key", 0)
  cpp:
      - '.contains('
      - '.at('
  ts:
      - '.get('
  rs:
      - 'HashMap<String, i64>'
      - '.get(&String::from("key")'
      - '.unwrap_or(0)'
  zig:
      - '.accipeAut("key", 0)'
  fab:
      - 'fixum tabula<textus, numerus> map = {}'
      - 'map.accipeAut("key", 0)'

# conflata merges maps (returns new map)
- name: 'conflata -> merge maps'
  source: |
      varia tabula<textus, numerus> map = {}
      varia tabula<textus, numerus> other = {}
      map.conflata(other)
  cpp:
      - 'faber::tabula_conflata(map, other)'
  ts:
      - '[...'
  rs:
      - 'HashMap<String, i64>'
      - 'faber::tabula_conflata(&map, &other)'
  zig:
      - '.conflata(&other)'
  fab:
      - 'varia tabula<textus, numerus> map = {}'
      - 'varia tabula<textus, numerus> other = {}'
      - 'map.conflata(other)'

# inLista converts map entries to a vector
- name: 'inLista -> vector from map'
  source: |
      varia tabula<textus, numerus> map = {}
      map.inLista()
  wrap: 'cura arena fit alloc { $ }'
  cpp:
      - 'faber::tabula_in_lista(map)'
  ts:
      - '[...'
  rs:
      - 'HashMap<String, i64>'
      - 'faber::tabula_in_lista(&map)'
  zig:
      - '.inLista(alloc)'
  fab:
      - 'varia tabula<textus, numerus> map = {}'
      - 'map.inLista()'

# =============================================================================
# Missing Method Coverage
# =============================================================================

# paria returns entries iterator
- name: 'paria -> entries/items iterator'
  source: |
      fixum tabula<textus, numerus> map = {}
      map.paria()
  cpp:
      - 'map'
  ts:
      - '.entries('
  rs:
      - 'HashMap<String, i64>'
      - '.iter()'
  zig:
      - '.paria()'
  fab:
      - 'fixum tabula<textus, numerus> map = {}'
      - 'map.paria()'

# selecta keeps only specified keys
- name: 'selecta -> filter by keys'
  source: |
      fixum tabula<textus, numerus> map = {}
      map.selecta(["key1", "key2"])
  cpp:
      - 'faber::tabula_selecta(map, '
  ts:
      - '[...map].filter('
      - '.includes(k)'
  rs:
      - 'HashMap<String, i64>'
      - 'faber::tabula_selecta(&map, &'
  fab:
      - 'fixum tabula<textus, numerus> map = {}'
      - 'map.selecta(["key1", "key2"])'
  skip: [zig]

# omissa removes specified keys (returns new map)
- name: 'omissa -> filter excluding keys'
  source: |
      fixum tabula<textus, numerus> map = {}
      map.omissa(["key1", "key2"])
  cpp:
      - 'faber::tabula_omissa(map, '
  ts:
      - '[...map].filter('
      - '!['
      - '.includes(k)'
  rs:
      - 'HashMap<String, i64>'
      - 'faber::tabula_omissa(&map, &'
  fab:
      - 'fixum tabula<textus, numerus> map = {}'
      - 'map.omissa(["key1", "key2"])'
  skip: [zig]

# inversa swaps keys and values
- name: 'inversa -> invert map'
  source: |
      fixum tabula<textus, numerus> map = {}
      map.inversa()
  cpp:
      - 'faber::tabula_inversa(map)'
  ts:
      - '[...map].map(([k, v]) => [v, k])'
  rs:
      - 'HashMap<String, i64>'
      - 'faber::tabula_inversa(&map)'
  fab:
      - 'fixum tabula<textus, numerus> map = {}'
      - 'map.inversa()'
  skip: [zig]

# mappaValores transforms values
- name: 'mappaValores -> transform values'
  source: |
      fixum tabula<textus, numerus> map = {}
      map.mappaValores(pro v: v * 2)
  cpp:
      - '[...map].map(([k, v]) => [k, '
  ts:
      - '[...map].map(([k, v]) => [k, '
  rs:
      - 'HashMap<String, i64>'
  fab:
      - 'fixum tabula<textus, numerus> map = {}'
      - 'map.mappaValores(pro v: v * 2)'
  skip: [zig, rs, py]

# mappaClaves transforms keys
- name: 'mappaClaves -> transform keys'
  source: |
      fixum tabula<textus, numerus> map = {}
      map.mappaClaves(pro k: k + "_new")
  cpp:
      - '[...map].map(([k, v]) => ['
      - ', v])'
  ts:
      - '[...map].map(([k, v]) => ['
      - ', v])'
  rs:
      - 'HashMap<String, i64>'
  fab:
      - 'fixum tabula<textus, numerus> map = {}'
      - 'map.mappaClaves(pro k: k + "_new")'
  skip: [zig, rs, py]

# inObjectum converts to plain object (JS/Python only)
- name: 'inObjectum -> object from map'
  source: |
      fixum tabula<textus, numerus> map = {}
      map.inObjectum()
  cpp:
      - 'Object.fromEntries('
  ts:
      - 'Object.fromEntries('
  fab:
      - 'fixum tabula<textus, numerus> map = {}'
      - 'map.inObjectum()'
  skip: [zig, rs, cpp]
