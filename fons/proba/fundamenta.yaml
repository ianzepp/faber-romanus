# Fundamenta - C++ codegen specifics
# Covers: scribe output, includes, main function wrapping
# Note: Variable declarations and literals now in proba/codegen/statements/ and expressions/

# =============================================================================
# Scribe Output
# =============================================================================

# scribe is the print statement (console.log in TS, print in Python)
- name: 'scribe single arg'
  source: 'scribe x'
  ts: 'console.log(x);'
  py: 'print(x)'
  cpp:
      - 'std::print'
  skip: [rs]
  fab: 'scribe x'

# Multiple arguments are comma-separated
- name: 'scribe multiple args'
  source: 'scribe "a", "b", "c"'
  ts: 'console.log("a", "b", "c");'
  py: 'print("a", "b", "c")'
  cpp:
      - 'std::print("{} {} {}\n"'
  zig:
      - 'print("{s} {s} {s}\n", .{ "a", "b", "c" });'
  rs:
      - 'println!'
  fab:
      - 'scribe "a", "b", "c"'

# Expressions are evaluated before printing
- name: 'scribe with expression'
  source: 'scribe x + y'
  ts:
      - 'console.log'
      - 'x + y'
  py:
      - 'print'
      - 'x + y'
  cpp:
      - 'std::print("{}\n", (x + y));'
  skip: [rs]
  fab:
      - 'scribe x + y'

# =============================================================================
# Includes (C++)
# =============================================================================

# scribe generates required includes for print and string
- name: 'cpp generates required includes'
  source: 'scribe "hello"'
  cpp:
      - '#include <print>'
      - '#include <string>'
  rs:
      - 'println!'
  fab: 'scribe "hello"'

# adfirma adds cassert include
- name: 'cpp optional includes added when used'
  source: 'adfirma verum'
  cpp:
      - '#include <cassert>'
  rs:
      - 'assert!(true);'
  fab: 'adfirma verum'

# =============================================================================
# Entry Point (incipit)
# =============================================================================

# incipit generates target-appropriate main function
- name: 'incipit generates main function'
  source: |
      incipit {
        scribe "hello"
      }
  ts:
      - 'console.log("hello")'
  py:
      - 'if __name__ == "__main__":'
      - 'print("hello")'
  cpp:
      - 'int main() {'
      - 'std::print'
      - 'return 0;'
  rs:
      - 'fn main() {'
      - 'println!'
  zig:
      - 'pub fn main() void {'
      - 'print("{s}\n", .{ "hello" });'
  fab:
      - 'incipit {'
      - 'scribe "hello"'

# Declarations outside incipit, call inside
- name: 'declarations outside incipit'
  source: |
      functio greet() {
        scribe "hi"
      }
      incipit {
        greet()
      }
  ts:
      - 'function greet()'
      - 'console.log("hi")'
      - 'greet();'
  py:
      - 'def greet():'
      - 'print("hi")'
      - 'if __name__ == "__main__":'
      - 'greet()'
  cpp:
      - 'void greet() {'
      - 'int main() {'
      - 'greet();'
  rs:
      - 'fn greet() {'
      - 'fn main() {'
      - 'greet();'
  zig:
      - 'fn greet() void {'
      - 'pub fn main() void {'
      - 'greet();'
  fab:
      - 'functio greet() {'
      - 'scribe "hi"'
      - 'incipit {'
      - 'greet()'

# =============================================================================
# Forward References (Two-Pass Semantic Analysis)
# =============================================================================

# Function B calls function A, but A is defined later in the file
- name: 'forward function reference'
  source: |
      functio b() {
        a()
      }
      functio a() {
        scribe "hello"
      }
      incipit {
        b()
      }
  ts:
      - 'function b()'
      - 'a();'
      - 'function a()'
      - 'console.log("hello")'
      - 'b();'
  py:
      - 'def b():'
      - 'a()'
      - 'def a():'
      - 'print("hello")'
      - 'b()'
  cpp:
      - 'void b() {'
      - 'a();'
      - 'void a() {'
      - 'int main() {'
  rs:
      - 'fn b() {'
      - 'a();'
      - 'fn a() {'
      - 'fn main() {'
  zig:
      - 'fn b() void {'
      - 'a();'
      - 'fn a() void {'
      - 'pub fn main() void {'
  fab:
      - 'functio b() {'
      - 'a()'
      - 'functio a() {'
      - 'scribe "hello"'
      - 'incipit {'
      - 'b()'

# Mutual recursion: isEven calls isOdd and vice versa
- name: 'mutual recursion'
  source: |
      functio isEven(numerus n) fit bivalens {
        si n == 0 { redde verum }
        redde isOdd(n - 1)
      }
      functio isOdd(numerus n) fit bivalens {
        si n == 0 { redde falsum }
        redde isEven(n - 1)
      }
  ts:
      - 'function isEven(n: number): boolean'
      - 'isOdd((n - 1))'
      - 'function isOdd(n: number): boolean'
      - 'isEven((n - 1))'
  py:
      - 'def isEven(n: int) -> bool:'
      - 'isOdd((n - 1))'
      - 'def isOdd(n: int) -> bool:'
      - 'isEven((n - 1))'
  cpp:
      - 'bool isEven(int64_t n) {'
      - 'return isOdd((n - 1));'
      - 'bool isOdd(int64_t n) {'
      - 'return isEven((n - 1));'
  rs:
      - 'fn isEven(n: i64) -> bool {'
      - 'return isOdd((n - 1));'
      - 'fn isOdd(n: i64) -> bool {'
      - 'return isEven((n - 1));'
  zig:
      - 'fn isEven(n: i64) bool {'
      - 'return isOdd((n - 1));'
      - 'fn isOdd(n: i64) bool {'
      - 'return isEven((n - 1));'
  fab:
      - 'functio isEven(numerus n) fit bivalens {'
      - 'redde isOdd(n - 1)'
      - 'functio isOdd(numerus n) fit bivalens {'
      - 'redde isEven(n - 1)'

# Forward type reference: function uses genus defined later
- name: 'forward type reference in function param'
  source: |
      functio process(User u) fit textus {
        redde u.name
      }
      genus User {
        textus name
      }
  ts:
      - 'function process(u: User): string'
      - 'u.name'
      - 'class User {'
      - 'name: string;'
  py:
      - 'def process(u: User) -> str:'
      - 'u.name'
      - 'class User:'
  cpp:
      - 'std::string process(const User& u) {'
      - 'return u.name;'
      - 'struct User {'
  rs:
      - 'fn process(u: User) -> String {'
      - 'return u.name;'
      - 'struct User {'
  zig:
      - 'fn process(u: User)'
      - 'return u.name;'
      - 'const User = struct {'
  fab:
      - 'functio process(User u) fit textus {'
      - 'redde u.name'
      - 'genus User {'
      - 'textus name'

# =============================================================================
# Keywords as Identifiers
# =============================================================================

# Keywords can be used as variable names
- name: 'keyword typus as variable name'
  source: |
      fixum numerus typus = 42
      scribe typus
  ts:
      - 'const typus: number = 42'
      - 'console.log(typus)'
  py:
      - 'typus: int = 42'
      - 'print(typus)'
  cpp:
      - 'const int64_t typus = 42'
      - 'std::print("{}\n", typus)'
  rs:
      - 'let typus: i64 = 42'
      - 'println!("{}", typus)'
  zig:
      - 'const typus: i64 = 42'
      - 'print("{d}\n", .{ typus });'
  fab:
      - 'fixum numerus typus = 42'
      - 'scribe typus'

- name: 'keyword genus as variable name'
  source: |
      fixum textus genus = "species"
      scribe genus
  ts:
      - 'const genus: string = "species"'
      - 'console.log(genus)'
  py:
      - 'genus: str = "species"'
      - 'print(genus)'
  cpp:
      - 'const std::string genus = std::string("species")'
      - 'std::print("{}\n", genus)'
  rs:
      - 'let genus: String = String::from("species")'
      - 'println!("{}", genus)'
  zig:
      - 'const genus: []const u8 = "species"'
      - 'print("{s}\n", .{ genus });'
  fab:
      - 'fixum textus genus = "species"'
      - 'scribe genus'
