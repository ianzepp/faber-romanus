type Responsum<T = unknown> =
  | { op: 'bene'; data: T }
  | { op: 'error'; code: string; message: string }
  | { op: 'factum' }
  | { op: 'res'; data: T };

const respond = {
  ok: <T>(data: T): Responsum<T> => ({ op: 'bene', data }),
  error: (code: string, message: string): Responsum<never> => ({ op: 'error', code, message }),
  done: (): Responsum<never> => ({ op: 'factum' }),
  item: <T>(data: T): Responsum<T> => ({ op: 'res', data }),
};

function asFit<T>(gen: () => Generator<Responsum<T>>): T {
  for (const resp of gen()) {
    if (resp.op === 'bene') return resp.data;
    if (resp.op === 'error') throw new Error(`${resp.code}: ${resp.message}`);
  }
  throw new Error('EPROTO: No terminal response');
}

function* asFiunt<T>(gen: Generator<Responsum<T>>): Generator<T> {
  for (const resp of gen) {
    if (resp.op === 'res') yield resp.data;
    else if (resp.op === 'error') throw new Error(`${resp.code}: ${resp.message}`);
    else if (resp.op === 'factum') return;
    else if (resp.op === 'bene') { yield resp.data; return; }
  }
}

async function asFiet<T>(gen: () => AsyncGenerator<Responsum<T>>): Promise<T> {
  for await (const resp of gen()) {
    if (resp.op === 'bene') return resp.data;
    if (resp.op === 'error') throw new Error(`${resp.code}: ${resp.message}`);
  }
  throw new Error('EPROTO: No terminal response');
}

async function* asFient<T>(gen: AsyncGenerator<Responsum<T>>): AsyncGenerator<T> {
  for await (const resp of gen) {
    if (resp.op === 'res') yield resp.data;
    else if (resp.op === 'error') throw new Error(`${resp.code}: ${resp.message}`);
    else if (resp.op === 'factum') return;
    else if (resp.op === 'bene') { yield resp.data; return; }
  }
}