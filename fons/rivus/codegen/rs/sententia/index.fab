# Rust Statement Generator - Dispatch

ex "../../../ast/sententia" importa Sententia, VariaGenus, ScribeGradus, IteratioGenus, CuratorGenus
ex "../../../ast/sententia" importa Parametrum, CampusDeclaratio, EligeCasus, VariansCasus
ex "../../../ast/sententia" importa OrdoMembrum, VariansDeclaratio, ImportaSpecificator, PactumMethodus, TypusParametrum
ex "../../../ast/sententia" importa SeriesDestructuraElementum, CustodiClausula, CapeClausula
ex "../../../ast/sententia" importa PraeparaTempus
ex "../../../ast/expressia" importa Expressia
ex "../../../ast/typus" importa TypusAnnotatio
ex "../nucleus" importa RsGenerator
ex "../typus" importa genTypus
ex "../expressia/index" importa genExpressia
ex "./varia" importa genVaria
ex "./si" importa genSi
ex "./functio" importa genFunctio, genParametrum
ex "./genus" importa genGenus
ex "./ordo" importa genOrdo
ex "./dum" importa genDum
ex "./iteratio" importa genIteratio
ex "./elige" importa genElige
ex "./discerne" importa genDiscerne
ex "./tempta" importa genTempta
ex "./scribe" importa genScribe
ex "./redde" importa genRedde

@ publica
functio genSententia(Sententia stmt, RsGenerator g) -> textus {
    fixum leading = g.notaePrae(stmt)
    fixum trailing = g.notaePost(stmt)
    fixum content = genSententiaContent(stmt, g)
    redde scriptum("§§§", leading, content, trailing)
}

functio genSententiaContent(Sententia stmt, RsGenerator g) -> textus {
    discerne stmt {
        casu MassaSententia ut s { redde genMassa(s.corpus qua lista<Sententia>, g) }
        casu VariaSententia ut s {
            redde genVaria(s.species qua VariaGenus, s.nomen qua textus, s.typus, s.valor, s.externa qua bivalens, g)
        }
        casu ImportaSententia ut s {
            fixum path = (s.fons qua textus).replace("/", "::")
            si s.totum qua bivalens { redde scriptum("§use §::*;", g.ind(), path) }
            varia names = [] innatum lista<textus>
            ex (s.specificatores qua lista<ImportaSpecificator>) pro spec {
                names.adde(spec.nomen)
            }
            si names.longitudo() == 1 { redde scriptum("§use §::§;", g.ind(), path, names[0]) }
            redde scriptum("§use §::{{§}};", g.ind(), path, names.coniunge(", "))
        }
        casu FunctioDeclaratio ut f {
            redde genFunctio(f.nomen qua textus, f.generaParametra, f.parametra qua lista<Parametrum>, f.reddeVerbum, f.typusReditus, f.corpus, f.asynca qua bivalens, f.generator qua bivalens, f.structor qua bivalens, f.visibilitas, f.abstracta qua bivalens, f.externa qua bivalens, g)
        }
        casu GenusDeclaratio ut s {
            redde genGenus(s.nomen qua textus, s.generaParametra, s.extendit, s.implet, s.abstractum qua bivalens, s.campi qua lista<CampusDeclaratio>, s.structor, s.methodi qua lista<Sententia>, g)
        }
        casu OrdoDeclaratio ut s { redde genOrdo(s.nomen qua textus, s.membra qua lista<OrdoMembrum>, g) }
        casu DiscretioDeclaratio ut s {
            varia result = scriptum("§pub enum § {{", g.ind(), s.nomen)
            g.intraProfundum()
            ex (s.variantes qua lista<VariansDeclaratio>) pro v {
                result = scriptum("§\n§§,", result, g.ind(), v.nomen)
            }
            g.exiProfundum()
            redde scriptum("§\n§}}", result, g.ind())
        }
        casu TypusAliasDeclaratio ut s {
            redde scriptum("§type § = §;", g.ind(), s.nomen, genTypus(s.typus qua TypusAnnotatio, g))
        }
        casu PactumDeclaratio ut s {
            varia result = scriptum("§pub trait § {{", g.ind(), s.nomen)
            g.intraProfundum()
            ex (s.methodi qua lista<PactumMethodus>) pro m {
                varia params = [] innatum lista<textus>
                si m.parametra != nihil {
                    ex (m.parametra qua lista<Parametrum>) pro param {
                        params.adde(genParametrum(param, g))
                    }
                }
                varia sig = scriptum("§fn §(§)", g.ind(), m.nomen, params.coniunge(", "))
                si nonnihil m.typusReditus {
                    sig = scriptum("§ -> §", sig, genTypus(m.typusReditus qua TypusAnnotatio, g))
                }
                result = scriptum("§\n§;", result, sig)
            }
            g.exiProfundum()
            redde scriptum("§\n§}}", result, g.ind())
        }
        casu SiSententia ut s { redde genSi(s.condicio, s.consequens qua Sententia, s.alternans, s.cape, g) }
        casu DumSententia ut s { redde genDum(s.condicio, s.corpus qua Sententia, s.cape, g) }
        casu IteratioSententia ut s {
            redde genIteratio(s.species qua IteratioGenus, s.variabilis qua textus, s.iterabile, s.corpus qua Sententia, s.asynca qua bivalens, s.cape, g)
        }
        casu EligeSententia ut s {
            redde genElige(s.discriminans, s.casus qua lista<EligeCasus>, s.praedefinitum, s.cape, g)
        }
        casu DiscerneSententia ut s { redde genDiscerne(s.discriminans, s.casus qua lista<VariansCasus>, g) }
        casu TemptaSententia ut s { redde genTempta(s.corpus qua Sententia, s.cape, s.demum, g) }
        casu IaceSententia ut s {
            si s.fatale qua bivalens {
                si nonnihil s.argumentum { redde scriptum("§panic!(\"{{:?}}\", §);", g.ind(), genExpressia(s.argumentum qua Expressia, g)) }
                redde scriptum("§panic!();", g.ind())
            }
            si nonnihil s.argumentum { redde scriptum("§return Err(§);", g.ind(), genExpressia(s.argumentum qua Expressia, g)) }
            redde scriptum("§return Err(());", g.ind())
        }
        casu ScribeSententia ut s { redde genScribe(s.gradus qua ScribeGradus, s.argumenta qua lista<Expressia>, g) }
        casu ReddeSententia ut s { redde genRedde(s.valor, g) }
        casu RumpeSententia { redde scriptum("§break;", g.ind()) }
        casu PergeSententia { redde scriptum("§continue;", g.ind()) }
        casu ExpressiaSententia ut s { redde scriptum("§§;", g.ind(), genExpressia(s.expressia, g)) }

        # Destructuring
        casu DestructuraSententia ut s {
            varia names = [] innatum lista<textus>
            ex (s.specificatores qua lista<ImportaSpecificator>) pro spec {
                names.adde(spec.nomen)
            }
            fixum keyword = (s.species qua VariaGenus) == VariaGenus.VARIA sic "let mut" secus "let"
            redde scriptum("§§ {{ § }} = §;", g.ind(), keyword, names.coniunge(", "), genExpressia(s.fons, g))
        }

        casu SeriesDestructuraSententia ut s {
            varia names = [] innatum lista<textus>
            ex (s.elementa qua lista<SeriesDestructuraElementum>) pro elem {
                si nonnihil elem.variabilis {
                    names.adde(elem.variabilis qua textus)
                } secus {
                    names.adde("_")
                }
            }
            fixum keyword = (s.species qua VariaGenus) == VariaGenus.VARIA sic "let mut" secus "let"
            redde scriptum("§§ [§] = §;", g.ind(), keyword, names.coniunge(", "), genExpressia(s.fons, g))
        }

        # In statement (with object)
        casu InSententia ut s {
            varia result = scriptum("§{{", g.ind())
            g.intraProfundum()
            fixum body = genSententia(s.corpus qua Sententia, g)
            g.exiProfundum()
            redde scriptum("§\n§\n§}}", result, body, g.ind())
        }

        # Guard statement
        casu CustodiSententia ut s {
            varia result = ""
            ex (s.clausulae qua lista<CustodiClausula>) pro clausula {
                fixum cond = genExpressia(clausula.condicio, g)
                fixum body = genSententia(clausula.corpus qua Sententia, g)
                si result == "" {
                    result = scriptum("§if !(§) {{\n§\n§}}", g.ind(), cond, body, g.ind())
                } secus {
                    result = scriptum("§ else if !(§) {{\n§\n§}}", result, cond, body, g.ind())
                }
            }
            redde result
        }

        # Fac (do-while)
        casu FacSententia ut s {
            fixum body = genSententia(s.corpus qua Sententia, g)
            fixum cond = genExpressia(s.condicio, g)
            redde scriptum("§loop {{\n§\n§if !(§) {{ break; }}\n§}}", g.ind(), body, g.ind(), cond, g.ind())
        }

        # Assertions
        casu AdfirmaSententia ut s {
            fixum cond = genExpressia(s.condicio, g)
            si nonnihil s.nuntius {
                redde scriptum("§assert!(§, §);", g.ind(), cond, genExpressia(s.nuntius qua Expressia, g))
            }
            redde scriptum("§assert!(§);", g.ind(), cond)
        }

        # Initialization
        casu IncipitSententia ut s {
            varia result = scriptum("§// incipit block", g.ind())
            si nonnihil s.corpus {
                result = scriptum("§\n§", result, genSententia(s.corpus qua Sententia, g))
            }
            redde result
        }

        casu IncipietSententia ut s {
            varia result = scriptum("§// incipiet (async init) block", g.ind())
            si nonnihil s.corpus {
                result = scriptum("§\n§", result, genSententia(s.corpus qua Sententia, g))
            }
            redde result
        }

        # Resource management
        casu CuraSententia ut s {
            fixum resource = genExpressia(s.res, g)
            fixum binding = s.vinculum qua textus
            fixum body = genSententia(s.corpus qua Sententia, g)
            redde scriptum("§let § = §;\n§", g.ind(), binding, resource, body)
        }

        # Ad statement (placeholder)
        casu AdSententia {
            redde scriptum("§panic!(\"ad statement not implemented\");", g.ind())
        }

        # Test statements
        casu ProbandumSententia ut s {
            varia lines = [] innatum lista<textus>
            ex (s.corpus qua lista<Sententia>) pro stmt {
                lines.adde(genSententia(stmt, g))
            }
            redde scriptum("§#[cfg(test)]\n§mod § {{\n§\n§}}", g.ind(), g.ind(), s.nomen, lines.coniunge("\n"), g.ind())
        }

        casu ProbaSententia ut s {
            fixum body = genSententia(s.corpus qua Sententia, g)
            redde scriptum("§#[test]\n§fn §() {{\n§\n§}}", g.ind(), g.ind(), s.nomen, body, g.ind())
        }

        casu PraeparaMassa ut s {
            fixum body = genSententia(s.corpus qua Sententia, g)
            redde scriptum("§// setup block\n§", g.ind(), body)
        }
    }
    redde scriptum("§/* unknown statement */", g.ind())
}

@ publica
functio genMassa(lista<Sententia> corpus, RsGenerator g) -> textus {
    si corpus.longitudo() == 0 { redde "" }
    varia lines = [] innatum lista<textus>
    ex corpus pro stmt { lines.adde(genSententia(stmt, g)) }
    redde lines.coniunge("\n")
}
