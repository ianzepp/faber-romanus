# Rust Expression Generator - Dispatch

ex "../../../ast/expressia" importa Expressia, LitteraGenus, ObiectumProprietas, LambdaParametrum, MorphologiaInvocatio, CatenaGradus
ex "../../../ast/sententia" importa Sententia, VariaGenus
ex "../sententia/index" importa genSententia, genMassa
ex "../../../ast/typus" importa TypusAnnotatio, TypusParametrum
ex "../nucleus" importa RsGenerator
ex "../typus" importa genTypus
ex "../../norma-registry.gen" importa getNormaTranslation, VerteTranslation
ex "./littera" importa genLittera, genLitteraExemplar
ex "./scriptum" importa genScriptum
ex "./obiectum" importa genObiectum

@ publica
functio genExpressia(Expressia expr, RsGenerator g) -> textus {
    discerne expr {
        casu Nomen ut e { redde e.valor qua textus }
        casu EgoExpressia { redde "self" }
        casu Littera ut e { redde genLittera(e.species qua LitteraGenus, e.crudus qua textus) }
        casu LitteraExemplar ut e {
            redde genLitteraExemplar(e.partes qua lista<textus>, e.expressiae qua lista<Expressia>, g)
        }
        casu LitteraRegex ut e {
            g.requisita.usesRegex = verum
            redde scriptum("Regex::new(r\"§\").unwrap()", e.forma)
        }

        casu BinariaExpressia ut e {
            fixum sinister = genExpressia(e.sinister, g)
            fixum dexter = genExpressia(e.dexter, g)
            varia signum = e.signum qua textus
            elige signum {
                casu "et" { signum = "&&" }
                casu "aut" { signum = "||" }
                casu "vel" { redde scriptum("§.unwrap_or(§)", sinister, dexter) }
            }
            si signum == "inter" {
                redde scriptum("§.contains(&§)", dexter, sinister)
            }
            redde scriptum("(§ § §)", sinister, signum, dexter)
        }

        casu UnariaExpressia ut e {
            fixum arg = genExpressia(e.argumentum, g)
            elige e.signum qua textus {
                casu "nihil" reddit scriptum("§.is_none()", arg)
                casu "nonnihil" reddit scriptum("§.is_some()", arg)
                casu "negativum" reddit scriptum("(§ < 0)", arg)
                casu "positivum" reddit scriptum("(§ > 0)", arg)
            }
            redde scriptum("§§", e.signum, arg)
        }

        casu AssignatioExpressia ut e {
            redde scriptum("§ § §", genExpressia(e.sinister, g), e.signum, genExpressia(e.dexter, g))
        }

        casu CondicioExpressia ut e {
            redde scriptum("if § {{ § }} else {{ § }}", genExpressia(e.condicio, g), genExpressia(e.consequens, g), genExpressia(e.alternans, g))
        }

        casu AmbitusExpressia ut e {
            fixum initium = genExpressia(e.initium, g)
            fixum finis = genExpressia(e.finis, g)
            si e.inclusivum qua bivalens { redde scriptum("§..=§", initium, finis) }
            redde scriptum("§..§", initium, finis)
        }

        casu QuaExpressia ut e {
            redde scriptum("(§ as §)", genExpressia(e.expressia, g), genTypus(e.scopus qua TypusAnnotatio, g))
        }

        casu InnatumExpressia ut e {
            fixum typusNomen = (e.scopus qua TypusAnnotatio).nomen qua textus
            si typusNomen == "tabula" {
                g.requisita.tabula = verum
                redde "HashMap::new()"
            }
            si typusNomen == "lista" {
                g.requisita.lista = verum
                redde "Vec::new()"
            }
            si typusNomen == "copia" {
                g.requisita.copia = verum
                redde "HashSet::new()"
            }
            redde genExpressia(e.expressia, g)
        }

        casu VocatioExpressia ut e {
            varia args = [] innatum lista<textus>
            ex (e.argumenta qua lista<Expressia>) pro arg {
                args.adde(genExpressia(arg, g))
            }
            discerne e.vocatum {
                casu MembrumExpressia ut m {
                    si non (m.computatum qua bivalens) {
                        discerne m.proprietas {
                            casu Nomen ut prop {
                                fixum methodNomen = prop.valor qua textus
                                fixum obj = genExpressia(m.obiectum, g)
                                si nonnihil e.morphologia {
                                    fixum recipiens = (e.morphologia qua MorphologiaInvocatio).recipiens
                                    fixum translation = getNormaTranslation("rs", recipiens, methodNomen)
                                    si nonnihil translation {
                                        si nonnihil translation.method {
                                            redde scriptum("§.§(§)", obj, translation.method, args.coniunge(", "))
                                        }
                                        si nonnihil translation.template et nonnihil translation.params {
                                            redde applyNormaTemplate(translation.template qua textus, translation.params qua lista<textus>, obj, args)
                                        }
                                    }
                                }
                            }
                            casu _ { }
                        }
                    }
                }
                casu _ { }
            }
            redde scriptum("§(§)", genExpressia(e.vocatum, g), args.coniunge(", "))
        }

        casu MembrumExpressia ut e {
            fixum obj = genExpressia(e.obiectum, g)
            si e.computatum qua bivalens {
                fixum idx = genExpressia(e.proprietas, g)
                si e.optivum qua bivalens { redde scriptum("§.get(&§)", obj, idx) }
                redde scriptum("§[§]", obj, idx)
            }
            fixum prop = genExpressia(e.proprietas, g)
            redde scriptum("§.§", obj, prop)
        }

        casu NovumExpressia ut e {
            varia args = [] innatum lista<textus>
            ex (e.argumenta qua lista<Expressia>) pro arg {
                args.adde(genExpressia(arg, g))
            }
            redde scriptum("§::new(§)", genExpressia(e.vocatum, g), args.coniunge(", "))
        }

        casu CedeExpressia ut e {
            redde scriptum("§.await", genExpressia(e.argumentum, g))
        }

        casu ScriptumExpressia ut e {
            redde genScriptum(e.exemplar qua textus, e.argumenta qua lista<Expressia>, g)
        }

        casu SeriesExpressia ut e {
            varia items = [] innatum lista<textus>
            ex (e.elementa qua lista<Expressia>) pro elem {
                items.adde(genExpressia(elem, g))
            }
            redde scriptum("vec![§]", items.coniunge(", "))
        }

        casu ObiectumExpressia ut e {
            redde genObiectum(e.proprietates qua lista<ObiectumProprietas>, g)
        }

        casu LambdaExpressia ut e {
            varia params = [] innatum lista<textus>
            ex (e.parametra qua lista<LambdaParametrum>) pro p {
                si nonnihil p.typus {
                    params.adde(scriptum("§: §", p.nomen, genTypus(p.typus qua TypusAnnotatio, g)))
                } secus {
                    params.adde(p.nomen)
                }
            }
            redde scriptum("|§| §", params.coniunge(", "), genExpressia(e.corpus qua Expressia, g))
        }

        casu ConversioExpressia ut conv {
            fixum src = genExpressia(conv.expressia, g)
            elige conv.signum qua textus {
                casu "numeratum" reddit scriptum("§.parse::<i64>().unwrap()", src)
                casu "fractatum" reddit scriptum("§.parse::<f64>().unwrap()", src)
                casu "textatum" reddit scriptum("§.to_string()", src)
            }
            redde src
        }

        casu TranslatioExpressia ut t {
            fixum shifted = genExpressia(t.expressia, g)
            fixum amount = genExpressia(t.quantitas, g)
            fixum op = (t.directio qua textus) == "dextratum" sic ">>" secus "<<"
            redde scriptum("(§ § §)", shifted, op, amount)
        }

        # EstExpressia - type check
        casu EstExpressia ut e {
            fixum expr = genExpressia(e.expressia, g)
            fixum typusNomen = (e.scopus qua TypusAnnotatio).nomen qua textus
            redde scriptum("/* § is § */true", expr, typusNomen)
        }

        # CatenaExpressia - method chaining
        casu CatenaExpressia ut e {
            fixum fons = genExpressia(e.fons, g)
            redde applicaCatenaGradus(fons, e.gradus qua lista<CatenaGradus>, g)
        }

        # PraefixumExpressia - compile-time block
        casu PraefixumExpressia ut e {
            fixum corpus = e.corpus qua Sententia
            discerne corpus {
                casu MassaSententia ut m {
                    g.intraProfundum()
                    fixum body = genMassa(m.corpus qua lista<Sententia>, g)
                    g.exiProfundum()
                    redde scriptum("{{\n§\n§}}", body, g.ind())
                }
                casu _ { }
            }
            redde scriptum("(§)", genExpressia(e.corpus qua Expressia, g))
        }

        # LegeExpressia - read input
        casu LegeExpressia ut e {
            si (e.modus qua textus) == "line" {
                redde "std::io::stdin().read_line(&mut String::new()).unwrap()"
            }
            redde "std::io::read_to_string(std::io::stdin()).unwrap()"
        }

        # AbExpressia - filtering
        casu AbExpressia ut e {
            fixum fons = genExpressia(e.fons, g)
            si e.filtrum == nihil {
                redde fons
            }
            redde scriptum("§.into_iter().filter(|_x| true).collect::<Vec<_>>()", fons)
        }

        # DispersioElementum - spread operator
        casu DispersioElementum ut e {
            redde scriptum("/* spread */ §", genExpressia(e.argumentum, g))
        }

        # FingeExpressia - discriminated union construction
        casu FingeExpressia ut e {
            varia props = [] innatum lista<textus>
            ex (e.campi qua lista<ObiectumProprietas>) pro campo {
                fixum key = genExpressia(campo.clavis, g)
                fixum val = genExpressia(campo.valor, g)
                props.adde(scriptum("§: §", key, val))
            }
            redde scriptum("§ {{ § }}", e.variansNomen, props.coniunge(", "))
        }
    }
    redde "/* unknown expression */"
}

functio applicaCatenaGradus(textus fons, lista<CatenaGradus> gradus, RsGenerator g) -> textus {
    varia result = fons
    ex gradus pro step {
        fixum verbum = step.verbum qua textus
        elige verbum {
            casu "prima" {
                si nonnihil step.argumentum {
                    result = scriptum("§.into_iter().take(§).collect::<Vec<_>>()", result, genExpressia(step.argumentum qua Expressia, g))
                } secus {
                    result = scriptum("§.first().cloned()", result)
                }
            }
            casu "ultima" {
                si nonnihil step.argumentum {
                    result = scriptum("§.into_iter().rev().take(§).collect::<Vec<_>>()", result, genExpressia(step.argumentum qua Expressia, g))
                } secus {
                    result = scriptum("§.last().cloned()", result)
                }
            }
            casu "summa" { result = scriptum("§.into_iter().sum::<i64>()", result) }
            casu "longitudo" { result = scriptum("§.len()", result) }
            casu "ordina" { result = scriptum("{{ let mut v = §; v.sort(); v }}", result) }
            casu "inversa" { result = scriptum("{{ let mut v = §; v.reverse(); v }}", result) }
        }
    }
    redde result
}

functio applyNormaTemplate(textus template, lista<textus> params, textus obj, lista<textus> args) -> textus {
    varia values = [] innatum lista<textus>
    varia argIdx = 0
    ex params pro param {
        si param == "ego" {
            values.adde(obj)
        } secus {
            si argIdx < args.longitudo() {
                values.adde(args[argIdx])
                argIdx += 1
            } secus {
                values.adde("")
            }
        }
    }

    varia result = ""
    varia i = 0
    varia implicitIdx = 0

    dum i < template.longitudo() {
        fixum c = template[i]
        si c == "§" {
            si implicitIdx < values.longitudo() {
                result = result + values[implicitIdx]
            }
            implicitIdx += 1
        } secus {
            result = result + c
        }
        i += 1
    }
    redde result
}
