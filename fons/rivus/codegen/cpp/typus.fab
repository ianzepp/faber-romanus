# C++ Type Mapping - Latin types to C++ types
#
# Maps Latin type names to their C++ equivalents.

ex "../../ast/typus" importa TypusAnnotatio, TypusParametrum
ex "./nucleus" importa CppGenerator

# =============================================================================
# TYPE MAPPING
# =============================================================================

# Map a Latin type name to C++ type name
@ publica
functio mappaNomenTypi(textus nomen, CppGenerator g) -> textus {
    elige nomen {
        # Primitives
        casu "textus" {
            g.addeInclude("string")
            redde "std::string"
        }
        casu "numerus" {
            g.addeInclude("cstdint")
            redde "int64_t"
        }
        casu "fractus" reddit "double"
        casu "decimus" {
            g.addeInclude("cstdint")
            redde "long double"
        }
        casu "magnus" {
            g.addeInclude("cstdint")
            redde "__int128"
        }
        casu "bivalens" reddit "bool"
        casu "nihil" reddit "nullptr_t"
        casu "vacuum" reddit "void"
        casu "numquam" reddit "[[noreturn]] void"

        # Binary
        casu "octeti" {
            g.addeInclude("cstdint")
            g.addeInclude("vector")
            redde "std::vector<uint8_t>"
        }

        # Error
        casu "erratum" {
            g.addeInclude("stdexcept")
            redde "std::runtime_error"
        }

        # Object/unknown
        casu "objectum" reddit "auto"
        casu "ignotum" reddit "auto"
    }

    # User-defined type: pass through unchanged
    redde nomen
}

# =============================================================================
# TYPE GENERATION
# =============================================================================

# Generate C++ type from type annotation
@ publica
functio genTypus(TypusAnnotatio adnotatio, CppGenerator g) -> textus {
    fixum nomen = adnotatio.nomen

    # Handle union types - C++ uses std::variant
    si nonnihil adnotatio.unio {
        fixum unioTypi = adnotatio.unio qua lista<TypusAnnotatio>
        si unioTypi.longitudo() > 0 {
            g.addeInclude("variant")
            varia parts = [] innatum lista<textus>
            ex unioTypi pro u {
                parts.adde(genTypus(u, g))
            }
            redde scriptum("std::variant<§>", parts.coniunge(", "))
        }
    }

    # Handle generic types
    si nonnihil adnotatio.typusParametra {
        fixum parametra = adnotatio.typusParametra qua lista<TypusParametrum>
        si parametra.longitudo() > 0 {
            fixum result = genTypusGenericus(nomen, parametra, adnotatio.nullabilis, g)
            redde result
        }
    }

    # Map Latin type name to C++
    fixum base = mappaNomenTypi(nomen, g)

    # Handle nullable: textus? -> std::optional<std::string>
    si adnotatio.nullabilis {
        g.addeInclude("optional")
        redde scriptum("std::optional<§>", base)
    }

    redde base
}

# Generate generic type (lista<T>, tabula<K,V>, etc.)
functio genTypusGenericus(textus nomen, lista<TypusParametrum> parametra, bivalens nullabilis, CppGenerator g) -> textus {
    varia result = ""

    elige nomen {
        casu "lista" {
            g.addeInclude("vector")
            fixum elemTypus = parametra[0]
            discerne elemTypus {
                casu Typus ut t {
                    fixum inner = genTypus(t.adnotatio, g)
                    result = scriptum("std::vector<§>", inner)
                }
                casu _ { }
            }
            si result == "" {
                result = "std::vector<auto>"
            }
        }

        casu "tabula" {
            g.addeInclude("unordered_map")
            si parametra.longitudo() >= 2 {
                varia keyCpp = "auto"
                varia valCpp = "auto"

                discerne parametra[0] {
                    casu Typus ut t {
                        keyCpp = genTypus(t.adnotatio, g)
                    }
                    casu _ { }
                }
                discerne parametra[1] {
                    casu Typus ut t {
                        valCpp = genTypus(t.adnotatio, g)
                    }
                    casu _ { }
                }

                result = scriptum("std::unordered_map<§, §>", keyCpp, valCpp)
            } secus {
                result = "std::unordered_map<auto, auto>"
            }
        }

        casu "copia" {
            g.addeInclude("unordered_set")
            fixum elemTypus = parametra[0]
            varia inner = "auto"
            discerne elemTypus {
                casu Typus ut t {
                    inner = genTypus(t.adnotatio, g)
                }
                casu _ { }
            }
            result = scriptum("std::unordered_set<§>", inner)
        }

        casu "promissum" {
            g.addeInclude("future")
            fixum innerTypus = parametra[0]
            varia inner = "auto"
            discerne innerTypus {
                casu Typus ut t {
                    inner = genTypus(t.adnotatio, g)
                }
                casu _ { }
            }
            result = scriptum("std::future<§>", inner)
        }
    }

    # Default case: user-defined type, pass through
    si result == "" {
        result = nomen
    }

    si nullabilis {
        g.addeInclude("optional")
        redde scriptum("std::optional<§>", result)
    }

    redde result
}

# Generate a single type parameter
@ publica
functio genTypusParametrum(TypusParametrum param, CppGenerator g) -> textus? {
    discerne param {
        casu Typus ut p {
            redde genTypus(p.adnotatio, g)
        }
        casu Littera {
            # Numeric parameters become template values
            redde nihil
        }
    }
    redde nihil
}

# Generate type parameter declarations for generics
# Example: <T, U, V> -> template<typename T, typename U, typename V>
@ publica
functio genTypusParametra(lista<textus> parametra) -> textus {
    varia typenames = [] innatum lista<textus>
    ex parametra pro p {
        typenames.adde(scriptum("typename §", p))
    }
    redde scriptum("template<§>", typenames.coniunge(", "))
}
