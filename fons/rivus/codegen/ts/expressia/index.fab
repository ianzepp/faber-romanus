# TypeScript Expression Generator - Dispatch to expression handlers
#
# Routes expression AST nodes to their specific generators.
# Uses scriptum() for string formatting for consistency.

ex "../../../ast/expressia" importa Expressia, LitteraGenus, ObiectumProprietas, LambdaParametrum, MorphologiaInvocatio
ex "../../../ast/expressia" importa AbFiltrum, CatenaGradus
ex "../../../ast/sententia" importa Sententia, VariaGenus
ex "../../../ast/typus" importa TypusAnnotatio
ex "../nucleus" importa TsGenerator
ex "../typus" importa genTypus
ex "../../../parser/morphologia" importa parseMethodum
ex "../../radices" importa generaListaMethodum

# =============================================================================
# EXPRESSION DISPATCH
# =============================================================================

# Generate TypeScript code for an expression
@ publica
functio genExpressia(Expressia expr, TsGenerator g) -> textus {
    discerne expr {
        # Identifiers
        casu Nomen ut e {
            redde e.valor qua textus
        }

        casu EgoExpressia {
            redde "this"
        }

        # Literals
        casu Littera ut e {
            redde genLittera(e.species qua LitteraGenus, e.crudus qua textus)
        }

        casu LitteraExemplar ut e {
            redde genLitteraExemplar(e.partes qua lista<textus>, e.expressiae qua lista<Expressia>, g)
        }

        casu LitteraRegex ut e {
            g.requisita.usesRegex = verum
            # WHY: Escape '/' so JS regex literals stay valid.
            fixum pattern = escapaRegex(e.forma)
            redde scriptum("/§/§", pattern, e.vexilla)
        }

        # Binary and unary
        casu BinariaExpressia ut e {
            fixum sinister = genExpressia(e.sinister, g)
            fixum dexter = genExpressia(e.dexter, g)
            varia signum = e.signum qua textus

            # WHY: Normalize keyword operators to JS equivalents.
            elige signum {
                casu "et" { signum = "&&" }
                casu "aut" { signum = "||" }
                casu "vel" { signum = "??" }
            }

            # WHY: Range containment has target-specific lowering.
            si signum == "intra" {
                discerne e.dexter {
                    casu AmbitusExpressia ut r {
                        fixum initium = genExpressia(r.initium, g)
                        fixum finis = genExpressia(r.finis, g)
                        fixum op = (r.inclusivum qua bivalens) sic "<=" secus "<"
                        redde scriptum("(§ >= § && § § §)", sinister, initium, sinister, op, finis)
                    }
                }
                redde scriptum("(§ intra §)", sinister, dexter)
            }

            # WHY: Set membership lowers to includes() in TS.
            si signum == "inter" {
                redde scriptum("§.includes(§)", dexter, sinister)
            }

            redde scriptum("(§ § §)", sinister, signum, dexter)
        }

        casu UnariaExpressia ut e {
            fixum arg = genExpressia(e.argumentum, g)

            # WHY: Null/empty checks are language-level operators, not JS prefixes.
            elige e.signum qua textus {
                casu "nulla" {
                    redde scriptum("(§ == null || (Array.isArray(§) || typeof § === 'string' ? §.length === 0 : typeof § === 'object' ? Object.keys(§).length === 0 : !§))", arg, arg, arg, arg, arg, arg, arg, arg)
                }
                casu "nonnulla" {
                    redde scriptum("(§ != null && (Array.isArray(§) || typeof § === 'string' ? §.length > 0 : typeof § === 'object' ? Object.keys(§).length > 0 : Boolean(§)))", arg, arg, arg, arg, arg, arg, arg, arg)
                }
                casu "nihil" {
                    redde scriptum("(§ == null)", arg)
                }
                casu "nonnihil" {
                    redde scriptum("(§ != null)", arg)
                }
                casu "negativum" {
                    redde scriptum("(§ < 0)", arg)
                }
                casu "positivum" {
                    redde scriptum("(§ > 0)", arg)
                }
            }

            # WHY: Preserve correct precedence for negated est checks.
            si e.signum == "!" {
                discerne e.argumentum {
                    casu EstExpressia ut est {
                        redde genEstExpressiaNegata(est.expressia, est.scopus qua TypusAnnotatio, g)
                    }
                }
            }

            redde scriptum("§§", e.signum, arg)
        }

        casu AssignatioExpressia ut e {
            # Map assignments for tabula<K,V>
            discerne e.sinister {
                casu MembrumExpressia ut m {
                    si m.computatum qua bivalens {
                        fixum tabulaNomen = invenitTabulaNomen(m.obiectum, g)
                        si nonnihil tabulaNomen {
                            fixum obj = genExpressia(m.obiectum, g)
                            fixum prop = genNudaExpressia(m.proprietas, g)
                            fixum right = genNudaExpressia(e.dexter, g)

                            fixum getExpr = genTabulaGet(obj, prop, m.optivum qua bivalens, m.nonNullum qua bivalens)
                            fixum setStmt = genTabulaSet(obj, prop, "__next", m.optivum qua bivalens, m.nonNullum qua bivalens)

                            si e.signum == "=" {
                                redde scriptum("(() => { const __next = §; §; return __next; })()", right, setStmt)
                            }

                            varia op = e.signum qua textus
                            si op.longitudo() > 1 et op.sectio(op.longitudo() - 1, op.longitudo()) == "=" {
                                op = op.sectio(0, op.longitudo() - 1)
                            }

                            redde scriptum("(() => { const __next = (§ as any) § §; §; return __next; })()", getExpr, op, right, setStmt)
                        }
                    }
                }
            }

            # WHY: Avoid extra parens on RHS for assignments.
            redde scriptum("§ § §", genExpressia(e.sinister, g), e.signum, genNudaExpressia(e.dexter, g))
        }

        casu CondicioExpressia ut e {
            redde scriptum("§ ? § : §", genExpressia(e.condicio, g), genExpressia(e.consequens, g), genExpressia(e.alternans, g))
        }

        casu AmbitusExpressia ut e {
            redde genAmbitusExpressia(e, g)
        }

        casu QuaExpressia ut e {
            redde scriptum("(§ as §)", genExpressia(e.expressia, g), genTypus(e.scopus qua TypusAnnotatio, g))
        }

        casu EstExpressia ut e {
            redde genEstExpressia(e.expressia, e.scopus qua TypusAnnotatio, g)
        }

        casu CatenaExpressia ut e {
            fixum fons = genExpressia(e.fons, g)
            redde applicaCatenaGradus(fons, e.gradus qua lista<CatenaGradus>, g)
        }

        casu PraefixumExpressia ut e {
            # Compile-time evaluation - in TS, wrap in IIFE for block form.
            fixum corpus = e.corpus qua Sententia
            discerne corpus {
                casu MassaSententia ut m {
                    g.intraProfundum()
                    fixum body = genPraefixumMassa(m.corpus, g)
                    g.exiProfundum()
                    redde scriptum("(() => {\n§\n§})()", body, g.ind())
                }
            }
            # Fallback: expression form.
            redde scriptum("(§)", genExpressia(e.corpus qua Expressia, g))
        }

        # Calls and member access
        casu VocatioExpressia ut e {
            varia args = [] qua lista<textus>
            ex (e.argumenta qua lista<Expressia>) pro arg {
                args.adde(genExpressia(arg, g))
            }

            # WHY: Morphology dispatch is receiver-bound and semantic-gated.
            si nonnihil e.morphologia {
                discerne e.vocatum {
                    casu MembrumExpressia ut m {
                        si non (m.computatum qua bivalens) {
                            discerne m.proprietas {
                                casu Nomen ut prop {
                                    fixum methodNomen = prop.valor qua textus
                                    fixum parsed = parseMethodum(methodNomen)
                                    si nonnihil parsed et (e.morphologia qua MorphologiaInvocatio).recipiens == "lista" {
                                        fixum obj = genExpressia(m.obiectum, g)
                                        fixum result = generaListaMethodum((e.morphologia qua MorphologiaInvocatio).radix, obj, args, parsed.flagga)
                                        si nonnihil result {
                                            redde result
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            # Default: pass through as-is
            fixum optMark = (e.optivum qua bivalens) sic "?." secus ""
            redde scriptum("§§(§)", genExpressia(e.vocatum, g), optMark, args.coniunge(", "))
        }

        casu MembrumExpressia ut e {
            fixum obj = genExpressia(e.obiectum, g)
            si e.computatum qua bivalens {
                discerne e.proprietas {
                    casu AmbitusExpressia ut a {
                        redde genSectioAccess(obj, a, e.optivum qua bivalens, e.nonNullum qua bivalens, g)
                    }
                }

                fixum idx = genNudaExpressia(e.proprietas, g)

                fixum tabulaNomen = invenitTabulaNomen(e.obiectum, g)
                si nonnihil tabulaNomen {
                    redde genTabulaGet(obj, idx, e.optivum qua bivalens, e.nonNullum qua bivalens)
                }

                si estNegativusIndex(e.proprietas) {
                    redde genNegativusAccess(obj, idx, e.optivum qua bivalens, e.nonNullum qua bivalens)
                }

                si e.optivum qua bivalens {
                    redde scriptum("§?.[§]", obj, idx)
                }
                si e.nonNullum qua bivalens {
                    redde scriptum("§![§]", obj, idx)
                }
                redde scriptum("§[§]", obj, idx)
            }
            # Dot access
            fixum prop = genExpressia(e.proprietas, g)
            si e.optivum qua bivalens {
                redde scriptum("§?.§", obj, prop)
            }
            si e.nonNullum qua bivalens {
                redde scriptum("§!.§", obj, prop)
            }
            redde scriptum("§.§", obj, prop)
        }

        casu NovumExpressia ut e {
            varia args = [] qua lista<textus>
            ex (e.argumenta qua lista<Expressia>) pro arg {
                args.adde(genExpressia(arg, g))
            }
            # WHY: novum supports optional override object as a final argument.
            si nonnihil e.initor {
                args.adde(genExpressia(e.initor, g))
            }
            redde scriptum("new §(§)", genExpressia(e.vocatum, g), args.coniunge(", "))
        }

        casu CedeExpressia ut e {
            # cede maps to yield in generators, await in async functions
            si g.inFiunt {
                redde scriptum("yield respond.item(§)", genExpressia(e.argumentum, g))
            }
            si g.inFient {
                redde scriptum("yield respond.item(await §)", genExpressia(e.argumentum, g))
            }
            si g.inCursore {
                redde scriptum("yield §", genExpressia(e.argumentum, g))
            }
            redde scriptum("await §", genExpressia(e.argumentum, g))
        }

        casu ScriptumExpressia ut e {
            redde genScriptum(e.exemplar qua textus, e.argumenta qua lista<Expressia>, g)
        }

        casu LegeExpressia ut e {
            si (e.modus qua textus) == "line" {
                # WHY: Match faber output; Bun needs readline for single-line input.
                redde "(await (async () => { const rl = require(\"readline\").createInterface({ input: process.stdin }); for await (const line of rl) { rl.close(); return line; } return \"\"; })())"
            }
            # WHY: Bun stdin reads all input via text().
            redde "await Bun.stdin.text()"
        }

        casu AbExpressia ut e {
            fixum fons = genExpressia(e.fons, g)

            si e.filtrum == nihil {
                si nonnihil e.gradus {
                    redde applicaCatenaGradus(fons, e.gradus qua lista<CatenaGradus>, g)
                }
                redde fons
            }

            fixum filtrum = e.filtrum qua AbFiltrum
            fixum param = "_x"
            varia condicio = ""

            si filtrum.habetUbi {
                condicio = genExpressia(filtrum.condicio, g)
            } secus {
                condicio = scriptum("§.§", param, genExpressia(filtrum.condicio, g))
            }

            si e.negata qua bivalens {
                condicio = scriptum("!(§)", condicio)
            }

            varia result = scriptum("§.filter(§ => §)", fons, param, condicio)
            si nonnihil e.gradus {
                result = applicaCatenaGradus(result, e.gradus qua lista<CatenaGradus>, g)
            }
            redde result
        }

        # Collections
        casu SeriesExpressia ut e {
            varia items = [] qua lista<textus>
            ex (e.elementa qua lista<Expressia>) pro elem {
                items.adde(genExpressia(elem, g))
            }
            redde scriptum("[§]", items.coniunge(", "))
        }

        casu ObiectumExpressia ut e {
            redde genObiectum(e.proprietates qua lista<ObiectumProprietas>, g)
        }

        casu DispersioElementum ut e {
            redde scriptum("...§", genExpressia(e.argumentum, g))
        }

        # Lambda
        casu LambdaExpressia ut e {
            varia params = [] qua lista<textus>
            ex (e.parametra qua lista<LambdaParametrum>) pro p {
                si nonnihil p.typus {
                    params.adde(scriptum("§: §", p.nomen, genTypus(p.typus qua TypusAnnotatio, g)))
                } secus {
                    params.adde(p.nomen)
                }
            }
            varia retType = ""
            si nonnihil e.typusReditus {
                retType = scriptum(": §", genTypus(e.typusReditus qua TypusAnnotatio, g))
            }
            fixum massa = e.corpus qua Sententia
            discerne massa {
                casu MassaSententia ut m {
                    g.intraProfundum()
                    fixum body = genPraefixumMassa(m.corpus, g)
                    g.exiProfundum()
                    si body == "" {
                        redde scriptum("(§)§ => {{}}", params.coniunge(", "), retType)
                    }
                    redde scriptum("(§)§ => {\n§\n§}", params.coniunge(", "), retType, body, g.ind())
                }
            }
            redde scriptum("(§)§ => §", params.coniunge(", "), retType, genExpressia(e.corpus qua Expressia, g))
        }

        # Discretio construction
        casu FingeExpressia ut e {
            # finge Click { x: 10 } qua Event -> { tag: 'Click', x: 10 }
            varia props = [] qua lista<textus>
            props.adde(scriptum("tag: '§'", e.variansNomen))
            ex (e.campi qua lista<ObiectumProprietas>) pro campo {
                fixum key = genExpressia(campo.clavis, g)
                fixum val = genExpressia(campo.valor, g)
                props.adde(scriptum("§: §", key, val))
            }
            redde scriptum("{{ § }}", props.coniunge(", "))
        }
    }

    # Fallback - should not reach here
    redde "/* unknown expression */"
}

# =============================================================================
# LITERAL HELPERS
# =============================================================================

# Generate literal value
@ publica
functio genLittera(LitteraGenus species, textus crudus) -> textus {
    si species == LitteraGenus.Verum {
        redde "true"
    }
    si species == LitteraGenus.Falsum {
        redde "false"
    }
    si species == LitteraGenus.Nihil {
        redde "null"
    }
    si species == LitteraGenus.Textus {
        # String literals need quotes - lexer strips them
        redde scriptum("\"§\"", crudus)
    }
    si species == LitteraGenus.Exemplar {
        # Template literals need backticks - lexer strips them
        redde "`" + crudus + "`"
    }
    # Numerus, Fractus pass through raw value
    redde crudus
}

# Escape forward slashes for JS regex literals.
functio escapaRegex(textus pattern) -> textus {
    varia result = ""
    varia i = 0
    dum i < pattern.longitudo() {
        fixum c = pattern[i]
        si c == "/" {
            result = result + "\\/"
        } secus {
            result = result + c
        }
        i += 1
    }
    redde result
}

# Minimal statement lowering for praefixum blocks (avoid codegen cycles).
functio genPraefixumMassa(lista<Sententia> corpus, TsGenerator g) -> textus {
    si corpus.longitudo() == 0 {
        redde ""
    }
    varia lines = [] qua lista<textus>
    ex corpus pro stmt {
        lines.adde(genPraefixumSententia(stmt, g))
    }
    redde lines.coniunge("\n")
}

functio genPraefixumSententia(Sententia stmt, TsGenerator g) -> textus {
    discerne stmt {
        casu VariaSententia ut s {
            fixum keyword = s.species == VariaGenus.Fixum aut s.species == VariaGenus.Figendum sic "const" secus "let"
            fixum asyncPrefix = s.species == VariaGenus.Figendum aut s.species == VariaGenus.Variandum sic "await " secus ""
            varia result = scriptum("§§ §", g.ind(), keyword, s.nomen)

            si nonnihil s.typus {
                result = scriptum("§: §", result, genTypus(s.typus qua TypusAnnotatio, g))
            }

            si nonnihil s.valor {
                result = scriptum("§ = §§", result, asyncPrefix, genExpressia(s.valor qua Expressia, g))
            }

            redde scriptum("§;", result)
        }

        casu ReddeSententia ut s {
            si nonnihil s.valor {
                redde scriptum("§return §;", g.ind(), genExpressia(s.valor qua Expressia, g))
            }
            redde scriptum("§return;", g.ind())
        }

        casu ExpressiaSententia ut s {
            redde scriptum("§§;", g.ind(), genExpressia(s.expressia, g))
        }
    }

    redde scriptum("§/* praefixum: unsupported statement */", g.ind())
}

# =============================================================================
# RANGE + BARE EXPRESSIONS
# =============================================================================

@ publica
functio genAmbitusExpressia(Expressia expr, TsGenerator g) -> textus {
    # WHY: Ranges become arrays outside of for-loops.
    discerne expr {
        casu AmbitusExpressia ut e {
            fixum initium = genExpressia(e.initium, g)
            fixum finis = genExpressia(e.finis, g)
            fixum adj = (e.inclusivum qua bivalens) sic " + 1" secus ""

            si nonnihil e.gradus {
                fixum gradus = genExpressia(e.gradus qua Expressia, g)
                si e.inclusivum qua bivalens {
                    redde scriptum("Array.from({length: Math.floor((§ - §) / §) + 1}, (_, i) => § + i * §)", finis, initium, gradus, initium, gradus)
                }
                redde scriptum("Array.from({length: Math.ceil((§ - §) / §)}, (_, i) => § + i * §)", finis, initium, gradus, initium, gradus)
            }

            redde scriptum("Array.from({length: § - §§}, (_, i) => § + i)", finis, initium, adj, initium)
        }
    }

    redde genExpressia(expr, g)
}

functio applicaCatenaGradus(textus fons, lista<CatenaGradus> gradus, TsGenerator g) -> textus {
    varia result = fons
    ex gradus pro gradusSingulus {
        fixum verbum = gradusSingulus.verbum qua textus
        elige verbum {
            casu "prima" {
                fixum arg = genExpressia(gradusSingulus.argumentum qua Expressia, g)
                result = scriptum("§.slice(0, §)", result, arg)
            }
            casu "ultima" {
                fixum arg = genExpressia(gradusSingulus.argumentum qua Expressia, g)
                result = scriptum("§.slice(-§)", result, arg)
            }
            casu "summa" {
                result = scriptum("§.reduce((a, b) => a + b, 0)", result)
            }
        }
    }
    redde result
}

functio invenitTabulaNomen(Expressia obiectum, TsGenerator g) -> textus? {
    discerne obiectum {
        casu Nomen ut n {
            fixum nomen = n.valor qua textus
            ex g.tabulaNominata pro item {
                si item == nomen {
                    redde nomen
                }
            }
        }
    }
    redde nihil
}

functio genTabulaGet(textus obj, textus prop, bivalens optivum, bivalens nonNullum) -> textus {
    si optivum {
        redde scriptum("§?.get(§)", obj, prop)
    }
    si nonNullum {
        redde scriptum("§!.get(§)", obj, prop)
    }
    redde scriptum("§.get(§)", obj, prop)
}

functio genTabulaSet(textus obj, textus prop, textus valor, bivalens optivum, bivalens nonNullum) -> textus {
    si optivum {
        redde scriptum("§?.set(§, §)", obj, prop, valor)
    }
    si nonNullum {
        redde scriptum("§!.set(§, §)", obj, prop, valor)
    }
    redde scriptum("§.set(§, §)", obj, prop, valor)
}

functio estNegativusIndex(Expressia expr) -> bivalens {
    discerne expr {
        casu UnariaExpressia ut u {
            redde (u.signum qua textus) == "-"
        }
    }
    redde falsum
}

functio genNegativusAccess(textus obj, textus idx, bivalens optivum, bivalens nonNullum) -> textus {
    si optivum {
        redde scriptum("§?.at(§)", obj, idx)
    }
    si nonNullum {
        redde scriptum("§!.at(§)", obj, idx)
    }
    redde scriptum("§.at(§)", obj, idx)
}

functio genSectioAccess(textus obj, Expressia range, bivalens optivum, bivalens nonNullum, TsGenerator g) -> textus {
    discerne range {
        casu AmbitusExpressia ut a {
            fixum initium = genExpressia(a.initium, g)
            fixum finis = genExpressia(a.finis, g)
            varia receiver = obj
            si optivum {
                receiver = scriptum("§?", receiver)
            } sin nonNullum {
                receiver = scriptum("§!", receiver)
            }

            si a.inclusivum qua bivalens {
                fixum literal = legeNumerusLiteralis(a.finis)
                si nonnihil literal {
                    fixum inclusive = (literal qua numerus) + 1
                    si inclusive == 0 {
                        redde scriptum("§.slice(§)", receiver, initium)
                    }
                    redde scriptum("§.slice(§, §)", receiver, initium, inclusive)
                }
                redde scriptum("§.slice(§, § + 1)", receiver, initium, finis)
            }

            redde scriptum("§.slice(§, §)", receiver, initium, finis)
        }
    }

    redde scriptum("§[§]", obj, genExpressia(range, g))
}

functio legeNumerusLiteralis(Expressia expr) -> numerus? {
    discerne expr {
        casu Littera ut l {
            si l.species == LitteraGenus.Numerus {
                redde legeNumerusTextus(l.crudus)
            }
        }
        casu UnariaExpressia ut u {
            si (u.signum qua textus) == "-" {
                discerne u.argumentum {
                    casu Littera ut l {
                        si l.species == LitteraGenus.Numerus {
                            redde -legeNumerusTextus(l.crudus)
                        }
                    }
                }
            }
        }
    }
    redde nihil
}

functio legeNumerusTextus(textus crudus) -> numerus {
    varia result = 0
    varia i = 0
    dum i < crudus.longitudo() {
        fixum c = crudus.sectio(i, i + 1)
        varia digit = 0
        elige c {
            casu "0" { digit = 0 }
            casu "1" { digit = 1 }
            casu "2" { digit = 2 }
            casu "3" { digit = 3 }
            casu "4" { digit = 4 }
            casu "5" { digit = 5 }
            casu "6" { digit = 6 }
            casu "7" { digit = 7 }
            casu "8" { digit = 8 }
            casu "9" { digit = 9 }
        }
        result = result * 10 + digit
        i += 1
    }
    redde result
}

@ publica
functio genNudaExpressia(Expressia expr, TsGenerator g) -> textus {
    # WHY: Flatten binary expressions when outer parens are unnecessary.
    discerne expr {
        casu BinariaExpressia ut e {
            fixum sin = genNudaExpressia(e.sinister, g)
            fixum dex = genNudaExpressia(e.dexter, g)
            varia signum = e.signum qua textus
            elige signum {
                casu "et" { signum = "&&" }
                casu "aut" { signum = "||" }
                casu "vel" { signum = "??" }
            }
            redde scriptum("§ § §", sin, signum, dex)
        }
    }

    redde genExpressia(expr, g)
}

# Generate template literal
@ publica
functio genLitteraExemplar(lista<textus> partes, lista<Expressia> expressiae, TsGenerator g) -> textus {
    varia result = "`"
    varia i = 0
    ex partes pro pars {
        result = result + pars
        si i < expressiae.longitudo() {
            result = result + "${" + genExpressia(expressiae[i], g) + "}"
        }
        i += 1
    }
    result = result + "`"
    redde result
}

# =============================================================================
# COMPLEX EXPRESSION HELPERS
# =============================================================================

# Generate est (type check) expression
@ publica
functio genEstExpressia(Expressia expr, TypusAnnotatio scopus, TsGenerator g) -> textus {
    redde genEstExpressiaCum(expr, scopus, g, falsum)
}

functio genEstExpressiaNegata(Expressia expr, TypusAnnotatio scopus, TsGenerator g) -> textus {
    redde genEstExpressiaCum(expr, scopus, g, verum)
}

functio genEstExpressiaCum(Expressia expr, TypusAnnotatio scopus, TsGenerator g, bivalens negatum) -> textus {
    fixum val = genExpressia(expr, g)

    # Primitive type checks use typeof
    si scopus.nomen == "textus" {
        fixum op = negatum sic "!==" secus "==="
        fixum check = scriptum("typeof § § \"string\"", val, op)
        si scopus.nullabilis {
            redde negatum sic scriptum("§ && § !== null", check, val) secus scriptum("§ || § === null", check, val)
        }
        redde check
    }
    si scopus.nomen == "numerus" aut scopus.nomen == "fractus" {
        fixum op = negatum sic "!==" secus "==="
        fixum check = scriptum("typeof § § \"number\"", val, op)
        si scopus.nullabilis {
            redde negatum sic scriptum("§ && § !== null", check, val) secus scriptum("§ || § === null", check, val)
        }
        redde check
    }
    si scopus.nomen == "bivalens" {
        fixum op = negatum sic "!==" secus "==="
        fixum check = scriptum("typeof § § \"boolean\"", val, op)
        si scopus.nullabilis {
            redde negatum sic scriptum("§ && § !== null", check, val) secus scriptum("§ || § === null", check, val)
        }
        redde check
    }
    si scopus.nomen == "nihil" {
        fixum op = negatum sic "!==" secus "==="
        redde scriptum("§ § null", val, op)
    }
    si scopus.nomen == "lista" {
        si negatum {
            redde scriptum("!Array.isArray(§)", val)
        }
        redde scriptum("Array.isArray(§)", val)
    }

    # User-defined types use instanceof
    si negatum {
        redde scriptum("!(§ instanceof §)", val, scopus.nomen)
    }
    redde scriptum("§ instanceof §", val, scopus.nomen)
}

# Generate scriptum (format string) expression
# Uses § (section sign) as placeholder
@ publica
functio genScriptum(textus exemplar, lista<Expressia> argumenta, TsGenerator g) -> textus {
    # WHY: No-arg scriptum should emit a plain string literal (no template).
    si argumenta.longitudo() == 0 {
        redde scriptum("\"§\"", exemplar)
    }

    # Convert scriptum("Hello, §!", name) to template literal
    varia result = "`"
    varia argIndex = 0
    varia i = 0

    dum i < exemplar.longitudo() {
        fixum c = exemplar[i]
        si c == "§" {
            fixum arg = argIndex < argumenta.longitudo() sic genExpressia(argumenta[argIndex], g) secus "undefined"
            result = result + "${" + arg + "}"
            argIndex += 1
        } secus {
            result = result + c
        }
        i += 1
    }

    result = result + "`"
    redde result
}

# Generate object literal
@ publica
functio genObiectum(lista<ObiectumProprietas> proprietates, TsGenerator g) -> textus {
    si proprietates.longitudo() == 0 {
        redde "{}"
    }

    varia props = [] qua lista<textus>
    ex proprietates pro prop {
        si prop.dispersum {
            # WHY: Spread properties lower to ...expr in JS object literals.
            props.adde(scriptum("...§", genExpressia(prop.valor, g)))
        } sin prop.brevitas {
            # Shorthand: { name } -> { name }
            props.adde(genExpressia(prop.clavis, g))
        } sin prop.computatum {
            # Computed: { [expr]: value }
            props.adde(scriptum("[§]: §", genExpressia(prop.clavis, g), genExpressia(prop.valor, g)))
        } secus {
            # Normal: { key: value }
            props.adde(scriptum("§: §", genExpressia(prop.clavis, g), genExpressia(prop.valor, g)))
        }
    }

    redde scriptum("{{ § }}", props.coniunge(", "))
}
