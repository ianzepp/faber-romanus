# TypeScript Expression Generator - Dispatch to expression handlers
#
# Routes expression AST nodes to their specific generators.
# Uses scriptum() for string formatting for consistency.

ex "../../../ast/expressia" importa Expressia, LitteraGenus, ObiectumProprietas, LambdaParametrum
ex "../../../ast/typus" importa TypusAnnotatio
ex "../nucleus" importa TsGenerator
ex "../typus" importa genTypus
ex "../../../parser/morphologia" importa parseMethodum, estRadixListae
ex "../../radices" importa generaListaMethodum

# =============================================================================
# EXPRESSION DISPATCH
# =============================================================================

# Generate TypeScript code for an expression
@ publica
functio genExpressia(Expressia expr, TsGenerator g) -> textus {
    discerne expr {
        # Identifiers
        casu Nomen ut e {
            redde e.valor qua textus
        }

        casu EgoExpressia {
            redde "this"
        }

        # Literals
        casu Littera ut e {
            redde genLittera(e.species qua LitteraGenus, e.crudus qua textus)
        }

        casu LitteraExemplar ut e {
            redde genLitteraExemplar(e.partes qua lista<textus>, e.expressiae qua lista<Expressia>, g)
        }

        casu LitteraRegex ut e {
            g.features.usesRegex = verum
            redde scriptum("/§/§", e.forma, e.vexilla)
        }

        # Binary and unary
        casu BinariaExpressia ut e {
            fixum sinister = genExpressia(e.sinister, g)
            fixum dexter = genExpressia(e.dexter, g)
            varia signum = e.signum qua textus

            # WHY: Normalize keyword operators to JS equivalents.
            elige signum {
                casu "et" { signum = "&&" }
                casu "aut" { signum = "||" }
                casu "vel" { signum = "??" }
            }

            # WHY: Range containment has target-specific lowering.
            si signum == "intra" {
                discerne e.dexter {
                    casu AmbitusExpressia ut r {
                        fixum initium = genExpressia(r.initium, g)
                        fixum finis = genExpressia(r.finis, g)
                        fixum op = (r.inclusivum qua bivalens) sic "<=" secus "<"
                        redde scriptum("(§ >= § && § § §)", sinister, initium, sinister, op, finis)
                    }
                }
                redde scriptum("(§ intra §)", sinister, dexter)
            }

            # WHY: Set membership lowers to includes() in TS.
            si signum == "inter" {
                redde scriptum("§.includes(§)", dexter, sinister)
            }

            redde scriptum("(§ § §)", sinister, signum, dexter)
        }

        casu UnariaExpressia ut e {
            fixum arg = genExpressia(e.argumentum, g)

            # WHY: Null/empty checks are language-level operators, not JS prefixes.
            elige e.signum qua textus {
                casu "nulla" {
                    redde scriptum("(§ == null || (Array.isArray(§) || typeof § === 'string' ? §.length === 0 : typeof § === 'object' ? Object.keys(§).length === 0 : !§))", arg, arg, arg, arg, arg, arg, arg, arg)
                }
                casu "nonnulla" {
                    redde scriptum("(§ != null && (Array.isArray(§) || typeof § === 'string' ? §.length > 0 : typeof § === 'object' ? Object.keys(§).length > 0 : Boolean(§)))", arg, arg, arg, arg, arg, arg, arg, arg)
                }
                casu "nihil" {
                    redde scriptum("(§ == null)", arg)
                }
                casu "nonnihil" {
                    redde scriptum("(§ != null)", arg)
                }
                casu "negativum" {
                    redde scriptum("(§ < 0)", arg)
                }
                casu "positivum" {
                    redde scriptum("(§ > 0)", arg)
                }
            }

            # WHY: Preserve correct precedence for negated est checks.
            si e.signum == "!" {
                discerne e.argumentum {
                    casu EstExpressia ut est {
                        redde genEstExpressiaNegata(est.expressia, est.scopus qua TypusAnnotatio, g)
                    }
                }
            }

            redde scriptum("§§", e.signum, arg)
        }

        casu AssignatioExpressia ut e {
            # WHY: Avoid extra parens on RHS for assignments.
            redde scriptum("§ § §", genExpressia(e.sinister, g), e.signum, genNudaExpressia(e.dexter, g))
        }

        casu CondicioExpressia ut e {
            redde scriptum("§ ? § : §", genExpressia(e.condicio, g), genExpressia(e.consequens, g), genExpressia(e.alternans, g))
        }

        casu AmbitusExpressia ut e {
            redde genAmbitusExpressia(e, g)
        }

        casu QuaExpressia ut e {
            redde scriptum("§ as §", genExpressia(e.expressia, g), genTypus(e.scopus qua TypusAnnotatio, g))
        }

        casu EstExpressia ut e {
            redde genEstExpressia(e.expressia, e.scopus qua TypusAnnotatio, g)
        }

        casu CatenaExpressia ut e {
            # Collection DSL chains - TODO: implement properly
            redde genExpressia(e.fons, g)
        }

        casu PraefixumExpressia ut e {
            # Compile-time evaluation - in TS, just evaluate the expression
            redde genExpressia(e.corpus, g)
        }

        # Calls and member access
        casu VocatioExpressia ut e {
            varia args = [] qua lista<textus>
            ex (e.argumenta qua lista<Expressia>) pro arg {
                args.adde(genExpressia(arg, g))
            }

            # WHY: Check for morphology-based collection method dispatch.
            # If callee is a member expression with a recognized verb conjugation,
            # dispatch to the stem-based generator instead of literal passthrough.
            discerne e.vocatum {
                casu MembrumExpressia ut m {
                    # Only non-computed member access (dot notation)
                    si non (m.computatum qua bivalens) {
                        discerne m.proprietas {
                            casu Nomen ut prop {
                                fixum methodNomen = prop.valor qua textus
                                fixum parsed = parseMethodum(methodNomen)

                                si nonnihil parsed {
                                    si estRadixListae(parsed.radix) {
                                        fixum obj = genExpressia(m.obiectum, g)
                                        fixum result = generaListaMethodum(parsed.radix, obj, args, parsed.flagga)
                                        si nonnihil result {
                                            redde result
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            # Default: pass through as-is
            fixum optMark = (e.optivum qua bivalens) sic "?." secus ""
            redde scriptum("§§(§)", genExpressia(e.vocatum, g), optMark, args.coniunge(", "))
        }

        casu MembrumExpressia ut e {
            fixum obj = genExpressia(e.obiectum, g)
            si e.computatum qua bivalens {
                fixum idx = genExpressia(e.proprietas, g)
                si e.optivum qua bivalens {
                    redde scriptum("§?.[§]", obj, idx)
                }
                redde scriptum("§[§]", obj, idx)
            }
            # Dot access
            fixum prop = genExpressia(e.proprietas, g)
            si e.optivum qua bivalens {
                redde scriptum("§?.§", obj, prop)
            }
            si e.nonNullum qua bivalens {
                redde scriptum("§!.§", obj, prop)
            }
            redde scriptum("§.§", obj, prop)
        }

        casu NovumExpressia ut e {
            varia args = [] qua lista<textus>
            ex (e.argumenta qua lista<Expressia>) pro arg {
                args.adde(genExpressia(arg, g))
            }
            # WHY: novum supports optional override object as a final argument.
            si nonnihil e.initor {
                args.adde(genExpressia(e.initor, g))
            }
            redde scriptum("new §(§)", genExpressia(e.vocatum, g), args.coniunge(", "))
        }

        casu CedeExpressia ut e {
            # cede maps to yield in generators, await in async functions
            si g.inFiunt {
                redde scriptum("yield respond.item(§)", genExpressia(e.argumentum, g))
            }
            si g.inFient {
                redde scriptum("yield respond.item(await §)", genExpressia(e.argumentum, g))
            }
            si g.inGenerator {
                redde scriptum("yield §", genExpressia(e.argumentum, g))
            }
            redde scriptum("await §", genExpressia(e.argumentum, g))
        }

        casu ScriptumExpressia ut e {
            redde genScriptum(e.exemplar qua textus, e.argumenta qua lista<Expressia>, g)
        }

        casu LegeExpressia ut e {
            si (e.modus qua textus) == "line" {
                # WHY: Match faber output; Bun needs readline for single-line input.
                redde "(await (async () => { const rl = require(\"readline\").createInterface({ input: process.stdin }); for await (const line of rl) { rl.close(); return line; } return \"\"; })())"
            }
            # WHY: Bun stdin reads all input via text().
            redde "await Bun.stdin.text()"
        }

        casu AbExpressia ut e {
            redde scriptum("§.§", genExpressia(e.fons, g), genExpressia(e.transformatio, g))
        }

        # Collections
        casu SeriesExpressia ut e {
            varia items = [] qua lista<textus>
            ex (e.elementa qua lista<Expressia>) pro elem {
                items.adde(genExpressia(elem, g))
            }
            redde scriptum("[§]", items.coniunge(", "))
        }

        casu ObiectumExpressia ut e {
            redde genObiectum(e.proprietates qua lista<ObiectumProprietas>, g)
        }

        casu DispersioElementum ut e {
            redde scriptum("...§", genExpressia(e.argumentum, g))
        }

        # Lambda
        casu LambdaExpressia ut e {
            varia params = [] qua lista<textus>
            ex (e.parametra qua lista<LambdaParametrum>) pro p {
                si nonnihil p.typus {
                    params.adde(scriptum("§: §", p.nomen, genTypus(p.typus qua TypusAnnotatio, g)))
                } secus {
                    params.adde(p.nomen)
                }
            }
            varia retType = ""
            si nonnihil e.typusReditus {
                retType = scriptum(": §", genTypus(e.typusReditus qua TypusAnnotatio, g))
            }
            redde scriptum("(§)§ => §", params.coniunge(", "), retType, genExpressia(e.corpus, g))
        }

        # Discretio construction
        casu FingeExpressia ut e {
            # finge Click { x: 10 } qua Event -> { tag: 'Click', x: 10 }
            varia props = [] qua lista<textus>
            props.adde(scriptum("tag: '§'", e.variansNomen))
            ex (e.campi qua lista<ObiectumProprietas>) pro campo {
                fixum key = genExpressia(campo.clavis, g)
                fixum val = genExpressia(campo.valor, g)
                props.adde(scriptum("§: §", key, val))
            }
            redde scriptum("{{ § }}", props.coniunge(", "))
        }
    }

    # Fallback - should not reach here
    redde "/* unknown expression */"
}

# =============================================================================
# LITERAL HELPERS
# =============================================================================

# Generate literal value
@ publica
functio genLittera(LitteraGenus species, textus crudus) -> textus {
    si species == LitteraGenus.Verum {
        redde "true"
    }
    si species == LitteraGenus.Falsum {
        redde "false"
    }
    si species == LitteraGenus.Nihil {
        redde "null"
    }
    si species == LitteraGenus.Textus {
        # String literals need quotes - lexer strips them
        redde scriptum("\"§\"", crudus)
    }
    si species == LitteraGenus.Exemplar {
        # Template literals need backticks - lexer strips them
        redde "`" + crudus + "`"
    }
    # Numerus, Fractus pass through raw value
    redde crudus
}

# =============================================================================
# RANGE + BARE EXPRESSIONS
# =============================================================================

@ publica
functio genAmbitusExpressia(Expressia expr, TsGenerator g) -> textus {
    # WHY: Ranges become arrays outside of for-loops.
    discerne expr {
        casu AmbitusExpressia ut e {
            fixum initium = genExpressia(e.initium, g)
            fixum finis = genExpressia(e.finis, g)
            fixum adj = (e.inclusivum qua bivalens) sic " + 1" secus ""

            si nonnihil e.gradus {
                fixum gradus = genExpressia(e.gradus qua Expressia, g)
                si e.inclusivum qua bivalens {
                    redde scriptum("Array.from({length: Math.floor((§ - §) / §) + 1}, (_, i) => § + i * §)", finis, initium, gradus, initium, gradus)
                }
                redde scriptum("Array.from({length: Math.ceil((§ - §) / §)}, (_, i) => § + i * §)", finis, initium, gradus, initium, gradus)
            }

            redde scriptum("Array.from({length: § - §§}, (_, i) => § + i)", finis, initium, adj, initium)
        }
    }

    redde genExpressia(expr, g)
}

@ publica
functio genNudaExpressia(Expressia expr, TsGenerator g) -> textus {
    # WHY: Flatten binary expressions when outer parens are unnecessary.
    discerne expr {
        casu BinariaExpressia ut e {
            fixum sin = genNudaExpressia(e.sinister, g)
            fixum dex = genNudaExpressia(e.dexter, g)
            varia signum = e.signum qua textus
            elige signum {
                casu "et" { signum = "&&" }
                casu "aut" { signum = "||" }
                casu "vel" { signum = "??" }
            }
            redde scriptum("§ § §", sin, signum, dex)
        }
    }

    redde genExpressia(expr, g)
}

# Generate template literal
@ publica
functio genLitteraExemplar(lista<textus> partes, lista<Expressia> expressiae, TsGenerator g) -> textus {
    varia result = "`"
    varia i = 0
    ex partes pro pars {
        result = result + pars
        si i < expressiae.longitudo() {
            result = result + "${" + genExpressia(expressiae[i], g) + "}"
        }
        i += 1
    }
    result = result + "`"
    redde result
}

# =============================================================================
# COMPLEX EXPRESSION HELPERS
# =============================================================================

# Generate est (type check) expression
@ publica
functio genEstExpressia(Expressia expr, TypusAnnotatio scopus, TsGenerator g) -> textus {
    redde genEstExpressiaCum(expr, scopus, g, falsum)
}

functio genEstExpressiaNegata(Expressia expr, TypusAnnotatio scopus, TsGenerator g) -> textus {
    redde genEstExpressiaCum(expr, scopus, g, verum)
}

functio genEstExpressiaCum(Expressia expr, TypusAnnotatio scopus, TsGenerator g, bivalens negatum) -> textus {
    fixum val = genExpressia(expr, g)

    # Primitive type checks use typeof
    si scopus.nomen == "textus" {
        fixum op = negatum sic "!==" secus "==="
        fixum check = scriptum("typeof § § \"string\"", val, op)
        si scopus.nullabilis {
            redde negatum sic scriptum("§ && § !== null", check, val) secus scriptum("§ || § === null", check, val)
        }
        redde check
    }
    si scopus.nomen == "numerus" aut scopus.nomen == "fractus" {
        fixum op = negatum sic "!==" secus "==="
        fixum check = scriptum("typeof § § \"number\"", val, op)
        si scopus.nullabilis {
            redde negatum sic scriptum("§ && § !== null", check, val) secus scriptum("§ || § === null", check, val)
        }
        redde check
    }
    si scopus.nomen == "bivalens" {
        fixum op = negatum sic "!==" secus "==="
        fixum check = scriptum("typeof § § \"boolean\"", val, op)
        si scopus.nullabilis {
            redde negatum sic scriptum("§ && § !== null", check, val) secus scriptum("§ || § === null", check, val)
        }
        redde check
    }
    si scopus.nomen == "nihil" {
        fixum op = negatum sic "!==" secus "==="
        redde scriptum("§ § null", val, op)
    }
    si scopus.nomen == "lista" {
        si negatum {
            redde scriptum("!Array.isArray(§)", val)
        }
        redde scriptum("Array.isArray(§)", val)
    }

    # User-defined types use instanceof
    si negatum {
        redde scriptum("!(§ instanceof §)", val, scopus.nomen)
    }
    redde scriptum("§ instanceof §", val, scopus.nomen)
}

# Generate scriptum (format string) expression
# Recognizes both {} (traditional) and § (section sign, preferred) as placeholders
@ publica
functio genScriptum(textus exemplar, lista<Expressia> argumenta, TsGenerator g) -> textus {
    # WHY: No-arg scriptum should emit a plain string literal (no template).
    si argumenta.longitudo() == 0 {
        varia unescaped = ""
        varia i = 0
        dum i < exemplar.longitudo() {
            fixum c = exemplar[i]
            si c == "{" et i + 1 < exemplar.longitudo() et exemplar[i + 1] == "{" {
                unescaped = unescaped + "{"
                i = i + 2
            } sin c == "}" et i + 1 < exemplar.longitudo() et exemplar[i + 1] == "}" {
                unescaped = unescaped + "}"
                i = i + 2
            } secus {
                unescaped = unescaped + c
                i += 1
            }
        }
        redde scriptum("\"§\"", unescaped)
    }

    # Convert scriptum("Hello, §!", name) or scriptum("Hello, {}!", name) to template literal
    varia result = "`"
    varia argIndex = 0
    varia i = 0

    dum i < exemplar.longitudo() {
        fixum c = exemplar[i]
        si c == "§" {
            # § placeholder (section sign, preferred)
            fixum arg = argIndex < argumenta.longitudo() sic genExpressia(argumenta[argIndex], g) secus "undefined"
            result = result + "${" + arg + "}"
            argIndex += 1
            i += 1
        } sin c == "{" {
            si i + 1 < exemplar.longitudo() et exemplar[i + 1] == "{" {
                # {{ -> literal {
                result = result + "{"
                i = i + 2
            } sin i + 1 < exemplar.longitudo() et exemplar[i + 1] == "}" {
                # {} placeholder (traditional)
                fixum arg = argIndex < argumenta.longitudo() sic genExpressia(argumenta[argIndex], g) secus "undefined"
                result = result + "${" + arg + "}"
                argIndex += 1
                i = i + 2
            } secus {
                # Lone { passes through
                result = result + "{"
                i += 1
            }
        } sin c == "}" {
            si i + 1 < exemplar.longitudo() et exemplar[i + 1] == "}" {
                # }} -> literal }
                result = result + "}"
                i = i + 2
            } secus {
                # Lone } passes through
                result = result + "}"
                i += 1
            }
        } secus {
            result = result + c
            i += 1
        }
    }

    result = result + "`"
    redde result
}

# Generate object literal
@ publica
functio genObiectum(lista<ObiectumProprietas> proprietates, TsGenerator g) -> textus {
    si proprietates.longitudo() == 0 {
        redde "{}"
    }

    varia props = [] qua lista<textus>
    ex proprietates pro prop {
        si prop.dispersum {
            # WHY: Spread properties lower to ...expr in JS object literals.
            props.adde(scriptum("...§", genExpressia(prop.valor, g)))
        } sin prop.brevitas {
            # Shorthand: { name } -> { name }
            props.adde(genExpressia(prop.clavis, g))
        } sin prop.computatum {
            # Computed: { [expr]: value }
            props.adde(scriptum("[§]: §", genExpressia(prop.clavis, g), genExpressia(prop.valor, g)))
        } secus {
            # Normal: { key: value }
            props.adde(scriptum("§: §", genExpressia(prop.clavis, g), genExpressia(prop.valor, g)))
        }
    }

    redde scriptum("{{ § }}", props.coniunge(", "))
}
