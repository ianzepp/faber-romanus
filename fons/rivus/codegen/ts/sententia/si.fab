# TypeScript Statement Generator - Conditional Statements
#
# TRANSFORMS:
#   si x > 0 { ... }            -> if (x > 0) { ... }
#   si x > 0 { ... } secus { }  -> if (x > 0) { ... } else { ... }
#   si x > 0 { } sin y > 0 { }  -> if (x > 0) { } else if (y > 0) { }
#   si ... cape e { }           -> try { if (...) {...} } catch (e) { }

ex "../../../ast/sententia" importa Sententia, CapeClausula
ex "../../../ast/expressia" importa Expressia
ex "../nucleus" importa TsGenerator

# External declarations - implementations live in index.fab
@ externa
functio genExpressia(Expressia expr, TsGenerator g) -> textus

@ externa
functio genSententia(Sententia stmt, TsGenerator g) -> textus

functio genSiCatena(Expressia condicio, Sententia consequens, ignotum alternans, TsGenerator g) -> textus {
    g.intraProfundum()
    fixum consBody = genSententia(consequens, g)
    g.exiProfundum()

    varia result = scriptum("§if (§) {\n§\n§}", g.ind(), genExpressia(condicio, g), consBody, g.ind())

    varia next = alternans
    dum nonnihil next {
        fixum stmt = next qua Sententia

        si stmt.tag == "SiSententia" {
            fixum s = stmt

            # EDGE: `sin` chains never have cape, but nested `si` can.
            si nonnihil s.cape {
                g.intraProfundum()
                fixum elseBody = genSententia(s, g)
                g.exiProfundum()
                result = scriptum("§ else {\n§\n§}", result, elseBody, g.ind())
                next = nihil
                perge
            }

            g.intraProfundum()
            fixum body = genSententia(s.consequens, g)
            g.exiProfundum()

            result = scriptum("§ else if (§) {\n§\n§}", result, genExpressia(s.condicio, g), body, g.ind())
            next = s.alternans
            perge
        }

        g.intraProfundum()
        fixum body = genSententia(stmt, g)
        g.exiProfundum()

        result = scriptum("§ else {\n§\n§}", result, body, g.ind())
        next = nihil
    }

    redde result
}

@ publica
functio genSi(Expressia condicio, Sententia consequens, ignotum alternans, ignotum cape, TsGenerator g) -> textus {
    # WHY: si allows a catch clause, so we wrap the whole chain in try/catch.
    si nonnihil cape {
        fixum c = cape qua CapeClausula
        fixum ifBody = genSiCatena(condicio, consequens, alternans, g)
        redde scriptum("§try {\n§\n§} catch (§) §", g.ind(), ifBody, g.ind(), c.param, genSententia(c.corpus, g))
    }

    redde genSiCatena(condicio, consequens, alternans, g)
}
