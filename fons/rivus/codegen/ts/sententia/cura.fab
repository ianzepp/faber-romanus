# TypeScript Statement Generator - Cura (Resource Management)
#
# Generates try/finally blocks for RAII-style resource cleanup.
#
# TRANSFORMS:
#   cura res = expr { ... }                -> { const res = expr; try { ... } finally { res.solve?.(); } }
#   cura arena res = expr { ... }          -> (block contents only - GC manages memory)
#   cura res = expr { } cape e { }         -> try/catch/finally with resource cleanup
#
# WHY: GC targets (arena/page) skip allocator management - memory is automatic.

ex "../../../ast/sententia" importa Sententia, CuratorGenus, CapeClausula
ex "../../../ast/expressia" importa Expressia
ex "../nucleus" importa TsGenerator

# External declarations - implementations live in index.fab
@ externa
functio genSententia(Sententia stmt, TsGenerator g) -> textus

@ externa
functio genExpressia(Expressia expr, TsGenerator g) -> textus

@ publica
functio genCura(ignotum curatorSpecies, ignotum res, textus vinculum, Sententia corpus, bivalens asynca, ignotum cape, TsGenerator g) -> textus {
    # WHY: For arena/page curator kinds, just emit the block contents.
    # GC targets don't need allocator management - memory is automatic.
    si nonnihil curatorSpecies {
        fixum species = curatorSpecies qua CuratorGenus
        si species == CuratorGenus.Arena aut species == CuratorGenus.Pagina {
            redde genSententia(corpus, g)
        }
    }

    # Generic resource management with try/finally
    varia result = scriptum("§{{\n", g.ind())
    g.intraProfundum()

    # Resource acquisition: const <binding> = [await] <resource>;
    fixum awaitPrefix = asynca sic "await " secus ""
    si nonnihil res {
        result = scriptum("§§const § = §§;\n", result, g.ind(), vinculum, awaitPrefix, genExpressia(res qua Expressia, g))
    } secus {
        result = scriptum("§§const § = undefined;\n", result, g.ind(), vinculum)
    }

    # Try block
    g.intraProfundum()
    fixum tryBody = genSententia(corpus, g)
    g.exiProfundum()
    si tryBody == "" {
        result = scriptum("§§try {}\n", result, g.ind())
    } secus {
        result = scriptum("§§try {\n§\n§}\n", result, g.ind(), tryBody, g.ind())
    }

    # Optional catch clause
    si nonnihil cape {
        fixum capeClause = cape qua CapeClausula
        fixum catchParam = capeClause.param
        g.intraProfundum()
        fixum catchBody = genSententia(capeClause.corpus, g)
        g.exiProfundum()
        result = scriptum("§§catch (§) {\n§\n§}\n", result, g.ind(), catchParam, catchBody, g.ind())
    }

    # Finally block with solve?.()
    result = scriptum("§§finally {\n", result, g.ind())
    g.intraProfundum()
    fixum cleanup = scriptum("§.solve?.();", vinculum)
    result = scriptum("§§§\n", result, g.ind(), cleanup)
    g.exiProfundum()
    result = scriptum("§§}\n", result, g.ind())

    g.exiProfundum()
    result = scriptum("§§}", result, g.ind())

    redde result
}
