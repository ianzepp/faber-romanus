# TypeScript Statement Generator - Class Declarations
#
# Generates TypeScript class declarations with inheritance and visibility.
#
# TRANSFORMS:
#   genus Foo { ... }               -> class Foo { ... }
#   genus Foo<T> { ... }            -> class Foo<T> { ... }
#   genus Foo extendit Bar { ... }  -> class Foo extends Bar { ... }
#   genus Foo implet X, Y { ... }   -> class Foo implements X, Y { ... }
#   @ abstractum genus Foo { ... }  -> abstract class Foo { ... }
#   @ publica genus Foo { ... }     -> export class Foo { ... }
#   campus publicus x: numerus      -> public x: number
#   campus staticus x: numerus      -> static x: number

ex "../../../ast/sententia" importa Sententia, CampusDeclaratio, Visibilitas
ex "../../../ast/expressia" importa Expressia
ex "../../../ast/typus" importa TypusAnnotatio
ex "../nucleus" importa TsGenerator

# External declarations - implementations live in index.fab
ex "../expressia/index" importa genExpressia
ex "./index" importa genSententia
ex "../typus" importa genTypus

@ publica
functio genGenus(textus nomen, ignotum generaParametra, ignotum extendit, ignotum implet, bivalens abstractum, lista<CampusDeclaratio> campi, ignotum structor, lista<Sententia> methodi, ignotum visibilitas, TsGenerator g) -> textus {
    varia result = g.ind()

    # Determine class visibility for field inheritance
    varia classVisibility = Visibilitas.Privata
    si nonnihil visibilitas {
        classVisibility = visibilitas qua Visibilitas
    }

    # Module-level: export when public
    si nonnihil visibilitas {
        fixum vis = visibilitas qua Visibilitas
        si vis == Visibilitas.Publica {
            result = scriptum("§export ", result)
        }
    }

    si abstractum {
        result = scriptum("§abstract ", result)
    }

    result = scriptum("§class §", result, nomen)

    # Generics
    si nonnihil generaParametra {
        fixum gp = generaParametra qua lista<textus>
        si gp.longitudo() > 0 {
            result = scriptum("§<§>", result, gp.coniunge(", "))
        }
    }

    # Extends
    si nonnihil extendit {
        result = scriptum("§ extends §", result, extendit qua textus)
    }

    # Implements
    si nonnihil implet {
        fixum impl = implet qua lista<textus>
        si impl.longitudo() > 0 {
            result = scriptum("§ implements §", result, impl.coniunge(", "))
        }
    }

    result = scriptum("§ {\n", result)
    g.intraProfundum()
    g.inGenere = verum

    # Fields
    ex campi pro campus {
        result = scriptum("§§\n", result, genCampus(campus, classVisibility, g))
    }

    # Split creo method from other methods
    varia creo = nihil qua Sententia?
    varia ceteri = [] innatum lista<Sententia>
    ex methodi pro m {
        varia estCreo = falsum
        discerne m {
            casu FunctioDeclaratio ut f {
                si f.structor {
                    creo = f qua Sententia
                    estCreo = verum
                }
            }
            casu _ { }
        }
        si non estCreo {
            ceteri.adde(m)
        }
    }

    # Constructor (auto-merge)
    result = scriptum("§§\n", result, genAutoMergeConstructor(campi, nonnihil creo, g))

    # Private creo hook
    si nonnihil creo {
        result = scriptum("§§\n", result, genCreoMethod(creo qua Sententia, g))
    }

    # Methods
    ex ceteri pro methodus {
        result = scriptum("§§\n", result, genSententia(methodus, g))
    }

    g.inGenere = falsum
    g.exiProfundum()
    result = scriptum("§§}", result, g.ind())

    redde result
}

functio genAutoMergeConstructor(lista<CampusDeclaratio> campi, bivalens hasCreo, TsGenerator g) -> textus {
    varia lines = [] innatum lista<textus>
    varia instFields = [] innatum lista<CampusDeclaratio>
    ex campi pro campus {
        si non campus.staticum {
            instFields.adde(campus)
        }
    }

    varia props = [] innatum lista<textus>
    ex instFields pro campus {
        props.adde(scriptum("§?: §", campus.nomen, genTypus(campus.typus, g)))
    }
    fixum overridesType = instFields.longitudo() > 0 sic scriptum("{ § }", props.coniunge(", ")) secus "Record<string, never>"

    lines.adde(scriptum("§constructor(overrides: § = {}) {", g.ind(), overridesType))
    g.intraProfundum()

    ex instFields pro campus {
        lines.adde(scriptum("§if (overrides.§ !== undefined) { this.§ = overrides.§; }", g.ind(), campus.nomen, campus.nomen, campus.nomen))
    }
    si hasCreo {
        lines.adde(scriptum("§this.creo();", g.ind()))
    }

    g.exiProfundum()
    lines.adde(scriptum("§}", g.ind()))

    redde lines.coniunge("\n")
}

functio genCreoMethod(Sententia creo, TsGenerator g) -> textus {
    discerne creo {
        casu FunctioDeclaratio ut f {
            varia body = "{}"
            si nonnihil f.corpus {
                g.intraProfundum()
                fixum content = genSententia(f.corpus qua Sententia, g)
                g.exiProfundum()
                body = scriptum("{\n§\n§}", content, g.ind())
            }
            redde scriptum("§private creo() §", g.ind(), body)
        }
        casu _ { }
    }
    redde scriptum("§private creo() {}", g.ind())
}

@ publica
functio genCampus(CampusDeclaratio campus, Visibilitas classVisibility, TsGenerator g) -> textus {
    varia result = g.ind()

    # Determine effective visibility
    # HEURISTIC: For public classes, only emit explicit private/protected modifiers
    # This matches TypeScript's default where public is implicit
    varia effectiveVisibility = campus.visibilitas

    # If class is public and field would be private (default), make it public instead
    # This implements field visibility inheritance from parent class
    si classVisibility == Visibilitas.Publica et campus.visibilitas == Visibilitas.Privata {
        # Fields without explicit visibility in public classes should be public
        effectiveVisibility = Visibilitas.Publica
    }

    # Only emit modifier if private or protected (public is default in TS)
    si effectiveVisibility == Visibilitas.Privata {
        result = scriptum("§private ", result)
    } sin effectiveVisibility == Visibilitas.Protecta {
        result = scriptum("§protected ", result)
    }
    # For public visibility, emit no modifier (public is implicit in TypeScript)

    si campus.staticum {
        result = scriptum("§static ", result)
    }

    result = scriptum("§§: §", result, campus.nomen, genTypus(campus.typus, g))

    si nonnihil campus.valor {
        result = scriptum("§ = §", result, genExpressia(campus.valor, g))
    }

    redde scriptum("§;", result)
}
