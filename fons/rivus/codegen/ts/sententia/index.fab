# TypeScript Statement Generator - Dispatch
#
# Routes statement AST nodes to their specific generators.
#
# WHY: Uses scriptum() for string formatting to avoid method call return type bugs.

ex "../../../ast/sententia" importa Sententia, VariaGenus, ScribeGradus, IteratioGenus, CuratorGenus
ex "../../../ast/sententia" importa Parametrum, CampusDeclaratio, EligeCasus, VariansCasus
ex "../../../ast/sententia" importa CustodiClausula, CapeClausula, OrdoMembrum, VariansDeclaratio
ex "../../../ast/sententia" importa ImportaSpecificator, PactumMethodus, TypusParametrum
ex "../../../ast/sententia" importa SeriesDestructuraElementum
ex "../../../ast/sententia" importa Visibilitas, ProbaModificator, PraeparaTempus, ReddeVerbum
ex "../../../ast/expressia" importa Expressia, LitteraGenus
ex "../../../ast/typus" importa TypusAnnotatio
ex "../nucleus" importa TsGenerator
ex "../typus" importa genTypus
ex "../expressia/index" importa genExpressia
ex "./varia" importa genVaria
ex "./si" importa genSi
ex "./importa" importa genImporta, genDestructura, genSeriesDestructura
ex "./in" importa genIn
ex "./functio" importa genFunctio, genParametrum
ex "./genus" importa genGenus, genCampus
ex "./pactum" importa genPactum
ex "./typealias" importa genTypusAlias
ex "./ordo" importa genOrdo
ex "./discretio" importa genDiscretio
ex "./dum" importa genDum
ex "./iteratio" importa genIteratio
ex "./elige" importa genElige
ex "./discerne" importa genDiscerne
ex "./custodi" importa genCustodi
ex "./tempta" importa genTempta
ex "./iace" importa genIace
ex "./fac" importa genFac
ex "./adfirma" importa genAdfirma
ex "./scribe" importa genScribe
ex "./redde" importa genRedde
ex "./incipit" importa genIncipit, genIncipiet
ex "./cura" importa genCura
ex "./proba" importa genProbandum, genProba, genPraepara

# =============================================================================
# STATEMENT DISPATCH
# =============================================================================

# Generate TypeScript code for a statement
#
# WHY: Wraps statement generation with comment emission. Leading comments
#      appear before the statement, trailing comments on the same line.
#      Currently stubbed (returns empty strings) for bootstrap.
@ publica
functio genSententia(Sententia stmt, TsGenerator g) -> textus {
    fixum leading = g.notaePrae(stmt)
    fixum trailing = g.notaePost(stmt)
    fixum content = genSententiaContent(stmt, g)
    redde scriptum("§§§", leading, content, trailing)
}

# Generate statement content without comments
functio genSententiaContent(Sententia stmt, TsGenerator g) -> textus {
    discerne stmt {
        # Block
        casu MassaSententia ut s {
            redde genMassa(s.corpus qua lista<Sententia>, g)
        }

        # Variable declarations
        casu VariaSententia ut s {
            redde genVaria(s.species qua VariaGenus, s.nomen qua textus, s.typus, s.valor, s.externa qua bivalens, g)
        }

        casu ImportaSententia ut s {
            redde genImporta(s.fons qua textus, s.specificatores qua lista<ImportaSpecificator>, s.totum qua bivalens, s.totumAlias, g)
        }

        casu DestructuraSententia ut s {
            redde genDestructura(s.fons, s.species qua VariaGenus, s.specificatores qua lista<ImportaSpecificator>, g)
        }

        casu SeriesDestructuraSententia ut s {
            redde genSeriesDestructura(s.elementa qua lista<SeriesDestructuraElementum>, s.fons, s.species qua VariaGenus, g)
        }

        # Function declaration
        casu FunctioDeclaratio ut f {
            redde genFunctio(f.nomen qua textus, f.generaParametra, f.parametra qua lista<Parametrum>, f.reddeVerbum, f.typusReditus, f.corpus, f.asynca qua bivalens, f.generator qua bivalens, f.structor qua bivalens, f.visibilitas, f.abstracta qua bivalens, f.externa qua bivalens, g)
        }

        # Type declarations
        casu GenusDeclaratio ut s {
            redde genGenus(s.nomen qua textus, s.generaParametra, s.extendit, s.implet, s.abstractum qua bivalens, s.campi qua lista<CampusDeclaratio>, s.structor, s.methodi qua lista<Sententia>, g)
        }

        casu PactumDeclaratio ut s {
            redde genPactum(s.nomen qua textus, s.generaParametra, s.methodi qua lista<PactumMethodus>, g)
        }

        casu TypusAliasDeclaratio ut s {
            redde genTypusAlias(s.nomen qua textus, s.typus qua TypusAnnotatio, s.scopusNomen, g)
        }

        casu OrdoDeclaratio ut s {
            redde genOrdo(s.nomen qua textus, s.membra qua lista<OrdoMembrum>, g)
        }

        casu DiscretioDeclaratio ut s {
            redde genDiscretio(s.nomen qua textus, s.generaParametra, s.variantes qua lista<VariansDeclaratio>, g)
        }

        # Control flow
        casu SiSententia ut s {
            redde genSi(s.condicio, s.consequens qua Sententia, s.alternans, s.cape, g)
        }

        casu DumSententia ut s {
            redde genDum(s.condicio, s.corpus qua Sententia, s.cape, g)
        }

        casu IteratioSententia ut s {
            redde genIteratio(s.species qua IteratioGenus, s.variabilis qua textus, s.iterabile, s.corpus qua Sententia, s.asynca qua bivalens, s.cape, g)
        }

        casu InSententia ut s {
            redde genIn(s.obiectum, s.corpus qua Sententia, g)
        }

        casu EligeSententia ut s {
            redde genElige(s.discriminans, s.casus qua lista<EligeCasus>, s.praedefinitum, s.cape, g)
        }

        casu DiscerneSententia ut s {
            redde genDiscerne(s.discriminans, s.casus qua lista<VariansCasus>, g)
        }

        casu CustodiSententia ut s {
            redde genCustodi(s.clausulae qua lista<CustodiClausula>, g)
        }

        # Error handling
        casu TemptaSententia ut s {
            redde genTempta(s.corpus qua Sententia, s.cape, s.demum, g)
        }

        casu IaceSententia ut s {
            redde genIace(s.fatale qua bivalens, s.argumentum, g)
        }

        casu FacSententia ut s {
            redde genFac(s.corpus qua Sententia, s.condicio, s.cape, g)
        }

        casu AdfirmaSententia ut s {
            redde genAdfirma(s.condicio, s.nuntius, g)
        }

        # Actions
        casu ScribeSententia ut s {
            redde genScribe(s.gradus qua ScribeGradus, s.argumenta qua lista<Expressia>, g)
        }

        casu ReddeSententia ut s {
            redde genRedde(s.valor, g)
        }

        casu RumpeSententia {
            redde scriptum("§break;", g.ind())
        }

        casu PergeSententia {
            redde scriptum("§continue;", g.ind())
        }

        casu ExpressiaSententia ut s {
            redde scriptum("§§;", g.ind(), genExpressia(s.expressia, g))
        }

        casu IncipitSententia ut s {
            redde genIncipit(s.corpus, s.ergo, g)
        }

        casu IncipietSententia ut s {
            redde genIncipiet(s.corpus, s.ergo, g)
        }

        casu CuraSententia ut s {
            redde genCura(s.curatorSpecies, s.res, s.vinculum qua textus, s.corpus qua Sententia, s.asynca qua bivalens, s.cape, g)
        }

        casu AdSententia {
            redde scriptum("§throw new Error(\"ad statement not implemented\");", g.ind())
        }

        # Tests
        casu ProbandumSententia ut s {
            redde genProbandum(s.nomen qua textus, s.corpus qua lista<Sententia>, g)
        }

        casu ProbaSententia ut s {
            redde genProba(s.nomen qua textus, s.modificator, s.ratioModificatoris, s.corpus qua Sententia, g)
        }

        casu PraeparaMassa ut s {
            redde genPraepara(s.tempus qua PraeparaTempus, s.asynca qua bivalens, s.omnia qua bivalens, s.corpus qua Sententia, g)
        }
    }

    redde scriptum("§/* unknown statement */", g.ind())
}

# =============================================================================
# BLOCK
# =============================================================================

@ publica
functio genMassa(lista<Sententia> corpus, TsGenerator g) -> textus {
    si corpus.longitudo() == 0 {
        # WHY: Empty blocks should not stringify to undefined.
        redde ""
    }
    varia lines = [] innatum lista<textus>
    ex corpus pro stmt {
        lines.adde(genSententia(stmt, g))
    }
    redde lines.coniunge("\n")
}
