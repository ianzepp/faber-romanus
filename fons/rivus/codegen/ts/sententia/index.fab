# TypeScript Statement Generator - Dispatch to statement handlers
#
# Routes statement AST nodes to their specific generators.
# Uses scriptum() for string formatting to avoid method call return type bugs.

ex "../../../ast/sententia" importa Sententia, VariaGenus, ScribeGradus, IteratioGenus, CuratorGenus
ex "../../../ast/sententia" importa Parametrum, CampusDeclaratio, EligeCasus, VariansCasus
ex "../../../ast/sententia" importa CustodiClausula, CapeClausula, OrdoMembrum, VariansDeclaratio
ex "../../../ast/sententia" importa ImportaSpecificator, PactumMethodus, TypusParametrum
ex "../../../ast/sententia" importa SeriesDestructuraElementum
ex "../../../ast/sententia" importa Visibilitas, ProbaModificator, PraeparaTempus, ReddeVerbum
ex "../../../ast/expressia" importa Expressia, LitteraGenus
ex "../../../ast/typus" importa TypusAnnotatio
ex "../nucleus" importa TsGenerator
ex "../typus" importa genTypus
ex "../expressia/index" importa genExpressia

# =============================================================================
# STATEMENT DISPATCH
# =============================================================================

# Generate TypeScript code for a statement
#
# WHY: Wraps statement generation with comment emission. Leading comments
#      appear before the statement, trailing comments on the same line.
#      Currently stubbed (returns empty strings) for bootstrap.
@ publica
functio genSententia(Sententia stmt, TsGenerator g) -> textus {
    fixum leading = g.notaePrae(stmt)
    fixum trailing = g.notaePost(stmt)
    fixum content = genSententiaContent(stmt, g)
    redde scriptum("§§§", leading, content, trailing)
}

# Generate statement content without comments
functio genSententiaContent(Sententia stmt, TsGenerator g) -> textus {
    discerne stmt {
        # Block
        casu MassaSententia ut s {
            redde genMassa(s.corpus qua lista<Sententia>, g)
        }

        # Variable declarations
        casu VariaSententia ut s {
            redde genVaria(s.species qua VariaGenus, s.nomen qua textus, s.typus, s.valor, g)
        }

        casu ImportaSententia ut s {
            redde genImporta(s.fons qua textus, s.specificatores qua lista<ImportaSpecificator>, s.totum qua bivalens, s.totumAlias, g)
        }

        casu DestructuraSententia ut s {
            redde genDestructura(s.fons, s.species qua VariaGenus, s.specificatores qua lista<ImportaSpecificator>, g)
        }

        casu SeriesDestructuraSententia ut s {
            redde genSeriesDestructura(s.elementa qua lista<SeriesDestructuraElementum>, s.fons, s.species qua VariaGenus, g)
        }

        # Function declaration
        casu FunctioDeclaratio ut f {
            redde genFunctio(f.nomen qua textus, f.generaParametra, f.parametra qua lista<Parametrum>, f.reddeVerbum, f.typusReditus, f.corpus, f.asynca qua bivalens, f.generator qua bivalens, f.structor qua bivalens, f.visibilitas, f.abstracta qua bivalens, g)
        }

        # Type declarations
        casu GenusDeclaratio ut s {
            redde genGenus(s.nomen qua textus, s.generaParametra, s.extendit, s.implet, s.abstractum qua bivalens, s.campi qua lista<CampusDeclaratio>, s.structor, s.methodi qua lista<Sententia>, g)
        }

        casu PactumDeclaratio ut s {
            redde genPactum(s.nomen qua textus, s.generaParametra, s.methodi qua lista<PactumMethodus>, g)
        }

        casu TypusAliasDeclaratio ut s {
            redde genTypusAlias(s.nomen qua textus, s.typus qua TypusAnnotatio, s.scopusNomen, g)
        }

        casu OrdoDeclaratio ut s {
            redde genOrdo(s.nomen qua textus, s.membra qua lista<OrdoMembrum>, g)
        }

        casu DiscretioDeclaratio ut s {
            redde genDiscretio(s.nomen qua textus, s.generaParametra, s.variantes qua lista<VariansDeclaratio>, g)
        }

        # Control flow
        casu SiSententia ut s {
            redde genSi(s.condicio, s.consequens qua Sententia, s.alternans, s.cape, g)
        }

        casu DumSententia ut s {
            redde genDum(s.condicio, s.corpus qua Sententia, s.cape, g)
        }

        casu IteratioSententia ut s {
            redde genIteratio(s.species qua IteratioGenus, s.variabilis qua textus, s.iterabile, s.corpus qua Sententia, s.asynca qua bivalens, s.cape, g)
        }

        casu InSententia ut s {
            redde genIn(s.obiectum, s.corpus qua Sententia, g)
        }

        casu EligeSententia ut s {
            redde genElige(s.discriminans, s.casus qua lista<EligeCasus>, s.praedefinitum, s.cape, g)
        }

        casu DiscerneSententia ut s {
            redde genDiscerne(s.discriminans, s.casus qua lista<VariansCasus>, g)
        }

        casu CustodiSententia ut s {
            redde genCustodi(s.clausulae qua lista<CustodiClausula>, g)
        }

        # Error handling
        casu TemptaSententia ut s {
            redde genTempta(s.corpus qua Sententia, s.cape, s.demum, g)
        }

        casu IaceSententia ut s {
            redde genIace(s.fatale qua bivalens, s.argumentum, g)
        }

        casu FacSententia ut s {
            redde genFac(s.corpus qua Sententia, s.condicio, s.cape, g)
        }

        casu AdfirmaSententia ut s {
            redde genAdfirma(s.condicio, s.nuntius, g)
        }

        # Actions
        casu ScribeSententia ut s {
            redde genScribe(s.gradus qua ScribeGradus, s.argumenta qua lista<Expressia>, g)
        }

        casu ReddeSententia ut s {
            redde genRedde(s.valor, g)
        }

        casu RumpeSententia {
            redde scriptum("§break;", g.ind())
        }

        casu PergeSententia {
            redde scriptum("§continue;", g.ind())
        }

        casu ExpressiaSententia ut s {
            redde scriptum("§§;", g.ind(), genExpressia(s.expressia, g))
        }

        casu IncipitSententia ut s {
            redde genIncipit(s.corpus, s.ergo, g)
        }

        casu IncipietSententia ut s {
            redde genIncipiet(s.corpus, s.ergo, g)
        }

        casu CuraSententia ut s {
            redde genCura(s.curatorSpecies, s.res, s.vinculum qua textus, s.corpus qua Sententia, s.asynca qua bivalens, s.cape, g)
        }

        casu AdSententia {
            redde scriptum("§/* ad statement not implemented for TS */", g.ind())
        }

        # Tests
        casu ProbandumSententia ut s {
            redde genProbandum(s.nomen qua textus, s.corpus qua lista<Sententia>, g)
        }

        casu ProbaSententia ut s {
            redde genProba(s.nomen qua textus, s.modificator, s.ratioModificatoris, s.corpus qua Sententia, g)
        }

        casu PraeparaMassa ut s {
            redde genPraepara(s.tempus qua PraeparaTempus, s.asynca qua bivalens, s.omnia qua bivalens, s.corpus qua Sententia, g)
        }
    }

    redde scriptum("§/* unknown statement */", g.ind())
}

# =============================================================================
# BLOCK
# =============================================================================

@ publica
functio genMassa(lista<Sententia> corpus, TsGenerator g) -> textus {
    si corpus.longitudo() == 0 {
        # WHY: Empty blocks should not stringify to undefined.
        redde ""
    }
    varia lines = [] qua lista<textus>
    ex corpus pro stmt {
        lines.adde(genSententia(stmt, g))
    }
    redde lines.coniunge("\n")
}

# =============================================================================
# VARIABLE DECLARATIONS
# =============================================================================

@ publica
functio genVaria(VariaGenus species, textus nomen, ignotum adnotatioTypus, ignotum valor, TsGenerator g) -> textus {
    fixum keyword = species == VariaGenus.Fixum aut species == VariaGenus.Figendum sic "const" secus "let"
    fixum asyncPrefix = species == VariaGenus.Figendum aut species == VariaGenus.Variandum sic "await " secus ""

    varia result = scriptum("§§ §", g.ind(), keyword, nomen)

    si nonnihil adnotatioTypus {
        result = scriptum("§: §", result, genTypus(adnotatioTypus qua TypusAnnotatio, g))
    }

    si nonnihil valor {
        result = scriptum("§ = §§", result, asyncPrefix, genExpressia(valor qua Expressia, g))
    }

    redde scriptum("§;", result)
}

@ publica
functio genImporta(textus fons, lista<ImportaSpecificator> specificatores, bivalens totum, ignotum totumAlias, TsGenerator g) -> textus {
    si totum {
        si nonnihil totumAlias {
            redde scriptum("§import * as § from \"§\";", g.ind(), totumAlias qua textus, fons)
        }
        redde scriptum("§import * from \"§\";", g.ind(), fons)
    }

    varia specs = [] qua lista<textus>
    ex specificatores pro spec {
        si spec.importatum == spec.locale {
            specs.adde(spec.importatum)
        } secus {
            specs.adde(scriptum("§ as §", spec.importatum, spec.locale))
        }
    }

    redde scriptum("§import { § } from \"§\";", g.ind(), specs.coniunge(", "), fons)
}

@ publica
functio genDestructura(Expressia fons, VariaGenus species, lista<ImportaSpecificator> specificatores, TsGenerator g) -> textus {
    fixum keyword = (species == VariaGenus.Fixum aut species == VariaGenus.Figendum) sic "const" secus "let"
    fixum asyncPrefix = (species == VariaGenus.Figendum aut species == VariaGenus.Variandum) sic "await " secus ""

    varia specs = [] qua lista<textus>
    ex specificatores pro spec {
        si spec.residuum {
            specs.adde(scriptum("...§", spec.locale))
        } sin spec.importatum == spec.locale {
            specs.adde(spec.importatum)
        } secus {
            specs.adde(scriptum("§: §", spec.importatum, spec.locale))
        }
    }

    redde scriptum("§§ { § } = §§;", g.ind(), keyword, specs.coniunge(", "), asyncPrefix, genExpressia(fons, g))
}

@ publica
functio genSeriesDestructura(lista<SeriesDestructuraElementum> elementa, Expressia fons, VariaGenus species, TsGenerator g) -> textus {
    fixum keyword = (species == VariaGenus.Fixum aut species == VariaGenus.Figendum) sic "const" secus "let"
    fixum asyncPrefix = (species == VariaGenus.Figendum aut species == VariaGenus.Variandum) sic "await " secus ""

    varia items = [] qua lista<textus>
    ex elementa pro elem {
        si elem.omissum {
            items.adde("")
        } sin elem.residuum {
            items.adde(scriptum("...§", elem.nomen))
        } secus {
            items.adde(elem.nomen)
        }
    }

    redde scriptum("§§ [§] = §§;", g.ind(), keyword, items.coniunge(", "), asyncPrefix, genExpressia(fons, g))
}

# =============================================================================
# IN (MUTATION BLOCK)
# =============================================================================

@ publica
functio genIn(Expressia obiectum, Sententia corpus, TsGenerator g) -> textus {
    discerne corpus {
        casu MassaSententia ut m {
            varia lines = [] qua lista<textus>
            ex m.corpus pro stmt {
                lines.adde(genInSententia(stmt, obiectum, g))
            }
            redde lines.coniunge("\n")
        }
    }
    redde genSententia(corpus, g)
}

functio genInSententia(Sententia stmt, Expressia obiectum, TsGenerator g) -> textus {
    discerne stmt {
        casu ExpressiaSententia ut s {
            fixum expr = genInExpressia(s.expressia, obiectum, g)
            redde scriptum("§§;", g.ind(), expr)
        }
    }
    redde genSententia(stmt, g)
}

functio genInExpressia(Expressia expr, Expressia obiectum, TsGenerator g) -> textus {
    discerne expr {
        casu AssignatioExpressia ut a {
            discerne a.sinister {
                casu Nomen ut n {
                    fixum lhs = scriptum("§.§", genExpressia(obiectum, g), n.valor)
                    redde scriptum("§ § §", lhs, a.signum, genExpressia(a.dexter, g))
                }
            }
        }
    }
    redde genExpressia(expr, g)
}

# =============================================================================
# FUNCTION DECLARATION
# =============================================================================

@ publica
functio genFunctio(textus nomen, ignotum generaParametra, lista<Parametrum> parametra, ignotum reddeVerbum, ignotum typusReditus, ignotum corpus, bivalens asynca, bivalens generator, bivalens structor, ignotum visibilitas, bivalens abstracta, TsGenerator g) -> textus {
    varia result = g.ind()

    # Return type verb flags
    varia useFit = falsum
    varia useFiunt = falsum
    varia useFiet = falsum
    varia useFient = falsum
    si nonnihil reddeVerbum et non structor {
        fixum rv = reddeVerbum qua ReddeVerbum
        useFit = rv == ReddeVerbum.Fit
        useFiunt = rv == ReddeVerbum.Fiunt
        useFiet = rv == ReddeVerbum.Fiet
        useFient = rv == ReddeVerbum.Fient
    }

    varia localAsync = asynca
    varia localGenerator = generator
    si useFit {
        localAsync = falsum
        localGenerator = falsum
    } sin useFiunt {
        localAsync = falsum
        localGenerator = verum
    } sin useFiet {
        localAsync = verum
        localGenerator = falsum
    } sin useFient {
        localAsync = verum
        localGenerator = verum
    }

    # Visibility and abstract modifier (class methods only)
    si g.inClass et non structor {
        si nonnihil visibilitas {
            fixum vis = visibilitas qua Visibilitas
            si vis == Visibilitas.Publica {
                result = scriptum("§public ", result)
            } sin vis == Visibilitas.Protecta {
                result = scriptum("§protected ", result)
            } secus {
                result = scriptum("§private ", result)
            }
        }
        si abstracta {
            result = scriptum("§abstract ", result)
        }
    }

    # Async prefix
    si localAsync {
        result = scriptum("§async ", result)
    }

    # Function keyword (or constructor)
    si structor {
        result = scriptum("§constructor", result)
    } sin g.inClass {
        si localGenerator {
            result = scriptum("§*§", result, nomen)
        } secus {
            result = scriptum("§§", result, nomen)
        }
    } secus {
        si localGenerator {
            result = scriptum("§function* §", result, nomen)
        } secus {
            result = scriptum("§function §", result, nomen)
        }
    }

    # Generic parameters
    si nonnihil generaParametra {
        fixum gp = generaParametra qua lista<TypusParametrum>
        si gp.longitudo() > 0 {
            varia names = [] qua lista<textus>
            ex gp pro p {
                names.adde(p.nomen)
            }
            result = scriptum("§<§>", result, names.coniunge(", "))
        }
    }

    # Parameters
    varia params = [] qua lista<textus>
    ex parametra pro param {
        params.adde(genParametrum(param, g))
    }
    result = scriptum("§(§)", result, params.coniunge(", "))

    si nonnihil typusReditus et non structor {
        fixum base = genTypus(typusReditus qua TypusAnnotatio, g)
        si useFiunt {
            result = scriptum("§: Generator<§>", result, base)
        } sin useFient {
            result = scriptum("§: AsyncGenerator<§>", result, base)
        } sin useFiet {
            result = scriptum("§: Promise<§>", result, base)
        } sin localGenerator {
            # Generator functions wrap yield type in Generator/AsyncGenerator.
            si localAsync {
                result = scriptum("§: AsyncGenerator<§>", result, base)
            } secus {
                result = scriptum("§: Generator<§>", result, base)
            }
        } secus {
            # Async functions return Promise<T>.
            si localAsync {
                result = scriptum("§: Promise<§>", result, base)
            } secus {
                result = scriptum("§: §", result, base)
            }
        }
    }

    # Body
    si abstracta aut corpus == nihil {
        result = scriptum("§;", result)
        redde result
    }

    si nonnihil corpus {
        # Context flags for cede/iace lowering
        fixum prevInGenerator = g.inGenerator
        fixum prevInFlumina = g.inFlumina
        fixum prevInFiunt = g.inFiunt
        fixum prevInFiet = g.inFiet
        fixum prevInFient = g.inFient
        fixum prevTabula = g.tabulaNominata

        varia localTabula = [] qua lista<textus>
        ex parametra pro param {
            si nonnihil param.typus {
                fixum typus = param.typus qua TypusAnnotatio
                si typus.nomen == "tabula" {
                    localTabula.adde(param.nomen)
                }
            }
        }

        g.inGenerator = localGenerator
        g.tabulaNominata = localTabula

        si nonnihil reddeVerbum {
            g.inFlumina = useFit aut useFiet
            g.inFiet = useFiet
            g.inFiunt = useFiunt
            g.inFient = useFient
            si g.inFlumina aut g.inFiet aut g.inFiunt aut g.inFient {
                g.features.flumina = verum
            }
        }

        g.intraProfundum()
        varia body = genSententia(corpus qua Sententia, g)

        # fiunt/fient always end with done()
        si g.inFiunt aut g.inFient {
            si body != "" {
                body = scriptum("§\n§yield respond.done();", body, g.ind())
            } secus {
                body = scriptum("§yield respond.done();", g.ind())
            }
        }

        g.exiProfundum()

        g.inGenerator = prevInGenerator
        g.inFlumina = prevInFlumina
        g.inFiunt = prevInFiunt
        g.inFiet = prevInFiet
        g.inFient = prevInFient
        g.tabulaNominata = prevTabula

        si useFit {
            fixum ind = g.ind()
            result = scriptum("§ {\n§  return asFit(function* () {\n§\n§  });\n§}", result, ind, body, ind, ind)
        } sin useFiunt {
            fixum ind = g.ind()
            result = scriptum("§ {\n§  yield* asFiunt((function* () {\n§\n§  })());\n§}", result, ind, body, ind, ind)
        } sin useFiet {
            fixum ind = g.ind()
            result = scriptum("§ {\n§  return await asFiet(async function* () {\n§\n§  });\n§}", result, ind, body, ind, ind)
        } sin useFient {
            fixum ind = g.ind()
            result = scriptum("§ {\n§  yield* asFient((async function* () {\n§\n§  })());\n§}", result, ind, body, ind, ind)
        } sin body == "" {
            result = scriptum("§ {{}}", result)
        } secus {
            result = scriptum("§ {\n§\n§}", result, body, g.ind())
        }
    }

    redde result
}

@ publica
functio genParametrum(Parametrum param, TsGenerator g) -> textus {
    varia result = ""

    si param.residuum {
        result = "..."
    }

    # Use alias if present
    si nonnihil param.alias {
        result = scriptum("§§", result, param.alias qua textus)
    } secus {
        result = scriptum("§§", result, param.nomen)
    }

    # Optional marker (TypeScript `?:`), only if no default.
    si param.optionalis et nihil param.praedefinitum et non param.residuum {
        result = scriptum("§?", result)
    }

    # Type
    si nonnihil param.typus {
        result = scriptum("§: §", result, genTypus(param.typus qua TypusAnnotatio, g))
    }

    # Default value
    si nonnihil param.praedefinitum {
        result = scriptum("§ = §", result, genExpressia(param.praedefinitum, g))
    }

    redde result
}

# =============================================================================
# TYPE DECLARATIONS
# =============================================================================

@ publica
functio genGenus(textus nomen, ignotum generaParametra, ignotum extendit, ignotum implet, bivalens abstractum, lista<CampusDeclaratio> campi, ignotum structor, lista<Sententia> methodi, TsGenerator g) -> textus {
    varia result = g.ind()

    si abstractum {
        result = scriptum("§abstract ", result)
    }

    result = scriptum("§class §", result, nomen)

    # Generics
    si nonnihil generaParametra {
        fixum gp = generaParametra qua lista<textus>
        si gp.longitudo() > 0 {
            result = scriptum("§<§>", result, gp.coniunge(", "))
        }
    }

    # Extends
    si nonnihil extendit {
        result = scriptum("§ extends §", result, extendit qua textus)
    }

    # Implements
    si nonnihil implet {
        fixum impl = implet qua lista<textus>
        si impl.longitudo() > 0 {
            result = scriptum("§ implements §", result, impl.coniunge(", "))
        }
    }

    result = scriptum("§ {{\n", result)
    g.intraProfundum()
    g.inClass = verum

    # Fields
    ex campi pro campus {
        result = scriptum("§§\n", result, genCampus(campus, g))
    }

    # Split creo method from other methods
    varia creo = nihil qua Sententia?
    varia ceteri = [] qua lista<Sententia>
    ex methodi pro m {
        varia estCreo = falsum
        discerne m {
            casu FunctioDeclaratio ut f {
                si f.structor {
                    creo = f qua Sententia
                    estCreo = verum
                }
            }
        }
        si non estCreo {
            ceteri.adde(m)
        }
    }

    # Constructor (auto-merge)
    result = scriptum("§§\n", result, genAutoMergeConstructor(campi, nonnihil creo, g))

    # Private creo hook
    si nonnihil creo {
        result = scriptum("§§\n", result, genCreoMethod(creo qua Sententia, g))
    }

    # Methods
    ex ceteri pro methodus {
        result = scriptum("§§\n", result, genSententia(methodus, g))
    }

    g.inClass = falsum
    g.exiProfundum()
    result = scriptum("§§}}", result, g.ind())

    redde result
}

functio genAutoMergeConstructor(lista<CampusDeclaratio> campi, bivalens hasCreo, TsGenerator g) -> textus {
    varia lines = [] qua lista<textus>
    varia instFields = [] qua lista<CampusDeclaratio>
    ex campi pro campus {
        si non campus.staticum {
            instFields.adde(campus)
        }
    }

    varia props = [] qua lista<textus>
    ex instFields pro campus {
        props.adde(scriptum("§?: §", campus.nomen, genTypus(campus.typus, g)))
    }
    fixum overridesType = instFields.longitudo() > 0 sic scriptum("{ § }", props.coniunge(", ")) secus "Record<string, never>"

    lines.adde(scriptum("§constructor(overrides: § = {}) {", g.ind(), overridesType))
    g.intraProfundum()

    ex instFields pro campus {
        lines.adde(scriptum("§if (overrides.§ !== undefined) { this.§ = overrides.§; }", g.ind(), campus.nomen, campus.nomen, campus.nomen))
    }
    si hasCreo {
        lines.adde(scriptum("§this.creo();", g.ind()))
    }

    g.exiProfundum()
    lines.adde(scriptum("§}", g.ind()))

    redde lines.coniunge("\n")
}

functio genCreoMethod(Sententia creo, TsGenerator g) -> textus {
    discerne creo {
        casu FunctioDeclaratio ut f {
            varia body = "{}"
            si nonnihil f.corpus {
                g.intraProfundum()
                fixum content = genSententia(f.corpus qua Sententia, g)
                g.exiProfundum()
                body = scriptum("{\n§\n§}", content, g.ind())
            }
            redde scriptum("§private creo() §", g.ind(), body)
        }
    }
    redde scriptum("§private creo() {}", g.ind())
}

@ publica
functio genCampus(CampusDeclaratio campus, TsGenerator g) -> textus {
    varia result = g.ind()

    # Visibility
    si campus.visibilitas == Visibilitas.Publica {
        result = scriptum("§public ", result)
    } sin campus.visibilitas == Visibilitas.Protecta {
        result = scriptum("§protected ", result)
    } secus {
        result = scriptum("§private ", result)
    }

    si campus.staticum {
        result = scriptum("§static ", result)
    }

    result = scriptum("§§: §", result, campus.nomen, genTypus(campus.typus, g))

    si nonnihil campus.valor {
        result = scriptum("§ = §", result, genExpressia(campus.valor, g))
    }

    redde scriptum("§;", result)
}

@ publica
functio genPactum(textus nomen, ignotum generaParametra, lista<PactumMethodus> methodi, TsGenerator g) -> textus {
    varia result = scriptum("§interface §", g.ind(), nomen)

    si nonnihil generaParametra {
        fixum gp = generaParametra qua lista<textus>
        si gp.longitudo() > 0 {
            result = scriptum("§<§>", result, gp.coniunge(", "))
        }
    }

    result = scriptum("§ {{\n", result)
    g.intraProfundum()

    ex methodi pro methodus {
        varia params = [] qua lista<textus>
        ex methodus.parametra pro param {
            params.adde(genParametrum(param, g))
        }

        varia line = scriptum("§§(§)", g.ind(), methodus.nomen, params.coniunge(", "))
        varia reditus = ""
        si nonnihil methodus.typusReditus {
            reditus = genTypus(methodus.typusReditus qua TypusAnnotatio, g)
        }

        si reditus == "" et (methodus.generator aut methodus.asynca) {
            reditus = "void"
        }

        si methodus.generator {
            reditus = methodus.asynca sic scriptum("AsyncGenerator<§>", reditus) secus scriptum("Generator<§>", reditus)
        } sin methodus.asynca {
            reditus = scriptum("Promise<§>", reditus)
        }

        si reditus != "" {
            line = scriptum("§: §", line, reditus)
        }

        result = scriptum("§§;\n", result, line)
    }

    g.exiProfundum()
    result = scriptum("§§}}", result, g.ind())

    redde result
}

@ publica
functio genTypusAlias(textus nomen, TypusAnnotatio adnotatioTypus, ignotum scopusNomen, TsGenerator g) -> textus {
    si nonnihil scopusNomen {
        redde scriptum("§type § = typeof §;", g.ind(), nomen, scopusNomen qua textus)
    }
    redde scriptum("§type § = §;", g.ind(), nomen, genTypus(adnotatioTypus, g))
}

@ publica
functio genOrdo(textus nomen, lista<OrdoMembrum> membra, TsGenerator g) -> textus {
    varia result = scriptum("§enum § {\n", g.ind(), nomen)
    g.intraProfundum()

    # If no member has an explicit value, keep them on one line.
    varia habetValores = falsum
    ex membra pro membrum {
        si nonnihil membrum.valor {
            habetValores = verum
        }
    }

    si non habetValores {
        varia nomina = [] qua lista<textus>
        ex membra pro membrum {
            nomina.adde(membrum.nomen)
        }
        result = scriptum("§§§\n", result, g.ind(), nomina.coniunge(", "))
        g.exiProfundum()
        result = scriptum("§§}", result, g.ind())
        redde result
    }

    ex membra pro membrum {
        si nonnihil membrum.valor {
            result = scriptum("§§§ = §,\n", result, g.ind(), membrum.nomen, membrum.valor qua textus)
        } secus {
            result = scriptum("§§§,\n", result, g.ind(), membrum.nomen)
        }
    }

    g.exiProfundum()
    result = scriptum("§§}", result, g.ind())

    redde result
}

@ publica
functio genDiscretio(textus nomen, ignotum generaParametra, lista<VariansDeclaratio> variantes, TsGenerator g) -> textus {
    # TS: prefer inline union members so tests can match exact fragments.

    varia params = ""
    si nonnihil generaParametra {
        fixum p = generaParametra qua lista<textus>
        params = scriptum("<§>", p.coniunge(", "))
    }

    varia variants = [] qua lista<textus>
    ex variantes pro varians {
        varia member = scriptum("{ tag: '§'", varians.nomen)
        ex varians.campi pro campus {
            member = scriptum("§; §: §", member, campus.nomen, genTypus(campus.typus, g))
        }
        member = scriptum("§ }", member)
        variants.adde(member)
    }

    redde scriptum("§type §§ = §;", g.ind(), nomen, params, variants.coniunge(" | "))
}

# =============================================================================
# CONTROL FLOW
# =============================================================================

functio genSiCatena(Expressia condicio, Sententia consequens, ignotum alternans, TsGenerator g) -> textus {
    g.intraProfundum()
    fixum consBody = genSententia(consequens, g)
    g.exiProfundum()

    varia result = scriptum("§if (§) {\n§\n§}", g.ind(), genExpressia(condicio, g), consBody, g.ind())

    varia next = alternans
    dum nonnihil next {
        fixum stmt = next qua Sententia

        si stmt.tag == "SiSententia" {
            fixum s = stmt

            # EDGE: `sin` chains never have cape, but nested `si` can.
            si nonnihil s.cape {
                g.intraProfundum()
                fixum elseBody = genSententia(s, g)
                g.exiProfundum()
                result = scriptum("§ else {\n§\n§}", result, elseBody, g.ind())
                next = nihil
                perge
            }

            g.intraProfundum()
            fixum body = genSententia(s.consequens, g)
            g.exiProfundum()

            result = scriptum("§ else if (§) {\n§\n§}", result, genExpressia(s.condicio, g), body, g.ind())
            next = s.alternans
            perge
        }

        g.intraProfundum()
        fixum body = genSententia(stmt, g)
        g.exiProfundum()

        result = scriptum("§ else {\n§\n§}", result, body, g.ind())
        next = nihil
    }

    redde result
}

@ publica
functio genSi(Expressia condicio, Sententia consequens, ignotum alternans, ignotum cape, TsGenerator g) -> textus {
    # WHY: si allows a catch clause, so we wrap the whole chain in try/catch.
    si nonnihil cape {
        fixum c = cape qua CapeClausula
        fixum ifBody = genSiCatena(condicio, consequens, alternans, g)
        redde scriptum("§try {\n§\n§} catch (§) §", g.ind(), ifBody, g.ind(), c.param, genSententia(c.corpus, g))
    }

    redde genSiCatena(condicio, consequens, alternans, g)
}

@ publica
functio genDum(Expressia condicio, Sententia corpus, ignotum cape, TsGenerator g) -> textus {
    g.intraProfundum()
    fixum body = genSententia(corpus, g)
    g.exiProfundum()

    fixum loop = scriptum("§while (§) {{\n§\n§}}", g.ind(), genExpressia(condicio, g), body, g.ind())

    # WHY: dum allows cape; wrap the loop in try/catch.
    si nonnihil cape {
        fixum c = cape qua CapeClausula
        redde scriptum("§try {{\n§\n§}} catch (§) §", g.ind(), loop, g.ind(), c.param, genSententia(c.corpus, g))
    }

    redde loop
}

@ publica
functio genIteratio(IteratioGenus species, textus variabilis, Expressia iterabile, Sententia corpus, bivalens asynca, ignotum cape, TsGenerator g) -> textus {
    fixum keyword = species == IteratioGenus.De sic "in" secus "of"
    fixum asyncPrefix = asynca sic "await " secus ""

    g.intraProfundum()
    fixum body = genSententia(corpus, g)
    g.exiProfundum()

    # WHY: Ranges become traditional for loops for efficiency.
    discerne iterabile {
        casu AmbitusExpressia ut a {
            fixum initium = genExpressia(a.initium, g)
            fixum finis = genExpressia(a.finis, g)
            fixum op = (a.inclusivum qua bivalens) sic "<=" secus "<"

            varia incrementum = scriptum("§++", variabilis)
            si nonnihil a.gradus {
                incrementum = scriptum("§ += §", variabilis, genExpressia(a.gradus qua Expressia, g))
            }

            fixum header = scriptum("for §(let § = §; § § §; §)", asyncPrefix, variabilis, initium, variabilis, op, finis, incrementum)
            fixum loop = scriptum("§§ {{\n§\n§}}", g.ind(), header, body, g.ind())

            si nonnihil cape {
                fixum c = cape qua CapeClausula
                redde scriptum("§try {{\n§\n§}} catch (§) §", g.ind(), loop, g.ind(), c.param, genSententia(c.corpus, g))
            }

            redde loop
        }
    }

    fixum loop = scriptum("§for §(const § § §) {{\n§\n§}}", g.ind(), asyncPrefix, variabilis, keyword, genExpressia(iterabile, g), body, g.ind())

    si nonnihil cape {
        fixum c = cape qua CapeClausula
        redde scriptum("§try {{\n§\n§}} catch (§) §", g.ind(), loop, g.ind(), c.param, genSententia(c.corpus, g))
    }

    redde loop
}

@ publica
functio genElige(Expressia discriminans, lista<EligeCasus> casus, ignotum praedefinitum, ignotum cape, TsGenerator g) -> textus {
    fixum disc = genExpressia(discriminans, g)
    varia wrapTry = nonnihil cape
    si wrapTry {
        g.intraProfundum()
    }
    varia result = ""
    varia primus = verum

    ex casus pro c {
        fixum cond = genExpressia(c.condicio, g)
        si primus {
            result = scriptum("§if (§ === §) {\n", g.ind(), disc, cond)
            primus = falsum
        } secus {
            result = scriptum("§§else if (§ === §) {\n", result, g.ind(), disc, cond)
        }

        g.intraProfundum()
        fixum body = genSententia(c.consequens, g)
        g.exiProfundum()
        si body != "" {
            result = scriptum("§§\n", result, body)
        }
        result = scriptum("§§}\n", result, g.ind())
    }

    si nonnihil praedefinitum {
        result = scriptum("§§else {\n", result, g.ind())
        g.intraProfundum()
        fixum defBody = genSententia(praedefinitum qua Sententia, g)
        g.exiProfundum()
        si defBody != "" {
            result = scriptum("§§\n", result, defBody)
        }
        result = scriptum("§§}\n", result, g.ind())
    }

    si wrapTry {
        g.exiProfundum()
    }

    si nonnihil cape {
        fixum c = cape qua CapeClausula
        g.intraProfundum()
        fixum catchBody = genSententia(c.corpus, g)
        g.exiProfundum()
        redde scriptum("§try {\n§\n§} catch (§) {\n§\n§}", g.ind(), result, g.ind(), c.param, catchBody, g.ind())
    }

    redde result
}

@ publica
functio genDiscerne(Expressia discriminans, lista<VariansCasus> casus, TsGenerator g) -> textus {
    fixum disc = genExpressia(discriminans, g)
    varia result = scriptum("§// discerne §\n", g.ind(), disc)

    varia first = verum
    ex casus pro c {
        si first {
            result = scriptum("§§if (§.tag === '§') {{\n", result, g.ind(), disc, c.variansNomen)
            first = falsum
        } secus {
            result = scriptum("§§else if (§.tag === '§') {{\n", result, g.ind(), disc, c.variansNomen)
        }

        g.intraProfundum()

        # Bind alias or fields
        si nonnihil c.alias {
            # WHY: 'ut' binds the whole variant for access via alias.
            result = scriptum("§§const § = §;\n", result, g.ind(), c.alias, disc)
        } sin c.vincula.longitudo() > 0 {
            result = scriptum("§§const {{ § }} = §;\n", result, g.ind(), c.vincula.coniunge(", "), disc)
        }

        result = scriptum("§§\n", result, genSententia(c.consequens, g))
        g.exiProfundum()
        result = scriptum("§§}}\n", result, g.ind())
    }

    redde result
}

@ publica
functio genCustodi(lista<CustodiClausula> clausulae, TsGenerator g) -> textus {
    varia result = ""
    ex clausulae pro clausula {
        varia vacuus = falsum
        discerne clausula.consequens {
            casu MassaSententia ut m {
                si m.corpus.longitudo() == 0 {
                    vacuus = verum
                }
            }
        }

        si vacuus {
            # WHY: Empty guard bodies should compact to {} with no blank line.
            # WHY: Use {{}} so scriptum emits literal braces with no placeholder.
            result = scriptum("§§if (§) {{}}\n", result, g.ind(), genExpressia(clausula.condicio, g))
            perge
        }

        g.intraProfundum()
        varia body = "" qua textus
        discerne clausula.consequens {
            casu MassaSententia ut m {
                body = genMassa(m.corpus, g)
            }
        }
        si body == "" {
            body = genSententia(clausula.consequens, g)
        }
        si body == "" aut body == nihil aut body == "undefined" {
            # WHY: Defensive fallback if empty bodies stringify poorly.
            # WHY: Use {{}} so scriptum emits literal braces with no placeholder.
            result = scriptum("§§if (§) {{}}\n", result, g.ind(), genExpressia(clausula.condicio, g))
            g.exiProfundum()
            perge
        }
        g.exiProfundum()
        result = scriptum("§§if (§) {{\n§\n§}}\n", result, g.ind(), genExpressia(clausula.condicio, g), body, g.ind())
    }
    redde result
}

# =============================================================================
# ERROR HANDLING
# =============================================================================

@ publica
functio genTempta(Sententia corpus, ignotum cape, ignotum demum, TsGenerator g) -> textus {
    g.intraProfundum()
    fixum tryBody = genSententia(corpus, g)
    g.exiProfundum()

    varia result = ""
    si tryBody == "" {
        result = scriptum("§try {{}}", g.ind())
    } secus {
        result = scriptum("§try {{\n§\n§}}", g.ind(), tryBody, g.ind())
    }

    si nonnihil cape {
        fixum capeClausula = cape qua CapeClausula
        g.intraProfundum()
        fixum catchBody = genSententia(capeClausula.corpus, g)
        g.exiProfundum()
        si catchBody == "" {
            result = scriptum("§ catch (§) {{}}", result, capeClausula.param)
        } secus {
            result = scriptum("§ catch (§) {{\n§\n§}}", result, capeClausula.param, catchBody, g.ind())
        }
    }

    si nonnihil demum {
        g.intraProfundum()
        fixum finallyBody = genSententia(demum qua Sententia, g)
        g.exiProfundum()
        si finallyBody == "" {
            result = scriptum("§ finally {{}}", result)
        } secus {
            result = scriptum("§ finally {{\n§\n§}}", result, finallyBody, g.ind())
        }
    }

    redde result
}

@ publica
functio genIace(bivalens fatale, Expressia argumentum, TsGenerator g) -> textus {
    fixum expr = genExpressia(argumentum, g)

    si fatale {
        # WHY: mori is fatal - use Panic and string coercion for non-literals.
        g.features.panic = verum
        discerne argumentum {
            casu Littera ut lit {
                si lit.species == LitteraGenus.Textus {
                    redde scriptum("§throw new Panic(§);", g.ind(), expr)
                }
            }
        }
        redde scriptum("§throw new Panic(String(§));", g.ind(), expr)
    }

    # WHY: In flumina mode, iace yields an error response and exits.
    si g.inFlumina aut g.inFiunt aut g.inFiet aut g.inFient {
        varia message = scriptum("String(§)", expr)
        discerne argumentum {
            casu Littera ut lit {
                si lit.species == LitteraGenus.Textus {
                    message = expr
                }
            }
        }
        redde scriptum("§yield respond.error(\"EFAIL\", §);\n§return;", g.ind(), message, g.ind())
    }

    redde scriptum("§throw §;", g.ind(), expr)
}

@ publica
functio genFac(Sententia corpus, ignotum condicio, ignotum cape, TsGenerator g) -> textus {
    g.intraProfundum()
    fixum body = genSententia(corpus, g)
    g.exiProfundum()

    si nonnihil condicio {
        fixum test = genExpressia(condicio qua Expressia, g)
        fixum loop = scriptum("§do {{\n§\n§}} while (§);", g.ind(), body, g.ind(), test)

        si nonnihil cape {
            fixum c = cape qua CapeClausula
            g.intraProfundum()
            fixum catchBody = genSententia(c.corpus, g)
            g.exiProfundum()
            redde scriptum("§try {\n§\n§} catch (§) {\n§\n§}", g.ind(), loop, g.ind(), c.param, catchBody, g.ind())
        }

        redde loop
    }

    si nonnihil cape {
        fixum c = cape qua CapeClausula
        g.intraProfundum()
        fixum catchBody = genSententia(c.corpus, g)
        g.exiProfundum()
        redde scriptum("§try {\n§\n§} catch (§) {\n§\n§}", g.ind(), body, g.ind(), c.param, catchBody, g.ind())
    }

    # Plain block
    redde scriptum("§{{\n§\n§}}", g.ind(), body, g.ind())
}

@ publica
functio genAdfirma(Expressia condicio, ignotum nuntius, TsGenerator g) -> textus {
    fixum test = genExpressia(condicio, g)

    varia nuntiusTextus = ""
    si nonnihil nuntius {
        nuntiusTextus = genExpressia(nuntius qua Expressia, g)
    } secus {
        # WHY: Auto-generate assertion message from expression.
        nuntiusTextus = scriptum("\"Assertion failed: §\"", test.replace("\"", "\\\""))
    }

    redde scriptum("§if (!(§)) { throw new Error(§); }", g.ind(), test, nuntiusTextus)
}

# =============================================================================
# ACTIONS
# =============================================================================

@ publica
functio genScribe(ScribeGradus gradus, lista<Expressia> argumenta, TsGenerator g) -> textus {
    varia args = [] qua lista<textus>
    ex argumenta pro arg {
        args.adde(genExpressia(arg, g))
    }

    varia method = "log"
    si gradus == ScribeGradus.Vide {
        method = "debug"
    } sin gradus == ScribeGradus.Mone {
        method = "warn"
    }

    redde scriptum("§console.§(§);", g.ind(), method, args.coniunge(", "))
}

@ publica
functio genRedde(ignotum valor, TsGenerator g) -> textus {
    si g.inFlumina {
        fixum data = nonnihil valor sic genExpressia(valor qua Expressia, g) secus "undefined"
        redde scriptum("§yield respond.ok(§);", g.ind(), data)
    }
    si nonnihil valor {
        redde scriptum("§return §;", g.ind(), genExpressia(valor qua Expressia, g))
    }
    redde scriptum("§return;", g.ind())
}

# =============================================================================
# ENTRY POINTS
# =============================================================================

@ publica
functio genIncipit(ignotum corpus, ignotum ergo, TsGenerator g) -> textus {
    si nonnihil corpus {
        varia result = genSententia(corpus qua Sententia, g)
        si nonnihil ergo {
            result = scriptum("§\n§", result, genSententia(ergo qua Sententia, g))
        }
        redde result
    }
    si nonnihil ergo {
        redde genSententia(ergo qua Sententia, g)
    }
    redde ""
}

@ publica
functio genIncipiet(ignotum corpus, ignotum ergo, TsGenerator g) -> textus {
    g.intraProfundum()
    varia body = ""
    si nonnihil corpus {
        body = genSententia(corpus qua Sententia, g)
    }
    g.exiProfundum()

    varia result = scriptum("§(async () => {{\n§\n§}})();", g.ind(), body, g.ind())

    si nonnihil ergo {
        result = scriptum("§\n§", result, genSententia(ergo qua Sententia, g))
    }

    redde result
}

@ publica
functio genCura(ignotum curatorSpecies, ignotum res, textus vinculum, Sententia corpus, bivalens asynca, ignotum cape, TsGenerator g) -> textus {
    # WHY: For arena/page curator kinds, just emit the block contents.
    # GC targets don't need allocator management - memory is automatic.
    si nonnihil curatorSpecies {
        fixum species = curatorSpecies qua CuratorGenus
        si species == CuratorGenus.Arena aut species == CuratorGenus.Pagina {
            redde genSententia(corpus, g)
        }
    }

    # Generic resource management with try/finally
    varia result = scriptum("§{{\n", g.ind())
    g.intraProfundum()

    # Resource acquisition: const <binding> = [await] <resource>;
    fixum awaitPrefix = asynca sic "await " secus ""
    si nonnihil res {
        result = scriptum("§§const § = §§;\n", result, g.ind(), vinculum, awaitPrefix, genExpressia(res qua Expressia, g))
    } secus {
        result = scriptum("§§const § = undefined;\n", result, g.ind(), vinculum)
    }

    # Try block
    g.intraProfundum()
    fixum tryBody = genSententia(corpus, g)
    g.exiProfundum()
    si tryBody == "" {
        result = scriptum("§§try {{}}\n", result, g.ind())
    } secus {
        result = scriptum("§§try {{\n§\n§}}\n", result, g.ind(), tryBody, g.ind())
    }

    # Optional catch clause
    si nonnihil cape {
        fixum capeClause = cape qua CapeClausula
        fixum catchParam = capeClause.param
        g.intraProfundum()
        fixum catchBody = genSententia(capeClause.corpus, g)
        g.exiProfundum()
        result = scriptum("§§catch (§) {{\n§\n§}}\n", result, g.ind(), catchParam, catchBody, g.ind())
    }

    # Finally block with solve?.()
    result = scriptum("§§finally {{\n", result, g.ind())
    g.intraProfundum()
    fixum cleanup = scriptum("§.solve?.();", vinculum)
    result = scriptum("§§§\n", result, g.ind(), cleanup)
    g.exiProfundum()
    result = scriptum("§§}}\n", result, g.ind())

    g.exiProfundum()
    result = scriptum("§§}}", result, g.ind())

    redde result
}

# =============================================================================
# TESTS
# =============================================================================

@ publica
functio genProbandum(textus nomen, lista<Sententia> corpus, TsGenerator g) -> textus {
    varia lines = [] qua lista<textus>
    lines.adde(scriptum("§describe(\"§\", () => {{", g.ind(), nomen))

    g.intraProfundum()
    ex corpus pro stmt {
        lines.adde(genSententia(stmt, g))
    }
    g.exiProfundum()

    lines.adde(scriptum("§});", g.ind()))
    redde lines.coniunge("\n")
}

@ publica
functio genProba(textus nomen, ignotum modificator, textus? ratioModificatoris, Sententia corpus, TsGenerator g) -> textus {
    varia ratio = ""
    si nonnihil ratioModificatoris {
        ratio = scriptum("§: ", ratioModificatoris)
    }

    si nonnihil modificator {
        fixum mod = modificator qua ProbaModificator
        fixum titulus = scriptum("§§", ratio, nomen)

        si mod == ProbaModificator.Omitte {
            g.intraProfundum()
            fixum body = genSententia(corpus, g)
            g.exiProfundum()
            redde scriptum("§test.skip(\"§\", () => {{\n§\n§}});", g.ind(), titulus, body, g.ind())
        }
        si mod == ProbaModificator.Futurum {
            redde scriptum("§test.todo(\"§\");", g.ind(), titulus)
        }
    }

    g.intraProfundum()
    fixum body = genSententia(corpus, g)
    g.exiProfundum()

    redde scriptum("§test(\"§\", () => {{\n§\n§}});", g.ind(), nomen, body, g.ind())
}

@ publica
functio genPraepara(PraeparaTempus tempus, bivalens asynca, bivalens omnia, Sententia corpus, TsGenerator g) -> textus {
    varia hook = "beforeEach"
    si tempus == PraeparaTempus.Praepara {
        si omnia {
            hook = "beforeAll"
        } secus {
            hook = "beforeEach"
        }
    } secus {
        si omnia {
            hook = "afterAll"
        } secus {
            hook = "afterEach"
        }
    }

    fixum asyncPrefix = asynca sic "async " secus ""

    g.intraProfundum()
    fixum body = genSententia(corpus, g)
    g.exiProfundum()

    redde scriptum("§§(§() => {{\n§\n§}});", g.ind(), hook, asyncPrefix, body, g.ind())
}
