# TypeScript Statement Generator - Dispatch to statement handlers
#
# Routes statement AST nodes to their specific generators.
# Uses scriptum() for string formatting to avoid method call return type bugs.

ex "../../../ast/sententia" importa Sententia, VariaGenus, ScribeGradus, IteratioGenus
ex "../../../ast/sententia" importa Parametrum, CampusDeclaratio, EligeCasus, VariansCasus
ex "../../../ast/sententia" importa CustodiClausula, CapeClausula, OrdoMembrum, VariansDeclaratio
ex "../../../ast/sententia" importa ImportaSpecificator, PactumMethodus, TypusParametrum
ex "../../../ast/sententia" importa Visibilitas, ProbaModificator, PraeparaTempus
ex "../../../ast/expressia" importa Expressia
ex "../../../ast/typus" importa TypusAnnotatio
ex "../nucleus" importa TsGenerator
ex "../typus" importa genTypus
ex "../expressia/index" importa genExpressia

# =============================================================================
# STATEMENT DISPATCH
# =============================================================================

# Generate TypeScript code for a statement
#
# WHY: Wraps statement generation with comment emission. Leading comments
#      appear before the statement, trailing comments on the same line.
#      Currently stubbed (returns empty strings) for bootstrap.
@ publica
functio genSententia(Sententia stmt, TsGenerator g) -> textus {
    fixum leading = g.notaePrae(stmt)
    fixum trailing = g.notaePost(stmt)
    fixum content = genSententiaContent(stmt, g)
    redde scriptum("§§§", leading, content, trailing)
}

# Generate statement content without comments
functio genSententiaContent(Sententia stmt, TsGenerator g) -> textus {
    discerne stmt {
        # Block
        casu MassaSententia ut s {
            redde genMassa(s.corpus qua lista<Sententia>, g)
        }

        # Variable declarations
        casu VariaSententia ut s {
            redde genVaria(s.species qua VariaGenus, s.nomen qua textus, s.typus, s.valor, g)
        }

        casu ImportaSententia ut s {
            redde genImporta(s.fons qua textus, s.specificatores qua lista<ImportaSpecificator>, s.totum qua bivalens, s.totumAlias, g)
        }

        casu DestructuraSententia ut s {
            redde genDestructura(s.fons, s.species qua VariaGenus, s.specificatores qua lista<ImportaSpecificator>, g)
        }

        # Function declaration
        casu FunctioDeclaratio ut f {
            redde genFunctio(f.nomen qua textus, f.generaParametra, f.parametra qua lista<Parametrum>, f.typusReditus, f.corpus, f.asynca qua bivalens, f.generator qua bivalens, f.structor qua bivalens, g)
        }

        # Type declarations
        casu GenusDeclaratio ut s {
            redde genGenus(s.nomen qua textus, s.generaParametra, s.extendit, s.implet, s.abstractum qua bivalens, s.campi qua lista<CampusDeclaratio>, s.structor, s.methodi qua lista<Sententia>, g)
        }

        casu PactumDeclaratio ut s {
            redde genPactum(s.nomen qua textus, s.generaParametra, s.methodi qua lista<PactumMethodus>, g)
        }

        casu TypusAliasDeclaratio ut s {
            redde genTypusAlias(s.nomen qua textus, s.typus qua TypusAnnotatio, s.scopusNomen, g)
        }

        casu OrdoDeclaratio ut s {
            redde genOrdo(s.nomen qua textus, s.membra qua lista<OrdoMembrum>, g)
        }

        casu DiscretioDeclaratio ut s {
            redde genDiscretio(s.nomen qua textus, s.generaParametra, s.variantes qua lista<VariansDeclaratio>, g)
        }

        # Control flow
        casu SiSententia ut s {
            redde genSi(s.condicio, s.consequens qua Sententia, s.alternans, g)
        }

        casu DumSententia ut s {
            redde genDum(s.condicio, s.corpus qua Sententia, g)
        }

        casu IteratioSententia ut s {
            redde genIteratio(s.species qua IteratioGenus, s.variabilis qua textus, s.iterabile, s.corpus qua Sententia, s.asynca qua bivalens, g)
        }

        casu InSententia ut s {
            fixum obj = genExpressia(s.obiectum, g)
            fixum block = genSententia(s.corpus qua Sententia, g)
            redde scriptum("§// in §\n§", g.ind(), obj, block)
        }

        casu EligeSententia ut s {
            redde genElige(s.discriminans, s.casus qua lista<EligeCasus>, s.praedefinitum, g)
        }

        casu DiscerneSententia ut s {
            redde genDiscerne(s.discriminans, s.casus qua lista<VariansCasus>, g)
        }

        casu CustodiSententia ut s {
            redde genCustodi(s.clausulae qua lista<CustodiClausula>, g)
        }

        # Error handling
        casu TemptaSententia ut s {
            redde genTempta(s.corpus qua Sententia, s.cape, s.demum, g)
        }

        casu IaceSententia ut s {
            redde genIace(s.fatale qua bivalens, s.argumentum, g)
        }

        casu FacSententia ut s {
            redde genFac(s.corpus qua Sententia, s.condicio, g)
        }

        casu AdfirmaSententia ut s {
            redde genAdfirma(s.condicio, s.nuntius, g)
        }

        # Actions
        casu ScribeSententia ut s {
            redde genScribe(s.gradus qua ScribeGradus, s.argumenta qua lista<Expressia>, g)
        }

        casu ReddeSententia ut s {
            redde genRedde(s.valor, g)
        }

        casu RumpeSententia {
            redde scriptum("§break;", g.ind())
        }

        casu PergeSententia {
            redde scriptum("§continue;", g.ind())
        }

        casu ExpressiaSententia ut s {
            redde scriptum("§§;", g.ind(), genExpressia(s.expressia, g))
        }

        casu IncipitSententia ut s {
            redde genIncipit(s.corpus, s.ergo, g)
        }

        casu IncipietSententia ut s {
            redde genIncipiet(s.corpus, s.ergo, g)
        }

        casu CuraSententia ut s {
            redde genCura(s.res, s.vinculum qua textus, s.corpus qua Sententia, s.asynca qua bivalens, g)
        }

        casu AdSententia {
            redde scriptum("§/* ad statement not implemented for TS */", g.ind())
        }

        # Tests
        casu ProbandumSententia ut s {
            redde genProbandum(s.nomen qua textus, s.corpus qua lista<Sententia>, g)
        }

        casu ProbaSententia ut s {
            redde genProba(s.nomen qua textus, s.modificator, s.corpus qua Sententia, g)
        }

        casu PraeparaMassa ut s {
            redde genPraepara(s.tempus qua PraeparaTempus, s.asynca qua bivalens, s.omnia qua bivalens, s.corpus qua Sententia, g)
        }
    }

    redde scriptum("§/* unknown statement */", g.ind())
}

# =============================================================================
# BLOCK
# =============================================================================

@ publica
functio genMassa(lista<Sententia> corpus, TsGenerator g) -> textus {
    varia lines = [] qua lista<textus>
    ex corpus pro stmt {
        lines.adde(genSententia(stmt, g))
    }
    redde lines.coniunge("\n")
}

# =============================================================================
# VARIABLE DECLARATIONS
# =============================================================================

@ publica
functio genVaria(VariaGenus species, textus nomen, ignotum adnotatioTypus, ignotum valor, TsGenerator g) -> textus {
    fixum keyword = species == VariaGenus.Fixum aut species == VariaGenus.Figendum sic "const" secus "let"
    fixum asyncPrefix = species == VariaGenus.Figendum aut species == VariaGenus.Variandum sic "await " secus ""

    varia result = scriptum("§§ §", g.ind(), keyword, nomen)

    si nonnihil adnotatioTypus {
        result = scriptum("§: §", result, genTypus(adnotatioTypus qua TypusAnnotatio, g))
    }

    si nonnihil valor {
        result = scriptum("§ = §§", result, asyncPrefix, genExpressia(valor qua Expressia, g))
    }

    redde scriptum("§;", result)
}

@ publica
functio genImporta(textus fons, lista<ImportaSpecificator> specificatores, bivalens totum, ignotum totumAlias, TsGenerator g) -> textus {
    si totum {
        si nonnihil totumAlias {
            redde scriptum("§import * as § from '§';", g.ind(), totumAlias qua textus, fons)
        }
        redde scriptum("§import * from '§';", g.ind(), fons)
    }

    varia specs = [] qua lista<textus>
    ex specificatores pro spec {
        si spec.importatum == spec.locale {
            specs.adde(spec.importatum)
        } secus {
            specs.adde(scriptum("§ as §", spec.importatum, spec.locale))
        }
    }

    redde scriptum("§import {{ § }} from '§';", g.ind(), specs.coniunge(", "), fons)
}

@ publica
functio genDestructura(Expressia fons, VariaGenus species, lista<ImportaSpecificator> specificatores, TsGenerator g) -> textus {
    fixum keyword = species == VariaGenus.Fixum sic "const" secus "let"

    varia specs = [] qua lista<textus>
    ex specificatores pro spec {
        si spec.importatum == spec.locale {
            specs.adde(spec.importatum)
        } secus {
            specs.adde(scriptum("§: §", spec.importatum, spec.locale))
        }
    }

    redde scriptum("§§ {{ § }} = §;", g.ind(), keyword, specs.coniunge(", "), genExpressia(fons, g))
}

# =============================================================================
# FUNCTION DECLARATION
# =============================================================================

@ publica
functio genFunctio(textus nomen, ignotum generaParametra, lista<Parametrum> parametra, ignotum typusReditus, ignotum corpus, bivalens asynca, bivalens generator, bivalens structor, TsGenerator g) -> textus {
    varia result = g.ind()

    # Async prefix
    si asynca {
        result = scriptum("§async ", result)
    }

    # Function keyword (or constructor)
    si structor {
        result = scriptum("§constructor", result)
    } secus {
        si generator {
            result = scriptum("§function* §", result, nomen)
        } secus {
            result = scriptum("§function §", result, nomen)
        }
    }

    # Generic parameters
    si nonnihil generaParametra {
        fixum gp = generaParametra qua lista<TypusParametrum>
        si gp.longitudo() > 0 {
            varia names = [] qua lista<textus>
            ex gp pro p {
                names.adde(p.nomen)
            }
            result = scriptum("§<§>", result, names.coniunge(", "))
        }
    }

    # Parameters
    varia params = [] qua lista<textus>
    ex parametra pro param {
        params.adde(genParametrum(param, g))
    }
    result = scriptum("§(§)", result, params.coniunge(", "))

    # Return type
    si nonnihil typusReditus et non structor {
        result = scriptum("§: §", result, genTypus(typusReditus qua TypusAnnotatio, g))
    }

    # Body
    si nonnihil corpus {
        g.intraProfundum()
        fixum body = genSententia(corpus qua Sententia, g)
        g.exiProfundum()
        result = scriptum("§ {{\n§\n§}}", result, body, g.ind())
    } secus {
        result = scriptum("§;", result)
    }

    redde result
}

@ publica
functio genParametrum(Parametrum param, TsGenerator g) -> textus {
    varia result = ""

    si param.residuum {
        result = "..."
    }

    # Use alias if present
    si nonnihil param.alias {
        result = scriptum("§§", result, param.alias qua textus)
    } secus {
        result = scriptum("§§", result, param.nomen)
    }

    # Type
    si nonnihil param.typus {
        result = scriptum("§: §", result, genTypus(param.typus qua TypusAnnotatio, g))
    }

    # Default value
    si nonnihil param.praedefinitum {
        result = scriptum("§ = §", result, genExpressia(param.praedefinitum, g))
    }

    redde result
}

# =============================================================================
# TYPE DECLARATIONS
# =============================================================================

@ publica
functio genGenus(textus nomen, ignotum generaParametra, ignotum extendit, ignotum implet, bivalens abstractum, lista<CampusDeclaratio> campi, ignotum structor, lista<Sententia> methodi, TsGenerator g) -> textus {
    varia result = g.ind()

    si abstractum {
        result = scriptum("§abstract ", result)
    }

    result = scriptum("§class §", result, nomen)

    # Generics
    si nonnihil generaParametra {
        fixum gp = generaParametra qua lista<textus>
        si gp.longitudo() > 0 {
            result = scriptum("§<§>", result, gp.coniunge(", "))
        }
    }

    # Extends
    si nonnihil extendit {
        result = scriptum("§ extends §", result, extendit qua textus)
    }

    # Implements
    si nonnihil implet {
        fixum impl = implet qua lista<textus>
        si impl.longitudo() > 0 {
            result = scriptum("§ implements §", result, impl.coniunge(", "))
        }
    }

    result = scriptum("§ {{\n", result)
    g.intraProfundum()
    g.inClass = verum

    # Fields
    ex campi pro campus {
        result = scriptum("§§\n", result, genCampus(campus, g))
    }

    # Constructor
    si nonnihil structor {
        result = scriptum("§§\n", result, genSententia(structor qua Sententia, g))
    }

    # Methods
    ex methodi pro methodus {
        result = scriptum("§§\n", result, genSententia(methodus, g))
    }

    g.inClass = falsum
    g.exiProfundum()
    result = scriptum("§§}}", result, g.ind())

    redde result
}

@ publica
functio genCampus(CampusDeclaratio campus, TsGenerator g) -> textus {
    varia result = g.ind()

    # Visibility
    si campus.visibilitas == Visibilitas.Publica {
        result = scriptum("§public ", result)
    } sin campus.visibilitas == Visibilitas.Protecta {
        result = scriptum("§protected ", result)
    } secus {
        result = scriptum("§private ", result)
    }

    si campus.staticum {
        result = scriptum("§static ", result)
    }

    result = scriptum("§§: §", result, campus.nomen, genTypus(campus.typus, g))

    si nonnihil campus.valor {
        result = scriptum("§ = §", result, genExpressia(campus.valor, g))
    }

    redde scriptum("§;", result)
}

@ publica
functio genPactum(textus nomen, ignotum generaParametra, lista<PactumMethodus> methodi, TsGenerator g) -> textus {
    varia result = scriptum("§interface §", g.ind(), nomen)

    si nonnihil generaParametra {
        fixum gp = generaParametra qua lista<textus>
        si gp.longitudo() > 0 {
            result = scriptum("§<§>", result, gp.coniunge(", "))
        }
    }

    result = scriptum("§ {{\n", result)
    g.intraProfundum()

    ex methodi pro methodus {
        varia params = [] qua lista<textus>
        ex methodus.parametra pro param {
            params.adde(genParametrum(param, g))
        }

        varia line = scriptum("§§(§)", g.ind(), methodus.nomen, params.coniunge(", "))

        si nonnihil methodus.typusReditus {
            line = scriptum("§: §", line, genTypus(methodus.typusReditus qua TypusAnnotatio, g))
        }

        result = scriptum("§§;\n", result, line)
    }

    g.exiProfundum()
    result = scriptum("§§}}", result, g.ind())

    redde result
}

@ publica
functio genTypusAlias(textus nomen, TypusAnnotatio adnotatioTypus, ignotum scopusNomen, TsGenerator g) -> textus {
    si nonnihil scopusNomen {
        redde scriptum("§type § = typeof §;", g.ind(), nomen, scopusNomen qua textus)
    }
    redde scriptum("§type § = §;", g.ind(), nomen, genTypus(adnotatioTypus, g))
}

@ publica
functio genOrdo(textus nomen, lista<OrdoMembrum> membra, TsGenerator g) -> textus {
    varia result = scriptum("§enum § {{\n", g.ind(), nomen)
    g.intraProfundum()

    ex membra pro membrum {
        si nonnihil membrum.valor {
            result = scriptum("§§§ = §,\n", result, g.ind(), membrum.nomen, membrum.valor qua textus)
        } secus {
            result = scriptum("§§§,\n", result, g.ind(), membrum.nomen)
        }
    }

    g.exiProfundum()
    result = scriptum("§§}}", result, g.ind())

    redde result
}

@ publica
functio genDiscretio(textus nomen, ignotum generaParametra, lista<VariansDeclaratio> variantes, TsGenerator g) -> textus {
    varia result = ""

    # Generate each variant interface
    ex variantes pro varians {
        result = scriptum("§§interface §§ {{\n", result, g.ind(), nomen, varians.nomen)
        g.intraProfundum()
        result = scriptum("§§tag: '§';\n", result, g.ind(), varians.nomen)

        ex varians.campi pro campus {
            result = scriptum("§§§: §;\n", result, g.ind(), campus.nomen, genTypus(campus.typus, g))
        }

        g.exiProfundum()
        result = scriptum("§§}}\n\n", result, g.ind())
    }

    # Generate union type alias
    varia variantNames = [] qua lista<textus>
    ex variantes pro varians {
        variantNames.adde(scriptum("§§", nomen, varians.nomen))
    }

    result = scriptum("§§type § = §;", result, g.ind(), nomen, variantNames.coniunge(" | "))

    redde result
}

# =============================================================================
# CONTROL FLOW
# =============================================================================

@ publica
functio genSi(Expressia condicio, Sententia consequens, ignotum alternans, TsGenerator g) -> textus {
    g.intraProfundum()
    fixum consBody = genSententia(consequens, g)
    g.exiProfundum()

    varia result = scriptum("§if (§) {{\n§\n§}}", g.ind(), genExpressia(condicio, g), consBody, g.ind())

    si nonnihil alternans {
        g.intraProfundum()
        fixum altBody = genSententia(alternans qua Sententia, g)
        g.exiProfundum()
        result = scriptum("§\nelse {{\n§\n§}}", result, altBody, g.ind())
    }

    redde result
}

@ publica
functio genDum(Expressia condicio, Sententia corpus, TsGenerator g) -> textus {
    g.intraProfundum()
    fixum body = genSententia(corpus, g)
    g.exiProfundum()
    redde scriptum("§while (§) {{\n§\n§}}", g.ind(), genExpressia(condicio, g), body, g.ind())
}

@ publica
functio genIteratio(IteratioGenus species, textus variabilis, Expressia iterabile, Sententia corpus, bivalens asynca, TsGenerator g) -> textus {
    fixum keyword = species == IteratioGenus.De sic "in" secus "of"
    fixum asyncPrefix = asynca sic "await " secus ""

    g.intraProfundum()
    fixum body = genSententia(corpus, g)
    g.exiProfundum()

    redde scriptum("§for §(const § § §) {{\n§\n§}}", g.ind(), asyncPrefix, variabilis, keyword, genExpressia(iterabile, g), body, g.ind())
}

@ publica
functio genElige(Expressia discriminans, lista<EligeCasus> casus, ignotum praedefinitum, TsGenerator g) -> textus {
    varia result = scriptum("§switch (§) {{\n", g.ind(), genExpressia(discriminans, g))
    g.intraProfundum()

    ex casus pro c {
        g.intraProfundum()
        fixum caseBody = genSententia(c.consequens, g)
        g.exiProfundum()
        result = scriptum("§§case §: {{\n§\n§break;\n§}}\n", result, g.ind(), genExpressia(c.condicio, g), caseBody, g.ind(), g.ind())
    }

    si nonnihil praedefinitum {
        g.intraProfundum()
        fixum defBody = genSententia(praedefinitum qua Sententia, g)
        g.exiProfundum()
        result = scriptum("§§default: {{\n§\n§}}\n", result, g.ind(), defBody, g.ind())
    }

    g.exiProfundum()
    result = scriptum("§§}}", result, g.ind())
    redde result
}

@ publica
functio genDiscerne(Expressia discriminans, lista<VariansCasus> casus, TsGenerator g) -> textus {
    fixum disc = genExpressia(discriminans, g)
    varia result = scriptum("§// discerne §\n", g.ind(), disc)

    varia first = verum
    ex casus pro c {
        si first {
            result = scriptum("§§if (§.tag === '§') {{\n", result, g.ind(), disc, c.variansNomen)
            first = falsum
        } secus {
            result = scriptum("§§else if (§.tag === '§') {{\n", result, g.ind(), disc, c.variansNomen)
        }

        g.intraProfundum()

        # Bind fields
        si c.vincula.longitudo() > 0 {
            result = scriptum("§§const {{ § }} = §;\n", result, g.ind(), c.vincula.coniunge(", "), disc)
        }

        result = scriptum("§§\n", result, genSententia(c.consequens, g))
        g.exiProfundum()
        result = scriptum("§§}}\n", result, g.ind())
    }

    redde result
}

@ publica
functio genCustodi(lista<CustodiClausula> clausulae, TsGenerator g) -> textus {
    varia result = ""
    ex clausulae pro clausula {
        g.intraProfundum()
        fixum body = genSententia(clausula.consequens, g)
        g.exiProfundum()
        result = scriptum("§§if (§) {{\n§\n§}}\n", result, g.ind(), genExpressia(clausula.condicio, g), body, g.ind())
    }
    redde result
}

# =============================================================================
# ERROR HANDLING
# =============================================================================

@ publica
functio genTempta(Sententia corpus, ignotum cape, ignotum demum, TsGenerator g) -> textus {
    g.intraProfundum()
    fixum tryBody = genSententia(corpus, g)
    g.exiProfundum()

    varia result = scriptum("§try {{\n§\n§}}", g.ind(), tryBody, g.ind())

    si nonnihil cape {
        fixum capeClausula = cape qua CapeClausula
        g.intraProfundum()
        fixum catchBody = genSententia(capeClausula.corpus, g)
        g.exiProfundum()
        result = scriptum("§\ncatch (§) {{\n§\n§}}", result, capeClausula.param, catchBody, g.ind())
    }

    si nonnihil demum {
        g.intraProfundum()
        fixum finallyBody = genSententia(demum qua Sententia, g)
        g.exiProfundum()
        result = scriptum("§\nfinally {{\n§\n§}}", result, finallyBody, g.ind())
    }

    redde result
}

@ publica
functio genIace(bivalens fatale, Expressia argumentum, TsGenerator g) -> textus {
    si fatale {
        g.features.panic = verum
        redde scriptum("§throw new Panic(§);", g.ind(), genExpressia(argumentum, g))
    }
    redde scriptum("§throw §;", g.ind(), genExpressia(argumentum, g))
}

@ publica
functio genFac(Sententia corpus, ignotum condicio, TsGenerator g) -> textus {
    g.intraProfundum()
    fixum body = genSententia(corpus, g)
    g.exiProfundum()

    si nonnihil condicio {
        # do-while loop
        redde scriptum("§do {{\n§\n§}} while (§);", g.ind(), body, g.ind(), genExpressia(condicio qua Expressia, g))
    }

    # Plain block
    redde scriptum("§{{\n§\n§}}", g.ind(), body, g.ind())
}

@ publica
functio genAdfirma(Expressia condicio, ignotum nuntius, TsGenerator g) -> textus {
    si nonnihil nuntius {
        redde scriptum("§console.assert(§, §);", g.ind(), genExpressia(condicio, g), genExpressia(nuntius qua Expressia, g))
    }
    redde scriptum("§console.assert(§);", g.ind(), genExpressia(condicio, g))
}

# =============================================================================
# ACTIONS
# =============================================================================

@ publica
functio genScribe(ScribeGradus gradus, lista<Expressia> argumenta, TsGenerator g) -> textus {
    varia args = [] qua lista<textus>
    ex argumenta pro arg {
        args.adde(genExpressia(arg, g))
    }

    varia method = "log"
    si gradus == ScribeGradus.Vide {
        method = "debug"
    } sin gradus == ScribeGradus.Mone {
        method = "warn"
    }

    redde scriptum("§console.§(§);", g.ind(), method, args.coniunge(", "))
}

@ publica
functio genRedde(ignotum valor, TsGenerator g) -> textus {
    si nonnihil valor {
        redde scriptum("§return §;", g.ind(), genExpressia(valor qua Expressia, g))
    }
    redde scriptum("§return;", g.ind())
}

# =============================================================================
# ENTRY POINTS
# =============================================================================

@ publica
functio genIncipit(ignotum corpus, ignotum ergo, TsGenerator g) -> textus {
    si nonnihil corpus {
        varia result = genSententia(corpus qua Sententia, g)
        si nonnihil ergo {
            result = scriptum("§\n§", result, genSententia(ergo qua Sententia, g))
        }
        redde result
    }
    redde ""
}

@ publica
functio genIncipiet(ignotum corpus, ignotum ergo, TsGenerator g) -> textus {
    g.intraProfundum()
    varia body = ""
    si nonnihil corpus {
        body = genSententia(corpus qua Sententia, g)
    }
    g.exiProfundum()

    varia result = scriptum("§(async () => {{\n§\n§}})();", g.ind(), body, g.ind())

    si nonnihil ergo {
        result = scriptum("§\n§", result, genSententia(ergo qua Sententia, g))
    }

    redde result
}

@ publica
functio genCura(ignotum res, textus vinculum, Sententia corpus, bivalens asynca, TsGenerator g) -> textus {
    varia result = scriptum("§{{\n", g.ind())
    g.intraProfundum()

    si nonnihil res {
        result = scriptum("§§const § = §;\n", result, g.ind(), vinculum, genExpressia(res qua Expressia, g))
    }

    g.intraProfundum()
    fixum tryBody = genSententia(corpus, g)
    g.exiProfundum()

    result = scriptum("§§try {{\n§\n§}}\n", result, g.ind(), tryBody, g.ind())
    result = scriptum("§§finally {{\n", result, g.ind())
    g.intraProfundum()
    result = scriptum("§§// cleanup §\n", result, g.ind(), vinculum)
    g.exiProfundum()
    result = scriptum("§§}}\n", result, g.ind())

    g.exiProfundum()
    result = scriptum("§§}}", result, g.ind())

    redde result
}

# =============================================================================
# TESTS
# =============================================================================

@ publica
functio genProbandum(textus nomen, lista<Sententia> corpus, TsGenerator g) -> textus {
    g.intraProfundum()
    varia body = "" qua textus
    ex corpus pro stmt {
        body = scriptum("§§\n", body, genSententia(stmt, g))
    }
    g.exiProfundum()

    redde scriptum("§describe('§', () => {{\n§§}});", g.ind(), nomen, body, g.ind())
}

@ publica
functio genProba(textus nomen, ignotum modificator, Sententia corpus, TsGenerator g) -> textus {
    varia testFn = "it"
    si nonnihil modificator {
        fixum mod = modificator qua ProbaModificator
        si mod == ProbaModificator.Omitte {
            testFn = "it.skip"
        } sin mod == ProbaModificator.Futurum {
            testFn = "it.todo"
        }
    }

    g.intraProfundum()
    fixum body = genSententia(corpus, g)
    g.exiProfundum()

    redde scriptum("§§('§', () => {{\n§\n§}});", g.ind(), testFn, nomen, body, g.ind())
}

@ publica
functio genPraepara(PraeparaTempus tempus, bivalens asynca, bivalens omnia, Sententia corpus, TsGenerator g) -> textus {
    varia hook = "beforeEach"
    si tempus == PraeparaTempus.Praepara {
        si omnia {
            hook = "beforeAll"
        } secus {
            hook = "beforeEach"
        }
    } secus {
        si omnia {
            hook = "afterAll"
        } secus {
            hook = "afterEach"
        }
    }

    fixum asyncPrefix = asynca sic "async " secus ""

    g.intraProfundum()
    fixum body = genSententia(corpus, g)
    g.exiProfundum()

    redde scriptum("§§(§() => {{\n§\n§}});", g.ind(), hook, asyncPrefix, body, g.ind())
}
