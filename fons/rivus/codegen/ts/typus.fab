# TypeScript Type Mapping - Latin types to TypeScript types
#
# Maps Latin type names to their TypeScript equivalents.

ex "../../ast/typus" importa TypusAnnotatio, TypusParametrum
ex "./nucleus" importa TsGenerator

# =============================================================================
# TYPE MAPPING
# =============================================================================

# Map a Latin type name to TypeScript type name
@ publica
functio mappaNomenTypi(textus nomen) -> textus {
    elige nomen {
        # Primitives
        casu "textus" { redde "string" }
        casu "numerus" { redde "number" }
        casu "fractus" { redde "number" }
        casu "decimus" { redde "Decimal" }
        casu "magnus" { redde "bigint" }
        casu "bivalens" { redde "boolean" }
        casu "nihil" { redde "null" }
        casu "vacuum" { redde "void" }
        casu "numquam" { redde "never" }

        # Binary
        casu "octeti" { redde "Uint8Array" }

        # Collections
        casu "lista" { redde "Array" }
        casu "tabula" { redde "Map" }
        casu "copia" { redde "Set" }

        # Async
        casu "promissum" { redde "Promise" }

        # Error
        casu "erratum" { redde "Error" }

        # Iterator
        casu "cursor" { redde "Iterator" }

        # Object
        casu "objectum" { redde "object" }
        casu "object" { redde "object" }

        # Unknown
        casu "ignotum" { redde "unknown" }
    }

    # User-defined type: pass through unchanged
    redde nomen
}

# =============================================================================
# TYPE GENERATION
# =============================================================================

# Generate TypeScript type from type annotation
@ publica
functio genTypus(TypusAnnotatio adnotatio, TsGenerator g) -> textus {
    # Track feature usage for preamble
    si adnotatio.nomen == "decimus" aut adnotatio.nomen == "decim" {
        g.features.decimal = verum
    }

    # Map Latin type name to TypeScript
    fixum base = mappaNomenTypi(adnotatio.nomen)

    # Build result with generics
    varia result = base

    si nonnihil adnotatio.typusParametra {
        fixum parametra = adnotatio.typusParametra qua lista<TypusParametrum>
        si parametra.longitudo() > 0 {
            varia params = [] qua lista<textus>
            ex parametra pro param {
                fixum paramStr = genTypusParametrum(param, g)
                si nonnihil paramStr {
                    params.adde(paramStr qua textus)
                }
            }
            si params.longitudo() > 0 {
                result = scriptum("ยง<ยง>", result, params.coniunge(", "))
            }
        }
    }

    # Handle nullable: textus? -> string | null
    si adnotatio.nullabilis {
        result = scriptum("ยง | null", result)
    }

    # Handle union types
    si nonnihil adnotatio.unio {
        fixum unioTypi = adnotatio.unio qua lista<TypusAnnotatio>
        si unioTypi.longitudo() > 0 {
            varia parts = [] qua lista<textus>
            ex unioTypi pro u {
                parts.adde(genTypus(u, g))
            }
            result = parts.coniunge(" | ")
        }
    }

    redde result
}

# Generate a single type parameter
@ publica
functio genTypusParametrum(TypusParametrum param, TsGenerator g) -> textus? {
    discerne param {
        casu Typus ut p {
            redde genTypus(p.adnotatio, g)
        }
        casu Littera {
            # Ignore numeric parameters (e.g., numerus<32>)
            redde nihil
        }
    }
    redde nihil
}

# Generate type parameter declarations for generics
# Example: <T, U, V>
@ publica
functio genTypusParametra(lista<textus> parametra) -> textus {
    redde scriptum("<ยง>", parametra.coniunge(", "))
}
