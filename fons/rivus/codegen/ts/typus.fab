# TypeScript Type Mapping - Latin types to TypeScript types
#
# Maps Latin type names to their TypeScript equivalents.

ex "../../ast/typus" importa TypusAnnotatio, TypusParametrum
ex "./nucleus" importa TsGenerator

# =============================================================================
# TYPE MAPPING
# =============================================================================

# Map a Latin type name to TypeScript type name
@ publica
functio mappaNomenTypi(textus nomen) -> textus {
    elige nomen {
        # Primitives
        casu "textus" reddit "string"
        casu "numerus" reddit "number"
        casu "fractus" reddit "number"
        casu "decimus" reddit "Decimal"
        casu "magnus" reddit "bigint"
        casu "bivalens" reddit "boolean"
        casu "nihil" reddit "null"
        casu "vacuum" reddit "void"
        casu "numquam" reddit "never"

        # Binary
        casu "octeti" reddit "Uint8Array"

        # Collections
        casu "lista" reddit "Array"
        casu "tabula" reddit "Map"
        casu "copia" reddit "Set"

        # Async
        casu "promissum" reddit "Promise"

        # Error
        casu "erratum" reddit "Error"

        # Iterator
        casu "cursor" reddit "Iterator"

        # Object
        casu "objectum" reddit "object"
        casu "object" reddit "object"

        # Unknown
        casu "ignotum" reddit "unknown"
    }

    # User-defined type: pass through unchanged
    redde nomen
}

# =============================================================================
# TYPE GENERATION
# =============================================================================

# Generate TypeScript type from type annotation
@ publica
functio genTypus(TypusAnnotatio adnotatio, TsGenerator g) -> textus {
    # Track feature usage for preamble
    si adnotatio.nomen == "decimus" aut adnotatio.nomen == "decim" {
        g.features.decimal = verum
    }

    # Map Latin type name to TypeScript
    fixum base = mappaNomenTypi(adnotatio.nomen)

    # Build result with generics
    varia result = base

    si nonnihil adnotatio.typusParametra {
        fixum parametra = adnotatio.typusParametra qua lista<TypusParametrum>
        si parametra.longitudo() > 0 {
            varia params = [] qua lista<textus>
            ex parametra pro param {
                fixum paramStr = genTypusParametrum(param, g)
                si nonnihil paramStr {
                    params.adde(paramStr qua textus)
                }
            }
            si params.longitudo() > 0 {
                result = scriptum("ยง<ยง>", result, params.coniunge(", "))
            }
        }
    }

    # Handle nullable: textus? -> string | null
    si adnotatio.nullabilis {
        result = scriptum("ยง | null", result)
    }

    # Handle union types
    si nonnihil adnotatio.unio {
        fixum unioTypi = adnotatio.unio qua lista<TypusAnnotatio>
        si unioTypi.longitudo() > 0 {
            varia parts = [] qua lista<textus>
            ex unioTypi pro u {
                parts.adde(genTypus(u, g))
            }
            result = parts.coniunge(" | ")
        }
    }

    redde result
}

# Generate a single type parameter
@ publica
functio genTypusParametrum(TypusParametrum param, TsGenerator g) -> textus? {
    discerne param {
        casu Typus ut p {
            redde genTypus(p.adnotatio, g)
        }
        casu Littera {
            # Ignore numeric parameters (e.g., numerus<32>)
            redde nihil
        }
    }
    redde nihil
}

# Generate type parameter declarations for generics
# Example: <T, U, V>
@ publica
functio genTypusParametra(lista<textus> parametra) -> textus {
    redde scriptum("<ยง>", parametra.coniunge(", "))
}
