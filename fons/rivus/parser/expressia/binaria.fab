# Binary Expression Parsers
#
# Operators: assignment, ternary, logical, comparison, bitwise, arithmetic.
# Uses precedence climbing with left-to-right associativity (except assignment/ternary).
#
# GRAMMAR:
#   assignment := ternary (('=' | '+=' | '-=' | ...) assignment)?
#   ternary := or (('?' expr ':' | 'sic' expr 'secus') ternary)?
#   or := and (('||' | 'aut' | 'vel') and)*
#   ... etc
#
# LATIN VOCABULARY:
# - assignatio = assignment
# - condicio = condition
# - aut = or (logical)
# - et = and

ex "../resolvitor" importa Resolvitor
ex "../../ast/positio" importa Locus
ex "../../ast/expressia" importa Expressia
ex "../../ast/typus" importa TypusAnnotatio
ex "../../ast/lexema" importa SymbolumGenus
ex "../errores" importa ParserErrorCodice
ex "./unaria" importa parseUnaria

functio estAssignabile(Expressia expr) -> bivalens {
    discerne expr {
        casu Nomen ut n {
            redde verum
        }
        casu MembrumExpressia ut m {
            redde verum
        }
    }

    redde falsum
}

# Parse assignment expression
#
# GRAMMAR: assignment := ternary (('=' | '+=' | '-=' | ...) assignment)?
#
# Assignment is right-associative: a = b = c parses as a = (b = c)
@ publica
functio parseAssignatio(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Parse left side (could be ternary or lower)
    varia sinister = parseCondicio(r)

    # Check for assignment operator
    si p.estAssignatioSignum(p.specta(0)) {
        fixum signum = p.procede().valor

        si non estAssignabile(sinister) {
            p.renuncia(ParserErrorCodice.InvalidumAssignatio, nihil)
        }

        # Right-associative: recurse into assignment
        fixum dexter = parseAssignatio(r)

        redde finge AssignatioExpressia {
            locus: locus,
            sinister: sinister,
            signum: signum,
            dexter: dexter
        } qua Expressia
    }

    redde sinister
}

# Parse ternary conditional expression
#
# GRAMMAR: ternary := or (('sic' expr 'secus' | '?' expr ':') ternary)?
#
# Latin: condicio sic consequens secus alternans
# JS:    condicio ? consequens : alternans
@ publica
functio parseCondicio(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Parse condition
    varia condicio = parseAut(r)

    # Check for ternary operator (sic/secus or ?/:)
    si p.congruetVerbum("sic") {
        fixum consequens = r.expressia()
        p.expectaVerbum("secus", ParserErrorCodice.ExpectaturSecus)
        fixum alternans = parseCondicio(r)

        redde finge CondicioExpressia {
            locus: locus,
            condicio: condicio,
            consequens: consequens,
            alternans: alternans
        } qua Expressia
    }

    si p.congruet(SymbolumGenus.Rogatio) {
        fixum consequens = r.expressia()
        p.expecta(SymbolumGenus.Colon, ParserErrorCodice.ExpectaturColon)
        fixum alternans = parseCondicio(r)

        redde finge CondicioExpressia {
            locus: locus,
            condicio: condicio,
            consequens: consequens,
            alternans: alternans
        } qua Expressia
    }

    redde condicio
}

# Parse logical OR expression
#
# GRAMMAR: or := and (('||' | 'aut' | '??') and)*
@ publica
functio parseAut(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    varia sinister = parseEt(r)

    dum p.congruet(SymbolumGenus.VelVel) aut p.congruetVerbum("aut") aut p.congruet(SymbolumGenus.RogatioBis) aut p.congruetVerbum("vel") {
        fixum operatorSym = p.praevius()
        fixum locus = operatorSym.locus
        fixum signum = operatorSym.valor
        fixum dexter = parseEt(r)

        sinister = finge BinariaExpressia {
            locus: locus,
            sinister: sinister,
            signum: signum,
            dexter: dexter
        } qua Expressia
    }

    redde sinister
}

# Parse logical AND expression
#
# GRAMMAR: and := equality (('&&' | 'et') equality)*
@ publica
functio parseEt(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    varia sinister = parseAequale(r)

    dum p.congruet(SymbolumGenus.EtEt) aut p.congruetVerbum("et") {
        fixum operatorSym = p.praevius()
        fixum locus = operatorSym.locus
        fixum signum = operatorSym.valor
        fixum dexter = parseAequale(r)

        sinister = finge BinariaExpressia {
            locus: locus,
            sinister: sinister,
            signum: signum,
            dexter: dexter
        } qua Expressia
    }

    redde sinister
}

# Parse equality expression
#
# GRAMMAR: equality := comparison (('==' | '!=' | '===' | '!==' | 'est') comparison)*
@ publica
functio parseAequale(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    varia sinister = parseComparatio(r)

    dum p.congruet(SymbolumGenus.AequumBis) aut p.congruet(SymbolumGenus.NonAequum) aut p.congruet(SymbolumGenus.AequumTer) aut p.congruet(SymbolumGenus.NonAequumBis) {
        fixum operatorSym = p.praevius()
        fixum locus = operatorSym.locus
        fixum signum = operatorSym.valor
        fixum dexter = parseComparatio(r)

        sinister = finge BinariaExpressia {
            locus: locus,
            sinister: sinister,
            signum: signum,
            dexter: dexter
        } qua Expressia
    }

    # Handle 'non est' type check
    si p.probaVerbum("non") et p.specta(1).species == SymbolumGenus.Verbum et p.specta(1).verbum == "est" {
        p.procede()
        p.procede()
        fixum locus = p.praevius().locus
        fixum scopus = r.adnotatio()
        redde finge UnariaExpressia {
            locus: locus,
            signum: "!",
            # WHY: Inline to keep contextual typing for Expressia union.
            argumentum: finge EstExpressia {
                locus: locus,
                expressia: sinister,
                scopus: scopus
            } qua Expressia
        } qua Expressia
    }

    # Handle 'est' type check
    si p.congruetVerbum("est") {
        fixum locus = p.praevius().locus
        fixum scopus = r.adnotatio()

        redde finge EstExpressia {
            locus: locus,
            expressia: sinister,
            scopus: scopus
        } qua Expressia
    }

    redde sinister
}

# Parse comparison expression
#
# GRAMMAR: comparison := additive (('<' | '>' | '<=' | '>=') additive)*
@ publica
functio parseComparatio(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    varia sinister = parseAmbitus(r)

    dum p.congruet(SymbolumGenus.Minor) aut p.congruet(SymbolumGenus.Maior) aut p.congruet(SymbolumGenus.MinorAequum) aut p.congruet(SymbolumGenus.MaiorAequum) aut p.congruetVerbum("intra") aut p.congruetVerbum("inter") {
        fixum operatorSym = p.praevius()
        fixum locus = operatorSym.locus
        fixum signum = operatorSym.valor
        fixum dexter = parseAmbitus(r)

        sinister = finge BinariaExpressia {
            locus: locus,
            sinister: sinister,
            signum: signum,
            dexter: dexter
        } qua Expressia
    }

    redde sinister
}

# Parse range expression
#
# GRAMMAR: range := additive (('..' | 'ante' | 'usque') additive ('per' additive)?)?
@ publica
functio parseAmbitus(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()
    varia initium = parseAdditio(r)

    varia inclusivum = falsum
    varia habetAmbitum = falsum

    si p.congruet(SymbolumGenus.PunctumBis) {
        habetAmbitum = verum
        inclusivum = falsum
    } sin p.probaVerbum("ante") {
        p.procede()
        habetAmbitum = verum
        inclusivum = falsum
    } sin p.probaVerbum("usque") {
        p.procede()
        habetAmbitum = verum
        inclusivum = verum
    }

    si habetAmbitum {
        fixum finis = parseAdditio(r)
        varia gradus = nihil qua Expressia?

        si p.probaVerbum("per") {
            p.procede()
            gradus = parseAdditio(r)
        }

        redde finge AmbitusExpressia {
            locus: locus,
            initium: initium,
            finis: finis,
            gradus: gradus,
            inclusivum: inclusivum
        } qua Expressia
    }

    redde initium
}

# Parse additive expression
#
# GRAMMAR: additive := multiplicative (('+' | '-') multiplicative)*
@ publica
functio parseAdditio(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    varia sinister = parseMultiplicatio(r)

    dum p.congruet(SymbolumGenus.Plus) aut p.congruet(SymbolumGenus.Minus) {
        fixum operatorSym = p.praevius()
        fixum locus = operatorSym.locus
        fixum signum = operatorSym.valor
        fixum dexter = parseMultiplicatio(r)

        sinister = finge BinariaExpressia {
            locus: locus,
            sinister: sinister,
            signum: signum,
            dexter: dexter
        } qua Expressia
    }

    redde sinister
}

# Parse multiplicative expression
#
# GRAMMAR: multiplicative := unary (('*' | '/' | '%') unary)*
@ publica
functio parseMultiplicatio(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    varia sinister = parseUnaria(r)

    dum p.congruet(SymbolumGenus.Stella) aut p.congruet(SymbolumGenus.Virgula) aut p.congruet(SymbolumGenus.Centum) {
        fixum operatorSym = p.praevius()
        fixum locus = operatorSym.locus
        fixum signum = operatorSym.valor
        fixum dexter = parseUnaria(r)

        sinister = finge BinariaExpressia {
            locus: locus,
            sinister: sinister,
            signum: signum,
            dexter: dexter
        } qua Expressia
    }

    redde sinister
}
