# Unary and Postfix Expression Parsers
#
# Prefix operators: non, -, ~, cede, novum, etc.
# Postfix operators: qua (type cast), innatum (native construction), call, member access
#
# GRAMMAR:
#   unary := ('non' | '-' | '~' | 'cede' | 'novum') unary | postfix
#   postfix := primary (callSuffix | memberSuffix | quaSuffix | innatumSuffix)*
#   callSuffix := '(' arguments ')'
#   memberSuffix := '.' IDENTIFIER | '[' expr ']'
#   quaSuffix := 'qua' typeAnnotation
#   innatumSuffix := 'innatum' typeAnnotation
#
# LATIN VOCABULARY:
# - unaria = unary
# - non = not
# - cede = yield/await
# - novum = new
# - qua = as (type cast)
# - innatum = native (type construction)

ex "../resolvitor" importa Resolvitor
ex "../../ast/positio" importa Locus
ex "../../ast/expressia" importa Expressia
ex "../../ast/typus" importa TypusAnnotatio
ex "../../ast/lexema" importa Symbolum, SymbolumGenus
ex "../errores" importa ParserErrorCodice
ex "../../lexicon/verba" importa estVerbumSententiae
ex "./primaria" importa parsePrimaria

# ============================================================================
# UNARY (PREFIX) EXPRESSIONS
# ============================================================================

# Parse unary expression
#
# Handles prefix operators: non, -, ~, nulla, nonnulla, cede, novum
#
# GRAMMAR: unary := prefixOp unary | postfix
@ publica
functio parseUnaria(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()
    fixum prox = p.specta(1)

    functio estInitiumExpressiae(Symbolum s) -> bivalens {
        si s.species inter [
            SymbolumGenus.Nomen,
            SymbolumGenus.Numerus,
            SymbolumGenus.Fractus,
            SymbolumGenus.Textus,
            SymbolumGenus.Exemplar,
            SymbolumGenus.Verum,
            SymbolumGenus.Falsum,
            SymbolumGenus.Nihil,
            SymbolumGenus.ParensSin,
            SymbolumGenus.QuadratusSin,
            SymbolumGenus.UncusSin
        ] {
            redde verum
        }

        si s.species == SymbolumGenus.Verbum {
            redde verum
        }

        redde falsum
    }

    # Check for prefix operators
    si p.congruetVerbum("non") {
        fixum argumentum = parseUnaria(r)
        redde finge UnariaExpressia {
            locus: locus,
            signum: "!",
            argumentum: argumentum
        } qua Expressia
    }

    si p.congruet(SymbolumGenus.Minus) {
        fixum argumentum = parseUnaria(r)
        redde finge UnariaExpressia {
            locus: locus,
            signum: "-",
            argumentum: argumentum
        } qua Expressia
    }

    si p.congruet(SymbolumGenus.Unda) {
        fixum argumentum = parseUnaria(r)
        redde finge UnariaExpressia {
            locus: locus,
            signum: "~",
            argumentum: argumentum
        } qua Expressia
    }

    si p.probaVerbum("nulla") aut p.probaVerbum("nonnulla") aut p.probaVerbum("nonnihil") aut p.probaVerbum("negativum") aut p.probaVerbum("positivum") {
        fixum signum = p.procede().verbum
        fixum argumentum = parseUnaria(r)
        redde finge UnariaExpressia {
            locus: locus,
            signum: signum,
            argumentum: argumentum
        } qua Expressia
    }

    functio estInitiumPostNihil(Symbolum s) -> bivalens {
        si s.species == SymbolumGenus.Verbum {
            # WHY: Only allow keywords that start expressions as nihil operands.
            si s.verbum inter ["pro", "finge", "praefixum", "scriptum", "lege", "sed", "novum", "ego"] {
                redde verum
            }
            # Treat statement/short-form keywords as terminators, not operands.
            si estVerbumSententiae(s.verbum) aut s.verbum inter ["reddit", "ergo", "secus", "sin", "aut", "et", "vel", "intra", "inter"] {
                redde falsum
            }
            redde falsum
        }
        redde estInitiumExpressiae(s)
    }

    # WHY: Only treat these as prefix unary operators if operand is on the same line.
    #      This prevents `verum\ni += 1` from being parsed as `(verum i) += 1`.
    fixum actualis = p.specta(0)
    fixum eademLinea = actualis.locus.linea == prox.locus.linea

    si p.proba(SymbolumGenus.Nihil) et eademLinea et estInitiumPostNihil(prox) et prox.species !== SymbolumGenus.UncusSin {
        # WHY: Avoid treating block starts as unary operands (si x == nihil { ... }).
        p.procede()
        fixum argumentum = parseUnaria(r)
        redde finge UnariaExpressia {
            locus: locus,
            signum: "nihil",
            argumentum: argumentum
        } qua Expressia
    }

    # Boolean true check: verum x -> x === true
    si p.proba(SymbolumGenus.Verum) et eademLinea et estInitiumPostNihil(prox) et prox.species !== SymbolumGenus.UncusSin {
        p.procede()
        fixum argumentum = parseUnaria(r)
        redde finge UnariaExpressia {
            locus: locus,
            signum: "verum",
            argumentum: argumentum
        } qua Expressia
    }

    # Boolean false check: falsum x -> x === false
    si p.proba(SymbolumGenus.Falsum) et eademLinea et estInitiumPostNihil(prox) et prox.species !== SymbolumGenus.UncusSin {
        p.procede()
        fixum argumentum = parseUnaria(r)
        redde finge UnariaExpressia {
            locus: locus,
            signum: "falsum",
            argumentum: argumentum
        } qua Expressia
    }

    # Await expression
    si p.congruetVerbum("cede") {
        fixum argumentum = parseUnaria(r)
        redde finge CedeExpressia {
            locus: locus,
            argumentum: argumentum
        } qua Expressia
    }

    # New expression
    si p.congruetVerbum("novum") {
        redde parseNovumExpressia(r, locus)
    }

    # No prefix operator - parse postfix
    redde parsePostfix(r)
}

# ============================================================================
# POSTFIX EXPRESSIONS
# ============================================================================

# Parse postfix expression (call, member, type cast)
#
# Handles chained suffixes: f(), x.y, x[i], x?.y, x!.y, x qua T
#
# GRAMMAR: postfix := primary (callSuffix | memberSuffix | quaSuffix)*
@ publica
functio parsePostfix(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    varia expressia = parsePrimaria(r)

    # Loop to handle chained postfix operations
    dum verum {
        fixum locus = p.locusActualis()

        # ---------------------------------------------------------------
        # Optional chaining: ?. ?[ ?(
        # WHY: Check for '?' with accessor to avoid consuming ternary
        # ---------------------------------------------------------------
        si p.proba(SymbolumGenus.Rogatio) et estAccessorInitium(p.specta(1)) {
            p.procede()

            si p.congruet(SymbolumGenus.Punctum) {
                fixum propSymbolum = parseNomenVelVerbum(r)
                expressia = finge MembrumExpressia {
                    locus: locus,
                    obiectum: expressia,
                    proprietas: propSymbolum,
                    computatum: falsum,
                    optivum: verum,
                    nonNullum: falsum
                } qua Expressia
                perge
            }

            si p.congruet(SymbolumGenus.QuadratusSin) {
                fixum proprietas = r.expressia()
                p.expecta(SymbolumGenus.QuadratusDex, ParserErrorCodice.ExpectaturQuadratusDex)

                expressia = finge MembrumExpressia {
                    locus: locus,
                    obiectum: expressia,
                    proprietas: proprietas,
                    computatum: verum,
                    optivum: verum,
                    nonNullum: falsum
                } qua Expressia
                perge
            }

            si p.congruet(SymbolumGenus.ParensSin) {
                fixum argumenta = parseArgumenta(r)
                p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)

                expressia = finge VocatioExpressia {
                    locus: locus,
                    vocatum: expressia,
                    argumenta: argumenta,
                    optivum: verum,
                    morphologia: nihil
                } qua Expressia
                perge
            }
        }

        # ---------------------------------------------------------------
        # Non-null chaining: !. ![ !(
        # WHY: '!' alone is not supported, only non-null accessors
        # ---------------------------------------------------------------
        si p.congruet(SymbolumGenus.NonPunctum) {
            fixum proprietas = parseNomenVelVerbum(r)
            expressia = finge MembrumExpressia {
                locus: locus,
                obiectum: expressia,
                proprietas: proprietas,
                computatum: falsum,
                optivum: falsum,
                nonNullum: verum
            } qua Expressia
            perge
        }

        si p.proba(SymbolumGenus.Non) et estAccessorInitium(p.specta(1)) {
            p.procede()

            si p.congruet(SymbolumGenus.Punctum) {
                fixum propSymbolum = parseNomenVelVerbum(r)
                expressia = finge MembrumExpressia {
                    locus: locus,
                    obiectum: expressia,
                    proprietas: propSymbolum,
                    computatum: falsum,
                    optivum: falsum,
                    nonNullum: verum
                } qua Expressia
                perge
            }

            si p.congruet(SymbolumGenus.QuadratusSin) {
                fixum proprietas = r.expressia()
                p.expecta(SymbolumGenus.QuadratusDex, ParserErrorCodice.ExpectaturQuadratusDex)

                expressia = finge MembrumExpressia {
                    locus: locus,
                    obiectum: expressia,
                    proprietas: proprietas,
                    computatum: verum,
                    optivum: falsum,
                    nonNullum: verum
                } qua Expressia
                perge
            }

            si p.congruet(SymbolumGenus.ParensSin) {
                fixum argumenta = parseArgumenta(r)
                p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)

                expressia = finge VocatioExpressia {
                    locus: locus,
                    vocatum: expressia,
                    argumenta: argumenta,
                    optivum: falsum,
                    morphologia: nihil
                } qua Expressia
                perge
            }
        }

        # Function call: expr(args)
        si p.congruet(SymbolumGenus.ParensSin) {
            fixum argumenta = parseArgumenta(r)
            p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)

            expressia = finge VocatioExpressia {
                locus: locus,
                vocatum: expressia,
                argumenta: argumenta,
                optivum: falsum,
                morphologia: nihil
            } qua Expressia
            perge
        }

        # Member access: expr.property
        si p.congruet(SymbolumGenus.Punctum) {
            fixum proprietas = parseNomenVelVerbum(r)

            expressia = finge MembrumExpressia {
                locus: locus,
                obiectum: expressia,
                proprietas: proprietas,
                computatum: falsum,
                optivum: falsum,
                nonNullum: falsum
            } qua Expressia
            perge
        }

        # Computed member access: expr[index]
        si p.congruet(SymbolumGenus.QuadratusSin) {
            fixum proprietas = r.expressia()
            p.expecta(SymbolumGenus.QuadratusDex, ParserErrorCodice.ExpectaturQuadratusDex)

            expressia = finge MembrumExpressia {
                locus: locus,
                obiectum: expressia,
                proprietas: proprietas,
                computatum: verum,
                optivum: falsum,
                nonNullum: falsum
            } qua Expressia
            perge
        }

        # Type cast: expr qua Type
        si p.congruetVerbum("qua") {
            fixum scopus = r.adnotatio()

            expressia = finge QuaExpressia {
                locus: locus,
                expressia: expressia,
                scopus: scopus
            } qua Expressia
            perge
        }

        # Native type construction: expr innatum Type
        # Example: {} innatum tabula<textus, numerus>
        si p.congruetVerbum("innatum") {
            fixum scopus = r.adnotatio()

            expressia = finge InnatumExpressia {
                locus: locus,
                expressia: expressia,
                scopus: scopus
            } qua Expressia
            perge
        }

        # Type conversion: expr numeratum, expr fractatum, expr textatum, expr bivalentum
        si p.probaVerbum("numeratum") aut p.probaVerbum("fractatum") aut
           p.probaVerbum("textatum") aut p.probaVerbum("bivalentum") {
            fixum signum = p.procede().verbum
            varia scopusTypus = nihil qua TypusAnnotatio?
            varia radix = nihil qua textus?
            varia fallback = nihil qua Expressia?

            # Type params for numeratum/fractatum only: <i32, Hex>
            si (signum == "numeratum" aut signum == "fractatum") et p.congruet(SymbolumGenus.Minor) {
                scopusTypus = r.adnotatio()
                si p.congruet(SymbolumGenus.Coma) {
                    fixum radixSym = p.specta(0)
                    # Radix types are parsed as identifiers, not keywords
                    si radixSym.species == SymbolumGenus.Nomen et radixSym.valor inter ["Dec", "Hex", "Oct", "Bin"] {
                        radix = p.procede().valor
                    }
                }
                p.expecta(SymbolumGenus.Maior, ParserErrorCodice.ExpectaturAngulusDex)
            }

            # Fallback clause: vel expr
            si p.congruetVerbum("vel") {
                fallback = parseUnaria(r)
            }

            expressia = finge ConversioExpressia {
                locus: locus,
                expressia: expressia,
                signum: signum,
                scopusTypus: scopusTypus,
                radix: radix,
                fallback: fallback
            } qua Expressia
            perge
        }

        # Bit shift: expr dextratum n, expr sinistratum n
        si p.probaVerbum("dextratum") aut p.probaVerbum("sinistratum") {
            fixum directio = p.procede().verbum
            fixum quantitas = parseUnaria(r)

            expressia = finge TranslatioExpressia {
                locus: locus,
                expressia: expressia,
                directio: directio,
                quantitas: quantitas
            } qua Expressia
            perge
        }

        # No more postfix operators
        rumpe
    }

    redde expressia
}

# ============================================================================
# CONSTRUCTOR AND ARGUMENT PARSING
# ============================================================================

# Parse novum (constructor) expression
#
# GRAMMAR:
#   novumExpr := 'novum' IDENTIFIER ('(' arguments ')')? ('de' expr | objectLiteral)?
#
# WHY: novum binds to the constructor name, not to a call expression.
@ publica
functio parseNovumExpressia(Resolvitor r, Locus locus) -> Expressia {
    fixum p = r.parser()

    # Constructor name
    fixum vocatum = parseNomenVelVerbum(r)

    # Optional arguments
    varia argumenta = [] innatum lista<Expressia>
    si p.congruet(SymbolumGenus.ParensSin) {
        argumenta = parseArgumenta(r)
        p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)
    }

    # Optional overrides: { ... } or de expr
    varia initor = nihil qua Expressia?
    si p.proba(SymbolumGenus.UncusSin) {
        initor = parsePrimaria(r)
    } sin p.probaVerbum("de") {
        p.procede()
        initor = r.expressia()
    }

    redde finge NovumExpressia {
        locus: locus,
        vocatum: vocatum,
        argumenta: argumenta,
        initor: initor
    } qua Expressia
}

# Parse function call arguments
#
# GRAMMAR: arguments := (expression (',' expression)*)?
@ publica
functio parseArgumenta(Resolvitor r) -> lista<Expressia> {
    fixum p = r.parser()
    varia argumenta = [] innatum lista<Expressia>

    # Check for empty arguments
    si p.proba(SymbolumGenus.ParensDex) {
        redde argumenta
    }

    # Parse first argument
    argumenta.adde(parseArgumentum(r))

    # Parse remaining comma-separated arguments
    dum p.congruet(SymbolumGenus.Coma) {
        # Allow trailing comma
        si p.proba(SymbolumGenus.ParensDex) {
            rumpe
        }
        argumenta.adde(parseArgumentum(r))
    }

    redde argumenta
}

# Parse a single argument (supports sparge)
@ publica
functio parseArgumentum(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    si p.probaVerbum("sparge") {
        # WHY: Spread arguments lower to ...expr in targets
        p.procede()
        fixum argumentum = r.expressia()
        redde finge DispersioElementum {
            locus: locus,
            argumentum: argumentum
        } qua Expressia
    }

    redde r.expressia()
}

# ============================================================================
# HELPERS
# ============================================================================

# Parse property name as identifier or keyword
@ publica
functio parseNomenVelVerbum(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum sym = p.specta(0)

    # WHY: Allow keywords as property names (e.g., items.omitte)
    si sym.species == SymbolumGenus.Nomen aut sym.species == SymbolumGenus.Verbum {
        p.procede()
        redde finge Nomen {
            locus: sym.locus,
            valor: sym.valor
        } qua Expressia
    }

    p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("got 'ยง'", sym.valor))
    p.procede()
    redde finge Nomen {
        locus: sym.locus,
        valor: sym.valor
    } qua Expressia
}

# Check for postfix accessor start after '?' or '!'
@ publica
functio estAccessorInitium(Symbolum s) -> bivalens {
    redde s.species == SymbolumGenus.Punctum aut s.species == SymbolumGenus.QuadratusSin aut s.species == SymbolumGenus.ParensSin
}
