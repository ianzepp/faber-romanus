# Primary Expression Parsers
#
# Terminals and grouping: literals, identifiers, parenthesized expressions,
# arrays, objects, lambdas, and special forms.
#
# GRAMMAR:
#   primary := IDENTIFIER | NUMBER | STRING | TEMPLATE_STRING
#            | 'ego' | 'verum' | 'falsum' | 'nihil'
#            | '(' expression ')' | arrayLiteral | objectLiteral
#            | lambdaExpression | fingeExpression | scriptumExpression
#            | legeExpression | regexExpression | abExpression | catenaExpression
#
# WHY: Primary expressions are the leaves of the expression tree.
#      Everything else builds on top of these terminals.
#
# LATIN VOCABULARY:
# - primaria = primary
# - littera = literal
# - nomen = identifier/name
# - ego = self/this
# - verum/falsum = true/false
# - nihil = null
# - series = array
# - obiectum = object
# - scriptum = formatted string
# - lege = read (stdin)
# - sed = regex (but/except)
# - ab = from (collection DSL)
# - catena = chain (collection DSL)

ex "../resolvitor" importa Resolvitor
ex "../../ast/positio" importa Locus
ex "../../ast/expressia" importa Expressia, LitteraGenus, ObiectumProprietas, LambdaParametrum
ex "../../ast/expressia" importa AbFiltrum, CatenaGradus
ex "../../ast/typus" importa TypusAnnotatio
ex "../../ast/lexema" importa SymbolumGenus
ex "../../ast/sententia" importa Sententia
ex "../errores" importa ParserErrorCodice

# ============================================================================
# PRIMARY DISPATCHER
# ============================================================================

# Parse primary expression
#
# Handles terminals: literals, identifiers, ego, grouped expressions.
# Routes to specialized parsers for compound forms (arrays, objects, lambdas).
@ publica
functio parsePrimaria(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum sym = p.specta(0)
    fixum locus = sym.locus

    # Numeric literal
    si sym.species == SymbolumGenus.Numerus {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Numerus,
            crudus: sym.valor
        } qua Expressia
    }

    # Float literal
    si sym.species == SymbolumGenus.Fractus {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Fractus,
            crudus: sym.valor
        } qua Expressia
    }

    # String literal
    si sym.species == SymbolumGenus.Textus {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Textus,
            crudus: sym.valor
        } qua Expressia
    }

    # Template literal
    si sym.species == SymbolumGenus.Exemplar {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Exemplar,
            crudus: sym.valor
        } qua Expressia
    }

    # Boolean: verum
    si sym.species == SymbolumGenus.Verum {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Verum,
            crudus: sym.valor
        } qua Expressia
    }

    # Boolean: falsum
    si sym.species == SymbolumGenus.Falsum {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Falsum,
            crudus: sym.valor
        } qua Expressia
    }

    # Null: nihil
    si sym.species == SymbolumGenus.Nihil {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Nihil,
            crudus: sym.valor
        } qua Expressia
    }

    # Ab expression (collection filtering DSL)
    si p.probaVerbum("ab") {
        redde parseAbExpressia(r)
    }

    # Identifier
    si sym.species == SymbolumGenus.Nomen {
        p.procede()
        redde finge Nomen {
            locus: locus,
            valor: sym.valor
        } qua Expressia
    }

    # Self reference: ego
    si p.probaVerbum("ego") {
        p.procede()
        redde finge EgoExpressia {
            locus: locus
        } qua Expressia
    }

    # Grouped expression: ( expr )
    si sym.species == SymbolumGenus.ParensSin {
        p.procede()
        fixum expr = r.expressia()
        p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)
        redde expr
    }

    # Array literal: [ ... ]
    si sym.species == SymbolumGenus.QuadratusSin {
        redde parseSeriesExpressia(r)
    }

    # Object literal: { ... }
    si sym.species == SymbolumGenus.UncusSin {
        redde parseObiectumExpressia(r)
    }

    # Lambda: pro x: expr
    si p.probaVerbum("pro") {
        redde parseLambdaExpressia(r)
    }

    # Discretio construction: finge Variant { ... } qua Type
    si p.probaVerbum("finge") {
        redde parseFingeExpressia(r)
    }

    # Praefixum (compile-time) expression
    si p.probaVerbum("praefixum") {
        redde parsePraefixumExpressia(r)
    }

    # Scriptum (format string)
    si p.probaVerbum("scriptum") {
        redde parseScriptumExpressia(r)
    }

    # Lege (stdin read)
    si p.probaVerbum("lege") {
        redde parseLegeExpressia(r)
    }

    # Regex literal: sed "pattern" flags?
    si p.probaVerbum("sed") {
        redde parseRegexExpressia(r)
    }

    # Collection DSL expression: ex items prima 5
    si p.probaVerbum("ex") {
        redde parseCatenaExpressia(r)
    }

    # Keyword identifiers (allow keywords as names in expression position)
    si sym.species == SymbolumGenus.Verbum {
        p.procede()
        redde finge Nomen {
            locus: locus,
            valor: sym.valor
        } qua Expressia
    }

    # Fallback: report error and return placeholder
    p.renuncia(ParserErrorCodice.ExpectaturExpressia, scriptum("got 'ยง'", sym.valor))
    si non p.estFinis() {
        p.procede()
    }
    redde finge Nomen {
        locus: locus,
        valor: ""
    } qua Expressia
}

# ============================================================================
# COLLECTION DSL (ex/ab expressions)
# ============================================================================

# Parse collection DSL expression (ex ... transforms)
#
# Example: ex items prima 5 summa
@ publica
functio parseCatenaExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("ex", ParserErrorCodice.ExpectaturEx)
    fixum fons = r.expressia()

    varia gradus = parseCatenaGradus(r)
    si gradus.longitudo() == 0 {
        p.renuncia(ParserErrorCodice.ExpectaturExpressia, "expected DSL transform after ex")
    }

    redde finge CatenaExpressia {
        locus: locus,
        fons: fons,
        gradus: gradus
    } qua Expressia
}

# Parse ab expression (collection filtering DSL)
#
# GRAMMAR:
#   abExpr := 'ab' expression filter? (',' transform)*
#   filter := ['non'] ('ubi' expression | IDENT)
#   transform := ('prima' | 'ultima' | 'summa') expression?
@ publica
functio parseAbExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("ab", ParserErrorCodice.ExpectaturExpressia)

    fixum fons = r.expressia()

    varia negata = falsum
    si p.probaVerbum("non") {
        negata = verum
        p.procede()
    }

    varia filtrum = nihil qua AbFiltrum?

    functio estCatenaVerbumSym(symbolum) -> bivalens {
        si symbolum.species !== SymbolumGenus.Verbum {
            redde falsum
        }
        si symbolum.verbum inter ["prima", "ultima", "summa"] {
            redde verum
        }
        redde falsum
    }

    si non p.proba(SymbolumGenus.Coma) {
        si p.probaVerbum("ubi") {
            p.procede()
            fixum condicio = r.expressia()
            filtrum = {
                locus: locus,
                habetUbi: verum,
                condicio: condicio
            } qua AbFiltrum
        } sin (p.proba(SymbolumGenus.Nomen) aut p.proba(SymbolumGenus.Verbum)) {
            fixum prox = p.specta(0)
            si non estCatenaVerbumSym(prox) et non p.probaVerbum("pro") et non p.probaVerbum("fit") et non p.probaVerbum("fiet") {
                fixum nomenSym = p.procede()
                filtrum = {
                    locus: nomenSym.locus,
                    habetUbi: falsum,
                    condicio: finge Nomen {
                        locus: nomenSym.locus,
                        valor: nomenSym.valor
                    } qua Expressia
                } qua AbFiltrum
            }
        }
    }

    varia gradus = nihil qua lista<CatenaGradus>?
    si p.congruet(SymbolumGenus.Coma) aut estCatenaVerbumSym(p.specta(0)) {
        gradus = parseCatenaGradus(r)
    }

    redde finge AbExpressia {
        locus: locus,
        fons: fons,
        negata: negata,
        filtrum: filtrum,
        gradus: gradus
    } qua Expressia
}

@ publica
functio parseCatenaGradus(Resolvitor r) -> lista<CatenaGradus> {
    fixum p = r.parser()
    varia gradus = [] innatum lista<CatenaGradus>

    functio estCatenaVerbumSym(symbolum) -> bivalens {
        si symbolum.species !== SymbolumGenus.Verbum {
            redde falsum
        }
        si symbolum.verbum inter ["prima", "ultima", "summa"] {
            redde verum
        }
        redde falsum
    }

    dum estCatenaVerbumSym(p.specta(0)) {
        fixum verbSym = p.procede()
        varia argumentum = nihil qua Expressia?

        si verbSym.verbum == "prima" aut verbSym.verbum == "ultima" {
            argumentum = r.expressia()
        }

        gradus.adde({
            locus: verbSym.locus,
            verbum: verbSym.verbum,
            argumentum: argumentum
        } qua CatenaGradus)

        si non p.congruet(SymbolumGenus.Coma) {
            rumpe
        }
    }

    redde gradus
}

# ============================================================================
# ARRAY AND OBJECT LITERALS
# ============================================================================

# Parse array literal
#
# GRAMMAR: arrayLiteral := '[' (expression (',' expression)*)? ']'
#
# Example: [1, 2, 3], [sparge items, 4, 5]
@ publica
functio parseSeriesExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expecta(SymbolumGenus.QuadratusSin, ParserErrorCodice.ExpectaturQuadratusSin)

    varia elementa = [] innatum lista<Expressia>

    si non p.proba(SymbolumGenus.QuadratusDex) {
        elementa.adde(parseElementumSeries(r))

        dum p.congruet(SymbolumGenus.Coma) {
            # Allow trailing comma
            si p.proba(SymbolumGenus.QuadratusDex) {
                rumpe
            }
            elementa.adde(parseElementumSeries(r))
        }
    }

    p.expecta(SymbolumGenus.QuadratusDex, ParserErrorCodice.ExpectaturQuadratusDex)

    redde finge SeriesExpressia {
        locus: locus,
        elementa: elementa
    } qua Expressia
}

# Parse a single array element (supports sparge)
@ publica
functio parseElementumSeries(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    si p.probaVerbum("sparge") {
        # WHY: Spread elements lower to DispersioElementum for codegen
        p.procede()
        fixum argumentum = r.expressia()
        redde finge DispersioElementum {
            locus: locus,
            argumentum: argumentum
        } qua Expressia
    }

    redde r.expressia()
}

# Parse object literal
#
# GRAMMAR: objectLiteral := '{' (property (',' property)*)? '}'
#          property := (IDENTIFIER | STRING) ':' expression
#                    | '[' expr ']' ':' expression  # computed key
#                    | IDENTIFIER                    # shorthand { name } = { name: name }
#                    | 'sparge' expression          # spread: sparge obj
#
# Examples:
#   {}
#   { name: "Alice" }
#   { name: "Alice", age: 30 }
#   { name }                      # shorthand
#   { [key]: value }              # computed
#   { sparge base, extra: 1 }    # spread
@ publica
functio parseObiectumExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expecta(SymbolumGenus.UncusSin, ParserErrorCodice.ExpectaturUncusSin)

    varia proprietates = [] innatum lista<ObiectumProprietas>

    # Parse properties until closing brace
    si non p.proba(SymbolumGenus.UncusDex) {
        fac {
            fixum propLocus = p.locusActualis()

            # Check for spread: sparge expr
            si p.probaVerbum("sparge") {
                p.procede()
                fixum argumentum = r.expressia()

                # Add as DispersioElementum property
                # WHY: We wrap spread in ObiectumProprietas with special marker
                #      by using the spread expression as both key and value
                proprietates.adde({
                    locus: propLocus,
                    clavis: argumentum,
                    valor: argumentum,
                    brevitas: falsum,
                    computatum: falsum,
                    dispersum: verum
                } qua ObiectumProprietas)
            } secus {
                # Parse the key
                varia clavis = nihil qua Expressia?
                varia computatum = falsum

                # Computed property: [expr]
                si p.congruet(SymbolumGenus.QuadratusSin) {
                    clavis = r.expressia()
                    p.expecta(SymbolumGenus.QuadratusDex, ParserErrorCodice.ExpectaturQuadratusDex)
                    computatum = verum
                }
                # String key: "name"
                sin p.proba(SymbolumGenus.Textus) {
                    fixum strSym = p.procede()
                    clavis = finge Littera {
                        locus: strSym.locus,
                        species: LitteraGenus.Textus,
                        crudus: strSym.valor
                    } qua Expressia
                }
                # Identifier key: name
                secus {
                    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
                    clavis = finge Nomen {
                        locus: nomenSym.locus,
                        valor: nomenSym.valor
                    } qua Expressia
                }

                # Check for colon (value follows) or shorthand
                si p.congruet(SymbolumGenus.Colon) {
                    # key: value
                    fixum valor = r.expressia()

                    proprietates.adde({
                        locus: propLocus,
                        clavis: clavis,
                        valor: valor,
                        brevitas: falsum,
                        computatum: computatum,
                        dispersum: falsum
                    } qua ObiectumProprietas)
                } secus {
                    # Shorthand: { name } means { name: name }
                    # Only valid for identifier keys
                    proprietates.adde({
                        locus: propLocus,
                        clavis: clavis,
                        valor: clavis,
                        brevitas: verum,
                        computatum: falsum,
                        dispersum: falsum
                    } qua ObiectumProprietas)
                }
            }
        } dum p.congruet(SymbolumGenus.Coma) et non p.proba(SymbolumGenus.UncusDex)
    }

    p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)

    redde finge ObiectumExpressia {
        locus: locus,
        proprietates: proprietates
    } qua Expressia
}

# ============================================================================
# LAMBDA EXPRESSIONS
# ============================================================================

# Parse lambda expression
#
# GRAMMAR:
#   lambdaExpr := 'pro' params? ('->' type)? (':' expression | blockStmt)
#   params := IDENTIFIER (',' IDENTIFIER)*
#
# Examples:
#   pro: 42                       # zero params
#   pro x: x * 2                  # single param
#   pro x, y: x + y               # multiple params
#   pro x -> numerus: x * 2       # with return type
#
# Note: Block form uses MassaSententia as corpus for later codegen.
@ publica
functio parseLambdaExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'pro'
    p.expectaVerbum("pro", ParserErrorCodice.ExpectaturPro)

    varia parametra = [] innatum lista<LambdaParametrum>

    # Check for immediate : or -> (zero-param lambda)
    si non p.proba(SymbolumGenus.Colon) et non p.proba(SymbolumGenus.Sagitta) {
        # Parse parameters until we hit : or ->
        fac {
            fixum paramLocus = p.locusActualis()
            fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)

            parametra.adde({
                locus: paramLocus,
                nomen: nomenSym.valor,
                typus: nihil
            } qua LambdaParametrum)
        } dum p.congruet(SymbolumGenus.Coma)
    }

    # Optional return type: -> Type
    varia typusReditus = nihil qua TypusAnnotatio?
    si p.congruet(SymbolumGenus.Sagitta) {
        typusReditus = r.adnotatio()
    }

    # Body: ':' expression or blockStmt
    varia corpus = nihil qua ignotum?
    si p.congruet(SymbolumGenus.Colon) {
        corpus = r.expressia()
    } sin p.proba(SymbolumGenus.UncusSin) {
        corpus = r.massa()
    } secus {
        p.expecta(SymbolumGenus.Colon, ParserErrorCodice.ExpectaturColon)
        corpus = r.expressia()
    }

    redde finge LambdaExpressia {
        locus: locus,
        parametra: parametra,
        corpus: corpus,
        typusReditus: typusReditus
    } qua Expressia
}

# Parse finge (discretio construction) expression
#
# GRAMMAR:
#   fingeExpr := 'finge' IDENTIFIER ('{' fields? '}')? ('qua' typeAnnotation)?
#   field := IDENTIFIER (':' expression)?
@ publica
functio parseFingeExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("finge", ParserErrorCodice.ExpectaturExpressia)

    fixum variansSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum variansNomen = variansSym.valor

    varia campi = [] innatum lista<ObiectumProprietas>

    si p.congruet(SymbolumGenus.UncusSin) {
        si non p.proba(SymbolumGenus.UncusDex) {
            fac {
                fixum campusLocus = p.locusActualis()

                fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
                # WHY: Keep Nomen as Expressia to avoid TS literal widening.
                fixum Expressia clavis = finge Nomen {
                    locus: nomenSym.locus,
                    valor: nomenSym.valor
                } qua Expressia

                # WHY: Preserve Expressia union type when assigning later expressions.
                varia Expressia valor = clavis
                varia brevitas = verum

                si p.congruet(SymbolumGenus.Colon) {
                    valor = r.expressia()
                    brevitas = falsum
                }

                campi.adde({
                    locus: campusLocus,
                    clavis: clavis,
                    valor: valor,
                    brevitas: brevitas,
                    computatum: falsum,
                    dispersum: falsum
                } qua ObiectumProprietas)
            } dum p.congruet(SymbolumGenus.Coma)
        }

        p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)
    }

    varia scopus = nihil qua TypusAnnotatio?
    si p.congruetVerbum("qua") {
        scopus = r.adnotatio()
    }

    redde finge FingeExpressia {
        locus: locus,
        variansNomen: variansNomen,
        campi: campi,
        scopus: scopus
    } qua Expressia
}

# ============================================================================
# COMPILE-TIME AND SPECIAL EXPRESSIONS
# ============================================================================

# Parse praefixum expression (compile-time evaluation)
#
# GRAMMAR: praefixum (blockStmt | '(' expression ')')
#
# Example: praefixum(VERSION), praefixum { computeConstant() }
@ publica
functio parsePraefixumExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("praefixum", ParserErrorCodice.ExpectaturExpressia)

    varia corpus = nihil qua ignotum?

    si p.proba(SymbolumGenus.UncusSin) {
        # WHY: Block form is allowed in grammar, but AST expects an expression.
        fixum massa = r.massa()
        corpus = massa
    } sin p.congruet(SymbolumGenus.ParensSin) {
        fixum expr = r.expressia()
        p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)
        corpus = expr
    } secus {
        p.renuncia(ParserErrorCodice.ExpectaturUncusVelParens, scriptum("got 'ยง'", p.specta(0).valor))
        corpus = finge Littera {
            locus: locus,
            species: LitteraGenus.Nihil,
            crudus: "nihil"
        } qua Expressia
    }

    redde finge PraefixumExpressia {
        locus: locus,
        corpus: corpus
    } qua Expressia
}

# Extract an expression from a block, preferring trailing redde/expr
@ publica
functio exMassaExpressia(Sententia massa, Locus locus) -> Expressia {
    # WHY: Blocks are statements; we salvage the last expression when present.
    discerne massa {
        casu MassaSententia ut m {
            si m.corpus.longitudo() > 0 {
                fixum ult = m.corpus[m.corpus.longitudo() - 1]
                discerne ult {
                    casu ReddeSententia ut r {
                        si nonnihil r.valor {
                            redde r.valor
                        }
                    }
                    casu ExpressiaSententia ut e {
                        redde e.expressia
                    }
                }
            }
        }
    }

    redde finge Littera {
        locus: locus,
        species: LitteraGenus.Nihil,
        crudus: "nihil"
    } qua Expressia
}

# Parse scriptum expression (format string)
#
# GRAMMAR: scriptum '(' STRING (',' expression)* ')'
#
# Example: scriptum("Hello, ยง!", name)
@ publica
functio parseScriptumExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("scriptum", ParserErrorCodice.ExpectaturExpressia)
    p.expecta(SymbolumGenus.ParensSin, ParserErrorCodice.ExpectaturParensSin)

    fixum exemplarSym = p.expecta(SymbolumGenus.Textus, ParserErrorCodice.ExpectaturTextus)
    fixum exemplar = exemplarSym.valor

    varia argumenta = [] innatum lista<Expressia>
    dum p.congruet(SymbolumGenus.Coma) {
        argumenta.adde(r.expressia())
    }

    p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)

    redde finge ScriptumExpressia {
        locus: locus,
        exemplar: exemplar,
        argumenta: argumenta
    } qua Expressia
}

# Parse lege expression (stdin read)
#
# GRAMMAR: lege ('lineam')?
#
# Example: lege (all stdin), lege lineam (one line)
@ publica
functio parseLegeExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("lege", ParserErrorCodice.ExpectaturExpressia)

    varia modus = "all" qua textus
    si p.probaVerbum("lineam") {
        p.procede()
        modus = "line"
    }

    redde finge LegeExpressia {
        locus: locus,
        modus: modus
    } qua Expressia
}

# Parse regex literal
#
# GRAMMAR: sed STRING IDENTIFIER?
#
# Example: sed "\\d+" g, sed "[a-z]+" i
@ publica
functio parseRegexExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("sed", ParserErrorCodice.ExpectaturExpressia)

    fixum patternSym = p.expecta(SymbolumGenus.Textus, ParserErrorCodice.ExpectaturTextusPostSed)
    varia vexilla = "" qua textus

    si p.proba(SymbolumGenus.Nomen) aut p.proba(SymbolumGenus.Verbum) {
        vexilla = p.procede().valor
    }

    redde finge LitteraRegex {
        locus: locus,
        forma: patternSym.valor,
        vexilla: vexilla
    } qua Expressia
}
