# Flow Control Statement Parsers
#
# Handles: elige (switch), discerne (pattern match), custodi (guard)
#
# GRAMMAR:
#   eligeStmt := 'elige' expr '{' eligeCase* ('secus' block)? '}'
#   eligeCase := 'si' expr block
#   discerneStmt := 'discerne' expr '{' variantCase* '}'
#   variantCase := 'si' IDENT ('pro' IDENT+)? block
#   custodiStmt := 'custodi' '{' custodiClause+ '}'
#   custodiClause := 'si' expr block
#
# LATIN VOCABULARY:
# - elige = choose (imperative of eligere)
# - discerne = distinguish (imperative of discernere)
# - custodi = guard (imperative of custodire)

ex "../resolvitor" importa Resolvitor
ex "../../ast/positio" importa Locus
ex "../../ast/expressia" importa Expressia
ex "../../ast/sententia" importa Sententia, EligeCasus, VariansCasus, CustodiClausula, CapeClausula
ex "../../ast/lexema" importa SymbolumGenus
ex "../errores" importa ParserErrorCodice
ex "./massa" importa parseMassaSententia

# Parse elige (switch) statement
#
# GRAMMAR:
#   eligeStmt := 'elige' expr '{' eligeCase* ('ceterum' block)? '}' ('cape' IDENT block)?
#   eligeCase := 'casu' expr ('ergo' stmt | block)
#
# Examples:
#   elige status {
#       casu "pending" { scribe "waiting" }
#       casu "done" { scribe "finished" }
#       ceterum { scribe "unknown" }
#   }
@ publica
functio parseEligeSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'elige'
    p.expectaVerbum("elige", ParserErrorCodice.ExpectaturElige)

    # Parse discriminant expression
    fixum discriminans = r.expressia()

    # Expect opening brace
    p.expecta(SymbolumGenus.UncusSin, ParserErrorCodice.ExpectaturUncusSin)

    varia casus = [] qua lista<EligeCasus>
    varia praedefinitum = nihil qua Sententia?

    # Parse cases until closing brace
    dum non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
        # Check for 'casu' case
        si p.probaVerbum("casu") {
            fixum casusLocus = p.locusActualis()
            p.procede()

            # Parse condition expression
            fixum condicio = r.expressia()

            # Parse body: block, ergo stmt, or reddit expr
            fixum consequens = parseCorpusBrevis(r)

            casus.adde({
                locus: casusLocus,
                condicio: condicio,
                consequens: consequens
            } qua EligeCasus)
        }
        # Check for 'ceterum' (default case)
        sin p.probaVerbum("ceterum") {
            p.procede()
            praedefinitum = parseCorpusBrevis(r)
            rumpe  # Default must be last
        }
        secus {
            # Invalid case start
            p.renuncia(ParserErrorCodice.InvalidumEligeCasusInitium, scriptum("got '§'", p.specta(0).valor))
            rumpe
        }
    }

    p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)

    # Optional catch clause
    varia cape = nihil qua CapeClausula?
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    redde finge EligeSententia {
        locus: locus,
        discriminans: discriminans,
        casus: casus,
        praedefinitum: praedefinitum,
        cape: cape
    } qua Sententia
}

# Parse discerne (pattern match) statement
#
# GRAMMAR:
#   discerneStmt := 'discerne' expr '{' variantCase* '}'
#   variantCase := 'casu' IDENT ('pro' IDENT (',' IDENT)*)? block
#
# Examples:
#   discerne event {
#       casu Click pro x, y { scribe scriptum("clicked at §, §", x, y) }
#       casu Keypress ut key { scribe scriptum("pressed §", key) }
#       casu Quit { mori "goodbye" }
#   }
@ publica
functio parseDiscerneSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'discerne'
    p.expectaVerbum("discerne", ParserErrorCodice.ExpectaturDiscerne)

    # Parse discriminant expression
    fixum discriminans = r.expressia()

    # Expect opening brace
    p.expecta(SymbolumGenus.UncusSin, ParserErrorCodice.ExpectaturUncusSin)

    varia casus = [] qua lista<VariansCasus>

    # Parse variant cases
    dum non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
        si p.probaVerbum("casu") {
            fixum casusLocus = p.locusActualis()
            p.procede()  # Consume 'casu'

            # Parse variant name
            fixum variansNomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
            fixum variansNomen = variansNomenSym.valor

            # Parse optional bindings: ut alias OR pro x, y, z
            varia vincula = [] qua lista<textus>
            si p.probaVerbum("ut") {
                p.procede()
                fixum aliasSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
                vincula.adde(aliasSym.valor)
            } sin p.probaVerbum("pro") {
                p.procede()
                fac {
                    fixum vincSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
                    vincula.adde(vincSym.valor)
                } dum p.congruet(SymbolumGenus.Coma)
            }

            # Parse body
            fixum consequens = parseCorpusBrevis(r)

            casus.adde({
                locus: casusLocus,
                variansNomen: variansNomen,
                vincula: vincula,
                consequens: consequens
            } qua VariansCasus)
        } secus {
            p.renuncia(ParserErrorCodice.InvalidumDiscerneCasusInitium, scriptum("got '§'", p.specta(0).valor))
            rumpe
        }
    }

    p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)

    redde finge DiscerneSententia {
        locus: locus,
        discriminans: discriminans,
        casus: casus
    } qua Sententia
}

# Parse custodi (guard) statement
#
# GRAMMAR:
#   custodiStmt := 'custodi' '{' custodiClause+ '}'
#   custodiClause := 'si' expr block
#
# Examples:
#   custodi {
#       si user == nihil { redde nihil }
#       si user.aetas < 0 { iace "Invalid age" }
#   }
@ publica
functio parseCustodiSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'custodi'
    p.expectaVerbum("custodi", ParserErrorCodice.ExpectaturCustodi)

    # Expect opening brace
    p.expecta(SymbolumGenus.UncusSin, ParserErrorCodice.ExpectaturUncusSin)

    varia clausulae = [] qua lista<CustodiClausula>

    # Parse guard clauses
    dum non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
        si p.probaVerbum("si") {
            fixum clausulaLocus = p.locusActualis()
            p.procede()  # Consume 'si'

            fixum condicio = r.expressia()
            fixum consequens = parseCorpusBrevis(r)

            clausulae.adde({
                locus: clausulaLocus,
                condicio: condicio,
                consequens: consequens
            } qua CustodiClausula)
        } secus {
            p.renuncia(ParserErrorCodice.ExpectaturSi, scriptum("got '§'", p.specta(0).valor))
            rumpe
        }
    }

    p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)

    redde finge CustodiSententia {
        locus: locus,
        clausulae: clausulae
    } qua Sententia
}

# Parse catch clause (helper)
@ publica
functio parseCapeClausula(Resolvitor r) -> CapeClausula {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # 'cape' already consumed by caller checking probaVerbum
    p.procede()

    # Parse error binding name
    fixum paramSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum param = paramSym.valor

    # Parse body
    fixum corpus = parseMassaSententia(r)

    redde {
        locus: locus,
        param: param,
        corpus: corpus
    } qua CapeClausula
}

# Parse a block or short-form body
@ publica
functio parseCorpusBrevis(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    si p.probaVerbum("ergo") {
        p.procede()
        redde r.sententia()
    }

    si p.probaVerbum("reddit") {
        p.procede()
        fixum valor = r.expressia()
        redde finge ReddeSententia {
            locus: locus,
            valor: valor
        } qua Sententia
    }

    redde parseMassaSententia(r)
}
