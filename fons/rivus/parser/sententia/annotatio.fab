# Annotation Parser - @ Directive Parsing
#
# Parses line-based annotations that modify declarations.
#
# GRAMMAR:
#   annotation := '@' IDENTIFIER arguments?
#   arguments := IDENTIFIER (',' IDENTIFIER)*  (same line only)
#
# Examples:
#   @ futura                         -> marks function as async
#   @ radix imperativus, perfectum   -> verb morphology forms
#   @ publica                        -> visibility modifier
#   @ externa                        -> external declaration
#
# LATIN VOCABULARY:
# - annotatio = annotation/note

ex "../resolvitor" importa Resolvitor
ex "../../ast/positio" importa Locus
ex "../../ast/lexema" importa SymbolumGenus
ex "../errores" importa ParserErrorCodice

# ============================================================================
# TYPES
# ============================================================================

# Parsed annotation with optional arguments
@ publicum
genus Annotatio {
    Locus locus
    textus nomen                # annotation name (e.g., "futura", "radix")
    lista<textus> argumenta     # optional arguments (e.g., ["imperativus"])
}

# ============================================================================
# HELPERS
# ============================================================================

# Check if a string is a valid verb form for @ radix
functio estFormaRadix(textus forma) -> bivalens {
    redde forma inter ["imperativus", "perfectum", "futurum_indicativum", "futurum_activum"]
}

# ============================================================================
# PARSER
# ============================================================================

# Parse all annotations at current position
#
# Consumes @ directives until a non-@ token is found.
# For @ radix, collects comma-separated form names on the same line.
@ publica
functio parseAnnotationes(Resolvitor r) -> lista<Annotatio> {
    fixum p = r.parser()
    varia annotationes = [] qua lista<Annotatio>

    dum p.congruet(SymbolumGenus.At) {
        fixum locus = p.praevius().locus
        fixum linea = locus.linea
        fixum sym = p.specta(0)

        varia nomen = ""
        si sym.species == SymbolumGenus.Nomen aut sym.species == SymbolumGenus.Verbum {
            p.procede()
            nomen = sym.valor
        } secus {
            p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("got 'ยง'", sym.valor))
            p.procede()
        }

        varia argumenta = [] qua lista<textus>

        si nomen == "radix" {
            dum non p.estFinis() {
                fixum next = p.specta(0)
                si next.locus.linea != linea {
                    rumpe
                }

                si next.species == SymbolumGenus.Coma {
                    p.procede()
                    perge
                }

                si next.species == SymbolumGenus.Nomen aut next.species == SymbolumGenus.Verbum {
                    p.procede()
                    si estFormaRadix(next.valor) {
                        argumenta.adde(next.valor)
                    } secus {
                        p.renuncia(ParserErrorCodice.InvalidaRadixForma, scriptum("got 'ยง'", next.valor))
                    }
                    perge
                }

                p.renuncia(ParserErrorCodice.InvalidaRadixForma, scriptum("got 'ยง'", next.valor))
                p.procede()
            }
        }

        annotationes.adde({
            locus: locus,
            nomen: nomen,
            argumenta: argumenta
        } qua Annotatio)
    }

    redde annotationes
}
