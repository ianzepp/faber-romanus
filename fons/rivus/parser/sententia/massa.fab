# Block and Program Parsers
#
# Top-level program parsing and block statement handling.
#
# GRAMMAR:
#   program := statement*
#   blockStmt := '{' statement* '}'
#   exprStmt := expression
#
# LATIN VOCABULARY:
# - programma = program
# - massa = block/mass (a body of statements)
# - sententia = statement
# - expressia = expression

ex "../resolvitor" importa Resolvitor
ex "../../ast/positio" importa Locus
ex "../../ast/expressia" importa Expressia
ex "../../ast/sententia" importa Sententia
ex "../../ast/lexema" importa SymbolumGenus
ex "../errores" importa ParserErrorCodice

# Programma - top-level program AST node
# NOTE: This is separate from Sententia since it's the root
@ publicum
genus Programma {
    Locus locus
    lista<Sententia> corpus
}

# Parse a block statement
#
# GRAMMAR: blockStmt := '{' statement* '}'
#
# Consumes opening brace, parses statements until closing brace.
# Handles optional semicolons between statements.
@ publica
functio parseMassaSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Expect opening brace
    p.expecta(SymbolumGenus.UncusSin, ParserErrorCodice.ExpectaturUncusSin)

    varia corpus = [] qua lista<Sententia>

    # Parse statements until closing brace or end
    dum non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
        # Skip optional semicolons between statements
        dum p.congruet(SymbolumGenus.PunctumColon) {
            # Continue skipping
        }

        # Check again after skipping semicolons
        si p.proba(SymbolumGenus.UncusDex) aut p.estFinis() {
            rumpe
        }

        # Parse the next statement
        corpus.adde(r.sententia())
    }

    # Expect closing brace
    p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)

    redde finge MassaSententia {
        locus: locus,
        corpus: corpus
    } qua Sententia
}

# Parse an expression statement
#
# GRAMMAR: exprStmt := expression
#
# Wraps a standalone expression as a statement.
@ publica
functio parseExpressiaSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()
    fixum expressia = r.expressia()

    redde finge ExpressiaSententia {
        locus: locus,
        expressia: expressia
    } qua Sententia
}

# Parse top-level program
#
# GRAMMAR: program := statement*
#
# Parses statements until end of input.
# Uses error recovery to handle malformed statements.
@ publica
functio parseProgramma(Resolvitor r) -> Programma {
    fixum p = r.parser()
    fixum locus = p.locusActualis()
    varia corpus = [] qua lista<Sententia>

    # Parse statements until end of input
    dum non p.estFinis() {
        # Skip optional semicolons between statements
        dum p.congruet(SymbolumGenus.PunctumColon) {
            # Continue skipping
        }

        # Check again after skipping
        si p.estFinis() {
            rumpe
        }

        # Try to parse statement with error recovery
        tempta {
            corpus.adde(r.sententia())
        } cape e {
            # Error recovery: skip to next statement boundary
            p.synchrona()
        }
    }

    redde {
        locus: locus,
        corpus: corpus
    } qua Programma
}
