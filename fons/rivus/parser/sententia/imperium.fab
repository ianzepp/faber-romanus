# Control Flow Statement Parsers
#
# Handles: si, dum, ex, de (conditionals and loops)
#
# GRAMMAR:
#   siStmt := 'si' expr blockStmt ('secus' 'si' expr blockStmt)* ('secus' blockStmt)?
#           | 'si' expr blockStmt 'cape' IDENT blockStmt
#   dumStmt := 'dum' expr blockStmt ('cape' IDENT blockStmt)?
#   exStmt := 'ex' expr 'pro' IDENT blockStmt ('cape' IDENT blockStmt)?
#   deStmt := 'de' expr 'pro' IDENT blockStmt ('cape' IDENT blockStmt)?
#
# LATIN VOCABULARY:
# - si = if
# - secus = else
# - sin = else if
# - dum = while
# - ex = from (iterate values)
# - de = from (iterate keys)
# - pro = for
# - cape = catch

ex "../resolvitor" importa Resolvitor
ex "../../ast/positio" importa Locus
ex "../../ast/expressia" importa Expressia
ex "../../ast/sententia" importa Sententia, CapeClausula, IteratioGenus
ex "../../ast/lexema" importa SymbolumGenus
ex "../errores" importa ParserErrorCodice
ex "./massa" importa parseMassaSententia

# Parse if statement
#
# GRAMMAR:
#   siStmt := 'si' expr blockStmt ('secus' 'si' expr blockStmt)* ('secus' blockStmt)?
#           | 'si' expr blockStmt 'cape' IDENT blockStmt
#
# Examples:
#   si x > 0 { scribe "positive" }
#   si x > 0 { ... } secus { ... }
#   si x > 0 { ... } sin x < 0 { ... } secus { ... }
#   si fetch() cape err { handle(err) }
@ publica
functio parseSiSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'si'
    p.expectaVerbum("si", ParserErrorCodice.ExpectaturSi)

    # Parse condition
    fixum condicio = r.expressia()

    # Parse consequent block
    fixum consequens = parseMassaSententia(r)

    # Check for optional catch (si expr { } cape err { })
    varia cape = nihil qua CapeClausula?
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    # Check for else/else-if chain
    varia alternans = nihil qua Sententia?

    si p.probaVerbum("secus") {
        # Check if this is 'sin' (else if)
        si p.probaVerbum("si") {
            # Recurse - but we already consumed 'si', need to back up
            # Actually, let's handle else-if differently
        }
        alternans = parseMassaSententia(r)
    }

    # Also check for 'sin' (else if shorthand)
    si p.probaVerbum("sin") {
        # Parse the rest as another si statement
        fixum siLocus = p.locusActualis()
        fixum siCondicio = r.expressia()
        fixum siConsequens = parseMassaSententia(r)

        # Recursively check for more else-if or else
        varia siAlternans = nihil qua Sententia?
        si p.probaVerbum("secus") {
            siAlternans = parseMassaSententia(r)
        } sin p.probaVerbum("sin") {
            # Need to handle nested sin - for now, parse as expression statement
            # TODO: proper recursive handling
        }

        alternans = finge SiSententia {
            locus: siLocus,
            condicio: siCondicio,
            consequens: siConsequens,
            alternans: siAlternans,
            cape: nihil
        } qua Sententia
    }

    redde finge SiSententia {
        locus: locus,
        condicio: condicio,
        consequens: consequens,
        alternans: alternans,
        cape: cape
    } qua Sententia
}

# Parse while statement
#
# GRAMMAR: dumStmt := 'dum' expr blockStmt ('cape' IDENT blockStmt)?
#
# Examples:
#   dum x > 0 { x = x - 1 }
#   dum iter.sequens() cape err { handle(err) }
@ publica
functio parseDumSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'dum'
    p.expectaVerbum("dum", ParserErrorCodice.ExpectaturDum)

    # Parse condition
    fixum condicio = r.expressia()

    # Parse body
    fixum corpus = parseMassaSententia(r)

    # Optional catch
    varia cape = nihil qua CapeClausula?
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    redde finge DumSententia {
        locus: locus,
        condicio: condicio,
        corpus: corpus,
        cape: cape
    } qua Sententia
}

# Parse for-of loop (iterate values)
#
# GRAMMAR: exStmt := 'ex' expr 'pro' IDENT blockStmt ('cape' IDENT blockStmt)?
#
# Examples:
#   ex items pro item { scribe item }
#   ex 0 ante 10 pro i { scribe i }
@ publica
functio parseExSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'ex'
    p.expectaVerbum("ex", ParserErrorCodice.ExpectaturEx)

    # Parse iterable expression
    fixum iterabile = r.expressia()

    # Expect 'pro'
    p.expectaVerbum("pro", ParserErrorCodice.ExpectaturPro)

    # Parse variable name
    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum variabilis = nomenSym.valor

    # Parse body
    fixum corpus = parseMassaSententia(r)

    # Optional catch
    varia cape = nihil qua CapeClausula?
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    redde finge IteratioSententia {
        locus: locus,
        species: IteratioGenus.Ex,
        variabilis: variabilis,
        iterabile: iterabile,
        corpus: corpus,
        asynca: falsum,
        cape: cape
    } qua Sententia
}

# Parse for-in loop (iterate keys)
#
# GRAMMAR: deStmt := 'de' expr 'pro' IDENT blockStmt ('cape' IDENT blockStmt)?
#
# Examples:
#   de obiectum pro clavis { scribe clavis }
@ publica
functio parseDeSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'de'
    p.expectaVerbum("de", ParserErrorCodice.ExpectaturDe)

    # Parse iterable expression
    fixum iterabile = r.expressia()

    # Expect 'pro'
    p.expectaVerbum("pro", ParserErrorCodice.ExpectaturPro)

    # Parse variable name
    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum variabilis = nomenSym.valor

    # Parse body
    fixum corpus = parseMassaSententia(r)

    # Optional catch
    varia cape = nihil qua CapeClausula?
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    redde finge IteratioSententia {
        locus: locus,
        species: IteratioGenus.De,
        variabilis: variabilis,
        iterabile: iterabile,
        corpus: corpus,
        asynca: falsum,
        cape: cape
    } qua Sententia
}

# Parse catch clause
#
# GRAMMAR: capeClause := 'cape' IDENT blockStmt
#
# Example: cape err { handle(err) }
@ publica
functio parseCapeClausula(Resolvitor r) -> CapeClausula {
    fixum p = r.parser()
    fixum locus = p.praevius().locus  # 'cape' already consumed

    # Parse error binding name
    fixum paramSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum param = paramSym.valor

    # Parse catch body
    fixum corpus = parseMassaSententia(r)

    redde {
        locus: locus,
        param: param,
        corpus: corpus
    } qua CapeClausula
}
