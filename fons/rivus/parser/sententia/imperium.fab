# Control Flow Statement Parsers
#
# Handles: si, dum, ex, de, in (conditionals and loops)
#
# GRAMMAR:
#   siStmt := 'si' expr blockStmt ('secus' 'si' expr blockStmt)* ('secus' blockStmt)?
#           | 'si' expr blockStmt 'cape' IDENT blockStmt
#   dumStmt := 'dum' expr blockStmt ('cape' IDENT blockStmt)?
#   exStmt := 'ex' expr 'pro' IDENT blockStmt ('cape' IDENT blockStmt)?
#   deStmt := 'de' expr 'pro' IDENT blockStmt ('cape' IDENT blockStmt)?
#   inStmt := 'in' expr blockStmt
#
# LATIN VOCABULARY:
# - si = if
# - secus = else
# - sin = else if
# - dum = while
# - ex = from (iterate values)
# - de = from (iterate keys)
# - in = into (mutation)
# - pro = for
# - cape = catch

ex "../resolvitor" importa Resolvitor
ex "../../ast/positio" importa Locus
ex "../../ast/expressia" importa Expressia
ex "../../ast/sententia" importa Sententia, CapeClausula, IteratioGenus
ex "../../ast/lexema" importa SymbolumGenus
ex "../errores" importa ParserErrorCodice
ex "./massa" importa parseMassaSententia

# Parse if statement
#
# GRAMMAR:
#   siStmt := 'si' expr blockStmt ('secus' 'si' expr blockStmt)* ('secus' blockStmt)?
#           | 'si' expr blockStmt 'cape' IDENT blockStmt
#
# Examples:
#   si x > 0 { scribe "positive" }
#   si x > 0 { ... } secus { ... }
#   si x > 0 { ... } sin x < 0 { ... } secus { ... }
#   si fetch() cape err { handle(err) }
@ publica
functio parseSiSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'si'
    p.expectaVerbum("si", ParserErrorCodice.ExpectaturSi)

    # Parse condition
    fixum condicio = r.expressia()

    # Parse consequent body
    fixum consequens = parseCorpusBrevis(r)

    # Check for optional catch (si expr { } cape err { })
    varia cape = nihil qua CapeClausula?
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    # Check for else/else-if chain
    varia alternans = nihil qua Sententia?

    si p.probaVerbum("sin") {
        alternans = parseSinSententia(r)
    } sin p.probaVerbum("secus") {
        p.procede()
        alternans = parseCorpusBrevis(r)
    }

    redde finge SiSententia {
        locus: locus,
        condicio: condicio,
        consequens: consequens,
        alternans: alternans,
        cape: cape
    } qua Sententia
}

# Parse while statement
#
# GRAMMAR: dumStmt := 'dum' expr blockStmt ('cape' IDENT blockStmt)?
#
# Examples:
#   dum x > 0 { x = x - 1 }
#   dum iter.sequens() cape err { handle(err) }
@ publica
functio parseDumSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'dum'
    p.expectaVerbum("dum", ParserErrorCodice.ExpectaturDum)

    # Parse condition
    fixum condicio = r.expressia()

    # Parse body
    fixum corpus = parseCorpusBrevis(r)

    # Optional catch
    varia cape = nihil qua CapeClausula?
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    redde finge DumSententia {
        locus: locus,
        condicio: condicio,
        corpus: corpus,
        cape: cape
    } qua Sententia
}

# Parse for-of loop (iterate values)
#
# GRAMMAR: exStmt := 'ex' expr 'pro' IDENT blockStmt ('cape' IDENT blockStmt)?
#
# Examples:
#   ex items pro item { scribe item }
#   ex 0 ante 10 pro i { scribe i }
@ publica
functio parseExSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'ex'
    p.expectaVerbum("ex", ParserErrorCodice.ExpectaturEx)

    # Parse iterable expression
    fixum iterabile = r.expressia()

    varia asynca = falsum
    varia expectaPro = verum
    si p.probaVerbum("fiet") {
        asynca = verum
        expectaPro = falsum
        p.procede()
    }

    # Expect 'pro' for sync loops
    si expectaPro {
        p.expectaVerbum("pro", ParserErrorCodice.ExpectaturPro)
    }

    # Parse variable name
    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum variabilis = nomenSym.valor

    # Parse body
    fixum corpus = parseCorpusBrevis(r)

    # Optional catch
    varia cape = nihil qua CapeClausula?
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    redde finge IteratioSententia {
        locus: locus,
        species: IteratioGenus.Ex,
        variabilis: variabilis,
        iterabile: iterabile,
        corpus: corpus,
        asynca: asynca,
        cape: cape
    } qua Sententia
}

# Parse for-in loop (iterate keys)
#
# GRAMMAR: deStmt := 'de' expr 'pro' IDENT blockStmt ('cape' IDENT blockStmt)?
#
# Examples:
#   de obiectum pro clavis { scribe clavis }
@ publica
functio parseDeSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'de'
    p.expectaVerbum("de", ParserErrorCodice.ExpectaturDe)

    # Parse iterable expression
    fixum iterabile = r.expressia()

    # Expect 'pro'
    p.expectaVerbum("pro", ParserErrorCodice.ExpectaturPro)

    # Parse variable name
    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum variabilis = nomenSym.valor

    # Parse body
    fixum corpus = parseCorpusBrevis(r)

    # Optional catch
    varia cape = nihil qua CapeClausula?
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    redde finge IteratioSententia {
        locus: locus,
        species: IteratioGenus.De,
        variabilis: variabilis,
        iterabile: iterabile,
        corpus: corpus,
        asynca: falsum,
        cape: cape
    } qua Sententia
}

# Parse mutation block
#
# GRAMMAR: inStmt := 'in' expr blockStmt
#
# Example: in user { nomen = "Marcus" }
@ publica
functio parseInSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'in'
    p.expectaVerbum("in", ParserErrorCodice.ExpectaturIn)

    # Parse target object
    fixum obiectum = r.expressia()

    # Parse block body
    fixum corpus = parseMassaSententia(r)

    redde finge InSententia {
        locus: locus,
        obiectum: obiectum,
        corpus: corpus
    } qua Sententia
}

# Parse catch clause
#
# GRAMMAR: capeClause := 'cape' IDENT blockStmt
#
# Example: cape err { handle(err) }
@ publica
functio parseCapeClausula(Resolvitor r) -> CapeClausula {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("cape", ParserErrorCodice.ExpectaturCape)

    # Parse error binding name
    fixum paramSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum param = paramSym.valor

    # Parse catch body
    fixum corpus = parseMassaSententia(r)

    redde {
        locus: locus,
        param: param,
        corpus: corpus
    } qua CapeClausula
}

# Parse a block or short-form body
@ publica
functio parseCorpusBrevis(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    si p.probaVerbum("ergo") {
        p.procede()
        redde r.sententia()
    }

    si p.probaVerbum("reddit") {
        p.procede()
        fixum valor = r.expressia()
        redde finge ReddeSententia {
            locus: locus,
            valor: valor
        } qua Sententia
    }

    # Short-form block: fac ... fine
    si p.probaVerbum("fac") {
        p.procede()
        varia corpus = [] qua lista<Sententia>

        dum non p.estFinis() {
            fixum s = p.specta(0)
            si (s.species == SymbolumGenus.Verbum et s.verbum == "fine") aut (s.species == SymbolumGenus.Nomen et s.valor == "fine") {
                p.procede()
                redde finge MassaSententia {
                    locus: locus,
                    corpus: corpus
                } qua Sententia
            }

            corpus.adde(r.sententia())
        }

        # Fallback: unterminated short block
        redde finge MassaSententia {
            locus: locus,
            corpus: corpus
        } qua Sententia
    }

    redde parseMassaSententia(r)
}

# Parse a "sin" (else-if) clause
@ publica
functio parseSinSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("sin", ParserErrorCodice.ExpectaturSi)

    fixum condicio = r.expressia()
    fixum consequens = parseCorpusBrevis(r)

    varia alternans = nihil qua Sententia?
    si p.probaVerbum("sin") {
        alternans = parseSinSententia(r)
    } sin p.probaVerbum("secus") {
        p.procede()
        alternans = parseCorpusBrevis(r)
    }

    redde finge SiSententia {
        locus: locus,
        condicio: condicio,
        consequens: consequens,
        alternans: alternans,
        cape: nihil
    } qua Sententia
}
