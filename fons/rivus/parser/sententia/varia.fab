# Variable Declaration Parsers
#
# Variable declarations, destructuring patterns, and related constructs.
#
# GRAMMAR:
#   varDecl := ('varia' | 'fixum' | 'figendum' | 'variandum') typeAnnotation? IDENTIFIER ('=' expression)?
#   arrayPattern := '[' arrayPatternElement (',' arrayPatternElement)* ']'
#   objectPattern := '{' patternProperty (',' patternProperty)* '}'
#
# LATIN VOCABULARY:
# - varia = variable (let it vary)
# - fixum = fixed (const)
# - figendum = to be fixed (const + await)
# - variandum = to be varied (let + await)
# - ceteri = the rest (rest pattern)
# - omissum = omitted/skipped (placeholder _)

ex "../resolvitor" importa Resolvitor
ex "../../ast/positio" importa Locus
ex "../../ast/expressia" importa Expressia
ex "../../ast/sententia" importa Sententia, VariaGenus, ImportaSpecificator
ex "../../ast/sententia" importa SeriesDestructuraElementum
ex "../../ast/typus" importa TypusAnnotatio
ex "../../ast/lexema" importa SymbolumGenus
ex "../errores" importa ParserErrorCodice

# Parse an identifier (simple name reference)
@ publica
functio parseNomen(Resolvitor r) -> textus {
    fixum p = r.parser()
    fixum symbolum = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    redde symbolum.valor
}

# Parse identifier or keyword (for import specifiers, property names)
# Keywords like 'scribe' can be valid identifiers in some contexts
@ publica
functio parseNomenVelVerbum(Resolvitor r) -> textus {
    fixum p = r.parser()
    fixum s = p.specta(0)

    si s.species === SymbolumGenus.Nomen aut s.species === SymbolumGenus.Verbum {
        p.procede()
        redde s.valor
    }

    # Error: expected identifier
    p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("got 'ยง'", s.valor))
    p.procede()
    redde s.valor
}

# Parse destructure declaration
#
# GRAMMAR: destruct := 'ex' expr (fixum|varia|figendum|variandum) spec (',' spec)*
# spec := IDENT ('ut' IDENT)? | 'ceteri' IDENT
@ publica
functio parseDestructuraSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("ex", ParserErrorCodice.ExpectaturEx)
    fixum fons = r.expressia()

    # Binding kind
    fixum verbum = p.specta(0).verbum
    varia species = VariaGenus.Fixum
    elige verbum {
        casu "fixum" { species = VariaGenus.Fixum }
        casu "varia" { species = VariaGenus.Varia }
        casu "figendum" { species = VariaGenus.Figendum }
        casu "variandum" { species = VariaGenus.Variandum }
    }
    p.procede()

    varia specificatores = [] qua lista<ImportaSpecificator>

    fac {
        fixum specLocus = p.locusActualis()

        varia residuum = falsum
        si p.probaVerbum("ceteri") {
            residuum = verum
            p.procede()
        }

        fixum importatum = parseNomenVelVerbum(r)
        varia locale = importatum

        si p.probaVerbum("ut") {
            p.procede()
            locale = parseNomenVelVerbum(r)
        }

        specificatores.adde({
            locus: specLocus,
            importatum: importatum,
            locale: locale,
            residuum: residuum
        } qua ImportaSpecificator)

    } dum p.congruet(SymbolumGenus.Coma)

    redde finge DestructuraSententia {
        locus: locus,
        fons: fons,
        species: species,
        specificatores: specificatores
    } qua Sententia
}

# Parse array destructuring pattern: [a, b, ceteri rest]
@ publica
functio parseSeriesDestructura(Resolvitor r) -> lista<SeriesDestructuraElementum> {
    fixum p = r.parser()

    p.expecta(SymbolumGenus.QuadratusSin, ParserErrorCodice.ExpectaturQuadratusSin)

    varia elementa = [] qua lista<SeriesDestructuraElementum>
    si non p.proba(SymbolumGenus.QuadratusDex) {
        fac {
            fixum locus = p.locusActualis()
            varia residuum = falsum
            varia omissum = falsum
            varia nomen = nihil qua textus?

            si p.probaVerbum("ceteri") {
                residuum = verum
                p.procede()
            }

            fixum s = p.specta(0)
            si s.species === SymbolumGenus.Nomen aut s.species === SymbolumGenus.Verbum {
                p.procede()
                si s.valor == "_" {
                    omissum = verum
                } secus {
                    nomen = s.valor
                }
            } secus {
                p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("got 'ยง'", s.valor))
                p.procede()
            }

            elementa.adde({
                locus: locus,
                nomen: nomen,
                residuum: residuum,
                omissum: omissum
            } qua SeriesDestructuraElementum)
        } dum p.congruet(SymbolumGenus.Coma)
    }

    p.expecta(SymbolumGenus.QuadratusDex, ParserErrorCodice.ExpectaturQuadratusDex)

    redde elementa
}

# Parse variable declaration
#
# GRAMMAR: varDecl := ('varia'|'fixum'|'figendum'|'variandum') type? name ('=' expr)?
#
# Supports:
# - Type inference: fixum x = 42
# - Type-first: fixum numerus x = 42
# - Array destructuring: fixum [a, b] = coords (TODO)
@ publica
functio parseVariaSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Get declaration kind from keyword
    fixum verbum = p.specta(0).verbum
    varia species = VariaGenus.Varia

    elige verbum {
        casu "varia" { species = VariaGenus.Varia }
        casu "fixum" { species = VariaGenus.Fixum }
        casu "figendum" { species = VariaGenus.Figendum }
        casu "variandum" { species = VariaGenus.Variandum }
    }

    # Consume the keyword
    p.procede()

    # -------------------------------------------------------------------------
    # Array destructuring: fixum [a, b] = coords
    # -------------------------------------------------------------------------
    si p.proba(SymbolumGenus.QuadratusSin) {
        fixum elementa = parseSeriesDestructura(r)
        p.expecta(SymbolumGenus.Aequum, ParserErrorCodice.ExpectaturAequale)
        fixum fons = r.expressia()
        redde finge SeriesDestructuraSententia {
            locus: locus,
            species: species,
            elementa: elementa,
            fons: fons
        } qua Sententia
    }

    # -------------------------------------------------------------------------
    # Determine what follows: type or name
    # -------------------------------------------------------------------------
    varia adnotatio = nihil qua TypusAnnotatio?
    varia nomen = ""

    si p.estTypusNomen(p.specta(0)) {
        # Builtin type: fixum numerus x = 42
        adnotatio = r.adnotatio()
        nomen = parseNomenVelVerbum(r)
    } sin p.proba(SymbolumGenus.Nomen) et p.specta(1).species === SymbolumGenus.Nomen {
        # Two identifiers: first is type, second is name
        # Handles user-defined types: fixum UserId id = 42
        adnotatio = r.adnotatio()
        nomen = parseNomenVelVerbum(r)
    } secus {
        # Just a name (type inference): fixum x = 42
        nomen = parseNomenVelVerbum(r)
    }

    # -------------------------------------------------------------------------
    # Parse optional initializer
    # -------------------------------------------------------------------------
    varia valor = nihil qua Expressia?

    si p.congruet(SymbolumGenus.Aequum) {
        valor = r.expressia()
    }

    redde finge VariaSententia {
        locus: locus,
        species: species,
        nomen: nomen,
        typus: adnotatio,
        valor: valor,
        externa: falsum
    } qua Sententia
}
