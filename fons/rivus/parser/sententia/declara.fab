# Declaration Statement Parsers
#
# Handles: functio, genus, pactum, ordo, discretio, typus, importa
#
# GRAMMAR:
#   functioDecl := 'functio' IDENT '(' params? ')' returnType? blockStmt
#   genusDecl := 'genus' IDENT genericParams? ('sub' IDENT)? ('implet' IDENT+)? '{' members '}'
#   pactumDecl := 'pactum' IDENT genericParams? '{' methods '}'
#   ordoDecl := 'ordo' IDENT '{' members '}'
#   discretioDecl := 'discretio' IDENT genericParams? '{' variants '}'
#   typusDecl := 'typus' IDENT '=' type
#   importaDecl := 'ex' STRING 'importa' specifiers
#
# LATIN VOCABULARY:
# - functio = function
# - genus = kind/class/struct
# - pactum = agreement/interface
# - ordo = order/enum
# - discretio = distinction/tagged union
# - typus = type alias
# - importa = import

ex "../resolvitor" importa Resolvitor
ex "../../ast/positio" importa Locus
ex "../../ast/expressia" importa Expressia
ex "../../ast/sententia" importa Sententia, Parametrum, TypusParametrum, CampusDeclaratio, PactumMethodus, OrdoMembrum, VariansDeclaratio, VariansCampus, Visibilitas, ReddeVerbum, ImportaSpecificator, MorphologiaDeclaratio
ex "../../ast/typus" importa TypusAnnotatio, typusSimplicis
ex "../../ast/lexema" importa SymbolumGenus, VerbumId
ex "../errores" importa ParserErrorCodice
ex "./massa" importa parseMassaSententia
ex "./varia" importa parseNomenVelVerbum
ex "./annotatio" importa Annotatio, parseAnnotationes

# ============================================================================
# FUNCTION DECLARATIONS
# ============================================================================

# Parse function declaration
#
# GRAMMAR:
#   functioDecl := 'functio' IDENT genericParams? '(' params? ')' returnType? blockStmt?
#   returnType := '->' type | 'fit' type | 'fiet' type | 'fiunt' type | 'fient' type
#
# Examples:
#   functio salve() { scribe "hello" }
#   functio add(numerus a, numerus b) -> numerus { redde a + b }
#   functio greet(textus name) fit textus { redde scriptum("Hello, §!", name) }
@ publica
functio parseFunctioDeclaratio(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'functio'
    p.expectaVerbum("functio", ParserErrorCodice.ExpectaturFunctio)

    # Parse function name
    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum nomen = nomenSym.valor

    # Optional generic parameters: either `prae typus T, U` or `<T, U>`
    varia generaParametra = nihil qua lista<TypusParametrum>?
    si p.probaVerbum("prae") {
        generaParametra = parseTypusParametra(r)
    } sin p.congruet(SymbolumGenus.Minor) {
        fixum nomina = parseGenericaNomina(r)
        generaParametra = [] innatum lista<TypusParametrum>
        ex nomina pro n {
            generaParametra.adde({ locus: locus, nomen: n } qua TypusParametrum)
        }
    }

    # Parse parameters
    p.expecta(SymbolumGenus.ParensSin, ParserErrorCodice.ExpectaturParensSin)
    fixum parametra = parseParametra(r)
    p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)

    # Parse return type
    varia typusReditus = nihil qua TypusAnnotatio?
    varia asynca = falsum
    varia generator = falsum
    varia reddeVerbum = nihil qua ReddeVerbum?

    si p.congruet(SymbolumGenus.Sagitta) {
        reddeVerbum = ReddeVerbum.Sagitta
        typusReditus = r.adnotatio()
    } sin p.congruetVerbumId(VerbumId.Fit) {
        reddeVerbum = ReddeVerbum.Fit
        typusReditus = r.adnotatio()
    } sin p.congruetVerbumId(VerbumId.Fiet) {
        reddeVerbum = ReddeVerbum.Fiet
        asynca = verum
        typusReditus = r.adnotatio()
    } sin p.congruetVerbumId(VerbumId.Fiunt) {
        reddeVerbum = ReddeVerbum.Fiunt
        generator = verum
        typusReditus = r.adnotatio()
    } sin p.congruetVerbumId(VerbumId.Fient) {
        reddeVerbum = ReddeVerbum.Fient
        asynca = verum
        generator = verum
        typusReditus = r.adnotatio()
    }

    # Parse body (optional for @ externa declarations)
    # WHY: Body is optional for @ externa declarations (external functions have no body)
    # If no opening brace, function has no body (validated in semantic phase)
    varia corpus = nihil qua Sententia?
    si p.proba(SymbolumGenus.UncusSin) {
        corpus = parseMassaSententia(r)
    }

    redde finge FunctioDeclaratio {
        locus: locus,
        nomen: nomen,
        generaParametra: generaParametra,
        parametra: parametra,
        typusReditus: typusReditus,
        corpus: corpus,
        asynca: asynca,
        generator: generator,
        abstracta: falsum,
        structor: falsum,
        externa: falsum,
        visibilitas: nihil,
        reddeVerbum: reddeVerbum,
        morphologia: nihil
    } qua Sententia
}

# ============================================================================
# GENUS (CLASS/STRUCT) DECLARATIONS
# ============================================================================

# Parse genus (class/struct) declaration
#
# GRAMMAR:
#   genusDecl := 'genus' IDENT genericParams? ('sub' IDENT)? ('implet' IDENT+)? '{' members '}'
#
# Examples:
#   genus Persona { textus nomen, numerus aetas }
#   genus Cursor<T> { varia index = 0 }
#   genus Admin sub Persona implet Serializable { ... }
@ publica
functio parseGenusDeclaratio(Resolvitor r, bivalens abstractum) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'genus'
    p.expectaVerbum("genus", ParserErrorCodice.ExpectaturGenus)

    # Parse name
    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum nomen = nomenSym.valor

    # Optional generic parameters
    varia generaParametra = nihil qua lista<textus>?
    si p.congruet(SymbolumGenus.Minor) {
        generaParametra = parseGenericaNomina(r)
    }

    # Optional extends
    varia extendit = nihil qua textus?
    si p.congruetVerbum("sub") {
        fixum parentSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
        extendit = parentSym.valor
    }

    # Optional implements
    varia implet = nihil qua lista<textus>?
    si p.congruetVerbum("implet") {
        implet = [] innatum lista<textus>
        fac {
            fixum ifaceSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
            implet.adde(ifaceSym.valor)
        } dum p.congruet(SymbolumGenus.Coma)
    }

    # Parse body
    p.expecta(SymbolumGenus.UncusSin, ParserErrorCodice.ExpectaturUncusSin)

    varia campi = [] innatum lista<CampusDeclaratio>
    varia methodi = [] innatum lista<Sententia>
    varia structor = nihil qua Sententia?

    dum non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
        # Parse annotations for visibility/abstract/morphologia
        fixum annotationes = parseAnnotationes(r)

        # Parse visibility modifier
        varia visibilitas = Visibilitas.Privata
        varia visibilitasExplicita = falsum
        ex annotationes pro a {
            si a.nomen inter ["publicum", "publica", "publicus"] {
                visibilitas = Visibilitas.Publica
                visibilitasExplicita = verum
            } sin a.nomen inter ["protectum", "protecta", "protectus"] {
                visibilitas = Visibilitas.Protecta
                visibilitasExplicita = verum
            } sin a.nomen inter ["privatum", "privata", "privatus"] {
                visibilitas = Visibilitas.Privata
                visibilitasExplicita = verum
            }
        }
        si p.congruetVerbum("publicus") {
            visibilitas = Visibilitas.Publica
            visibilitasExplicita = verum
        } sin p.congruetVerbum("privatus") {
            visibilitas = Visibilitas.Privata
            visibilitasExplicita = verum
        } sin p.congruetVerbum("protectus") {
            visibilitas = Visibilitas.Protecta
            visibilitasExplicita = verum
        }

        # Check for static modifier
        varia staticum = falsum
        si p.congruetVerbum("generis") {
            staticum = verum
        }

        # Check for reactive modifier
        varia reactivum = falsum
        si p.congruetVerbum("nexum") {
            reactivum = verum
        }

        # Check if this is a method or field
        si p.probaVerbum("functio") {
            si non visibilitasExplicita {
                visibilitas = Visibilitas.Publica
            }
            # WHY: Methods use full functio syntax but remain inside genus.
            p.procede()
            fixum methodLocus = p.locusActualis()
            fixum methodNomen = parseNomenVelVerbum(r)

            p.expecta(SymbolumGenus.ParensSin, ParserErrorCodice.ExpectaturParensSin)
            fixum params = parseParametra(r)
            p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)

            varia retTypus = nihil qua TypusAnnotatio?
            varia asynca = falsum
            varia generator = falsum

            si p.congruet(SymbolumGenus.Sagitta) {
                retTypus = r.adnotatio()
            } sin p.congruetVerbumId(VerbumId.Fit) {
                retTypus = r.adnotatio()
            } sin p.congruetVerbumId(VerbumId.Fiet) {
                asynca = verum
                retTypus = r.adnotatio()
            } sin p.congruetVerbumId(VerbumId.Fiunt) {
                generator = verum
                retTypus = r.adnotatio()
            } sin p.congruetVerbumId(VerbumId.Fient) {
                asynca = verum
                generator = verum
                retTypus = r.adnotatio()
            }

            varia body = nihil qua Sententia?
            si p.proba(SymbolumGenus.UncusSin) {
                # WHY: Abstract methods omit bodies inside abstract genera.
                body = parseMassaSententia(r)
            }

            varia estStructor = methodNomen == "creo"
            varia abstracta = falsum
            ex annotationes pro a {
                si a.nomen inter ["abstractum", "abstracta", "abstractus"] {
                    abstracta = verum
                }
            }
            si estStructor {
                visibilitas = Visibilitas.Privata
            }

            methodi.adde(finge FunctioDeclaratio {
                locus: methodLocus,
                nomen: methodNomen,
                generaParametra: nihil,
                parametra: params,
                typusReditus: retTypus,
                corpus: body,
                asynca: asynca,
                generator: generator,
                abstracta: abstracta,
                structor: estStructor,
                externa: falsum,
                visibilitas: visibilitas,
                reddeVerbum: nihil,
                morphologia: morphologiaEx(annotationes)
            } qua Sententia)
        } secus {
            # Field: type name or name: default
            fixum campusLocus = p.locusActualis()
            fixum typusAnnotatio = r.adnotatio()
            fixum campusNomen = parseNomenVelVerbum(r)

            varia valor = nihil qua Expressia?
            si p.congruet(SymbolumGenus.Colon) {
                valor = r.expressia()
            }

            campi.adde({
                locus: campusLocus,
                nomen: campusNomen,
                typus: typusAnnotatio,
                valor: valor,
                visibilitas: visibilitas,
                staticum: staticum,
                reactivum: reactivum
            } qua CampusDeclaratio)
        }

        # Optional comma/semicolon between members
        p.congruet(SymbolumGenus.Coma)
        p.congruet(SymbolumGenus.PunctumColon)
    }

    p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)

    redde finge GenusDeclaratio {
        locus: locus,
        nomen: nomen,
        generaParametra: generaParametra,
        extendit: extendit,
        implet: implet,
        abstractum: abstractum,
        campi: campi,
        structor: structor,
        methodi: methodi,
        morphologia: nihil
    } qua Sententia
}

# ============================================================================
# PACTUM (INTERFACE) DECLARATIONS
# ============================================================================

# Parse pactum (interface) declaration
#
# GRAMMAR: pactumDecl := 'pactum' IDENT genericParams? '{' methods '}'
#
# Examples:
#   pactum Iterabilis { functio sequens() fit T? }
#   pactum Comparabilis<T> { functio compara(T alius) fit numerus }
@ publica
functio parsePactumDeclaratio(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'pactum'
    p.expectaVerbum("pactum", ParserErrorCodice.ExpectaturPactum)

    # Parse name
    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum nomen = nomenSym.valor

    # Optional generic parameters
    varia generaParametra = nihil qua lista<textus>?
    si p.congruet(SymbolumGenus.Minor) {
        generaParametra = parseGenericaNomina(r)
    }

    # Parse body
    p.expecta(SymbolumGenus.UncusSin, ParserErrorCodice.ExpectaturUncusSin)

    varia methodi = [] innatum lista<PactumMethodus>

    dum non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
        # Optional annotations (e.g., @ futura, @ radix)
        fixum annotationes = parseAnnotationes(r)

        # Each method: functio name(params) returnType
        p.expectaVerbum("functio", ParserErrorCodice.ExpectaturFunctio)

        fixum methodLocus = p.praevius().locus
        fixum methodNomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
        fixum methodNomen = methodNomenSym.valor

        p.expecta(SymbolumGenus.ParensSin, ParserErrorCodice.ExpectaturParensSin)
        fixum params = parseParametra(r)
        p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)

        varia typusReditus = nihil qua TypusAnnotatio?
        varia asynca = falsum
        varia generator = falsum

        si p.congruet(SymbolumGenus.Sagitta) aut p.congruetVerbumId(VerbumId.Fit) {
            typusReditus = r.adnotatio()
        } sin p.congruetVerbumId(VerbumId.Fiet) {
            asynca = verum
            typusReditus = r.adnotatio()
        } sin p.congruetVerbumId(VerbumId.Fiunt) {
            generator = verum
            typusReditus = r.adnotatio()
        } sin p.congruetVerbumId(VerbumId.Fient) {
            asynca = verum
            generator = verum
            typusReditus = r.adnotatio()
        }

        ex annotationes pro a {
            si a.nomen == "futura" {
                asynca = verum
            }
        }

        methodi.adde({
            locus: methodLocus,
            nomen: methodNomen,
            parametra: params,
            typusReditus: typusReditus,
            asynca: asynca,
            generator: generator,
            morphologia: morphologiaEx(annotationes)
        } qua PactumMethodus)

        # Optional separator
        p.congruet(SymbolumGenus.Coma)
        p.congruet(SymbolumGenus.PunctumColon)
    }

    p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)

    redde finge PactumDeclaratio {
        locus: locus,
        nomen: nomen,
        generaParametra: generaParametra,
        methodi: methodi
    } qua Sententia
}

# ============================================================================
# ORDO (ENUM) AND DISCRETIO (TAGGED UNION) DECLARATIONS
# ============================================================================

# Parse ordo (enum) declaration
#
# GRAMMAR: ordoDecl := 'ordo' IDENT '{' (IDENT ('=' value)?)* '}'
#
# Examples:
#   ordo Color { Rubrum, Viridis, Caeruleum }
#   ordo Status { Pendens = 0, Actum = 1, Completum = 2 }
@ publica
functio parseOrdoDeclaratio(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'ordo'
    p.expectaVerbum("ordo", ParserErrorCodice.ExpectaturOrdo)

    # Parse name
    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum nomen = nomenSym.valor

    # Parse body
    p.expecta(SymbolumGenus.UncusSin, ParserErrorCodice.ExpectaturUncusSin)

    varia membra = [] innatum lista<OrdoMembrum>

    dum non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
        fixum membrumLocus = p.locusActualis()
        fixum membrumNomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
        fixum membrumNomen = membrumNomenSym.valor

        varia valor = nihil qua textus?
        si p.congruet(SymbolumGenus.Aequum) {
            # Parse value (number or string)
            si p.congruet(SymbolumGenus.Minus) {
                # Negative numeric literal
                fixum valorSym = p.procede()
                valor = scriptum("-§", valorSym.valor)
            } secus {
                fixum valorSym = p.procede()
                si valorSym.species === SymbolumGenus.Textus {
                    valor = scriptum("\"§\"", valorSym.valor)
                } secus {
                    valor = valorSym.valor
                }
            }
        }

        membra.adde({
            locus: membrumLocus,
            nomen: membrumNomen,
            valor: valor
        } qua OrdoMembrum)

        # Optional comma
        p.congruet(SymbolumGenus.Coma)
    }

    p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)

    redde finge OrdoDeclaratio {
        locus: locus,
        nomen: nomen,
        membra: membra
    } qua Sententia
}

# Parse discretio (tagged union) declaration
#
# GRAMMAR: discretioDecl := 'discretio' IDENT genericParams? '{' variants '}'
#
# Examples:
#   discretio Option<T> { Aliquid { T valor }, Nihil }
#   discretio Event { Click { numerus x, numerus y }, Quit }
@ publica
functio parseDiscretioDeclaratio(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'discretio'
    p.expectaVerbum("discretio", ParserErrorCodice.ExpectaturDiscretio)

    # Parse name
    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum nomen = nomenSym.valor

    # Optional generic parameters
    varia generaParametra = nihil qua lista<textus>?
    si p.congruet(SymbolumGenus.Minor) {
        generaParametra = parseGenericaNomina(r)
    }

    # Parse body
    p.expecta(SymbolumGenus.UncusSin, ParserErrorCodice.ExpectaturUncusSin)

    varia variantes = [] innatum lista<VariansDeclaratio>

    dum non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
        fixum variansLocus = p.locusActualis()
        fixum variansNomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
        fixum variansNomen = variansNomenSym.valor

        varia campi = [] innatum lista<VariansCampus>

        # Optional fields in braces or parens
        si p.congruet(SymbolumGenus.UncusSin) {
            dum non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
                fixum campusLocus = p.locusActualis()
                fixum campusTypus = r.adnotatio()

                # EDGE: Allow keywords as field names in compiler-internal ASTs.
                #       Example: `TypusAnnotatio? typus`, `CapeClausula? cape`.
                fixum campusNomenSym = p.specta(0)
                varia campusNomen = ""
                si campusNomenSym.species == SymbolumGenus.Nomen aut campusNomenSym.species == SymbolumGenus.Verbum {
                    p.procede()
                    campusNomen = campusNomenSym.valor
                } secus {
                    p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("got '§'", campusNomenSym.valor))
                    p.procede()
                    campusNomen = campusNomenSym.valor
                }

                campi.adde({
                    locus: campusLocus,
                    nomen: campusNomen,
                    typus: campusTypus
                } qua VariansCampus)

                p.congruet(SymbolumGenus.Coma)
            }
            p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)
        } sin p.congruet(SymbolumGenus.ParensSin) {
            varia index = 1
            si non p.proba(SymbolumGenus.ParensDex) {
                fac {
                    fixum campusLocus = p.locusActualis()
                    fixum campusTypus = r.adnotatio()
                    fixum campusNomen = index == 1 sic "value" secus scriptum("value§", index)
                    index += 1
                    campi.adde({
                        locus: campusLocus,
                        nomen: campusNomen,
                        typus: campusTypus
                    } qua VariansCampus)
                } dum p.congruet(SymbolumGenus.Coma)
            }
            p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)
        }

        variantes.adde({
            locus: variansLocus,
            nomen: variansNomen,
            campi: campi
        } qua VariansDeclaratio)

        # Optional comma between variants
        p.congruet(SymbolumGenus.Coma)
    }

    p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)

    redde finge DiscretioDeclaratio {
        locus: locus,
        nomen: nomen,
        generaParametra: generaParametra,
        variantes: variantes
    } qua Sententia
}

# ============================================================================
# TYPE ALIAS DECLARATIONS
# ============================================================================

# Parse type alias declaration
#
# GRAMMAR: typusDecl := 'typus' IDENT '=' type
#
# Examples:
#   typus ID = textus
#   typus Callback = functio(numerus) -> vacuum
@ publica
functio parseTypusAliasDeclaratio(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'typus'
    p.expectaVerbum("typus", ParserErrorCodice.ExpectaturTypus)

    # Parse name
    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum nomen = nomenSym.valor

    # Expect '='
    p.expecta(SymbolumGenus.Aequum, ParserErrorCodice.ExpectaturAequale)

    # Parse type (or typeof alias)
    varia scopusNomen = nihil qua textus?
    varia typusAlias = nihil qua TypusAnnotatio?

    si p.probaVerbum("typus") {
        p.procede()
        fixum scopusSym = p.specta(0)
        si scopusSym.species == SymbolumGenus.Nomen aut scopusSym.species == SymbolumGenus.Verbum {
            p.procede()
            scopusNomen = scopusSym.valor
            typusAlias = typusSimplicis("ignotum", locus)
        } secus {
            p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("got '§'", scopusSym.valor))
            p.procede()
            typusAlias = typusSimplicis("ignotum", locus)
        }
    } secus {
        typusAlias = r.adnotatio()
    }

    redde finge TypusAliasDeclaratio {
        locus: locus,
        nomen: nomen,
        typus: typusAlias,
        scopusNomen: scopusNomen
    } qua Sententia
}

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

functio morphologiaEx(lista<Annotatio> annotationes) -> MorphologiaDeclaratio? {
    ex annotationes pro a {
        si a.nomen == "radix" {
            redde { locus: a.locus, formae: a.argumenta } qua MorphologiaDeclaratio
        }
    }
    redde nihil
}

# Parse function parameters
@ publica
functio parseParametra(Resolvitor r) -> lista<Parametrum> {
    fixum p = r.parser()
    varia parametra = [] innatum lista<Parametrum>

    si p.proba(SymbolumGenus.ParensDex) {
        redde parametra
    }

    fac {
        fixum paramLocus = p.locusActualis()

        # Check for preposition (de, in, ex)
        varia praepositio = nihil qua textus?
        si p.estPraepositio(p.specta(0)) {
            praepositio = p.procede().verbum
        }

        # Optional parameter marker
        varia optionalis = falsum
        si p.probaVerbum("si") {
            optionalis = verum
            p.procede()
        }

        # Check for rest parameter
        varia residuum = falsum
        si p.probaVerbum("ceteri") {
            residuum = verum
            p.procede()
        }

        # Parse type (optional if no type annotation)
        varia paramTypus = nihil qua TypusAnnotatio?
        si p.estTypusNomen(p.specta(0)) {
            paramTypus = r.adnotatio()
        } sin p.proba(SymbolumGenus.Verbum) et p.specta(1).species == SymbolumGenus.Nomen {
            paramTypus = r.adnotatio()
        } sin p.proba(SymbolumGenus.Nomen) et (
            p.specta(1).species == SymbolumGenus.Nomen aut
            p.specta(1).species == SymbolumGenus.Minor aut
            p.specta(1).species == SymbolumGenus.QuadratusSin aut
            p.specta(1).species == SymbolumGenus.Rogatio
        ) {
            # User-defined type (Point, Point[], Point?, Point<T>)
            paramTypus = r.adnotatio()
        }

        # Parse name (keywords like `page` allowed)
        fixum nomen = parseNomenVelVerbum(r)

        # Optional alias: ut alias
        varia paramAlias = nihil qua textus?
        si p.probaVerbum("ut") {
            p.procede()
            paramAlias = parseNomenVelVerbum(r)
        }

        # Optional default: vel value
        varia praedefinitum = nihil qua Expressia?
        si p.probaVerbum("vel") {
            p.procede()
            praedefinitum = r.expressia()
        } sin p.congruet(SymbolumGenus.Colon) {
            # LEGACY: `textus name: "World"` style defaults
            praedefinitum = r.expressia()
        }

        parametra.adde({
            locus: paramLocus,
            nomen: nomen,
            alias: paramAlias,
            typus: paramTypus,
            praedefinitum: praedefinitum,
            praepositio: praepositio,
            optionalis: optionalis,
            residuum: residuum
        } qua Parametrum)

    } dum p.congruet(SymbolumGenus.Coma)

    redde parametra
}

# Parse compile-time type parameters (prae typus T, U)
@ publica
functio parseTypusParametra(Resolvitor r) -> lista<TypusParametrum> {
    fixum p = r.parser()
    varia parametra = [] innatum lista<TypusParametrum>

    # Already consumed 'prae', expect 'typus'
    p.expectaVerbum("typus", ParserErrorCodice.ExpectaturTypus)

    fac {
        fixum paramLocus = p.locusActualis()
        fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)

        parametra.adde({
            locus: paramLocus,
            nomen: nomenSym.valor
        } qua TypusParametrum)
    } dum p.congruet(SymbolumGenus.Coma)

    redde parametra
}

# Parse generic type names in angle brackets: <T, U>
@ publica
functio parseGenericaNomina(Resolvitor r) -> lista<textus> {
    fixum p = r.parser()
    varia nomina = [] innatum lista<textus>

    # Already consumed '<'
    fac {
        fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
        nomina.adde(nomenSym.valor)
    } dum p.congruet(SymbolumGenus.Coma)

    p.expecta(SymbolumGenus.Maior, ParserErrorCodice.ExpectaturAngulusDex)

    redde nomina
}

# ============================================================================
# IMPORT DECLARATIONS
# ============================================================================

# Parse import declaration
#
# GRAMMAR:
#   importaDecl := 'ex' (STRING | IDENT) 'importa' specifiers
#   specifiers := specifier (',' specifier)*
#   specifier := IDENT ('ut' IDENT)?
#              | '*' ('ut' IDENT)?
#              | 'ceteri' IDENT
#
# Examples:
#   ex "norma/mathesis" importa sinus, cosinus
#   ex norma importa scribe ut s
#   ex "./utils" importa * ut utils
@ publica
functio parseImportaSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'ex'
    p.expectaVerbum("ex", ParserErrorCodice.ExpectaturEx)

    # Parse source (string or identifier for norma modules)
    varia fons = ""
    si p.proba(SymbolumGenus.Textus) {
        fixum fonsSym = p.procede()
        fons = fonsSym.valor
    } secus {
        fixum fonsSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
        fons = fonsSym.valor
    }

    # Expect 'importa'
    p.expectaVerbum("importa", ParserErrorCodice.ExpectaturImporta)

    # Check for wildcard import: * or * ut alias
    varia totum = falsum
    varia totumAlias = nihil qua textus?
    varia specificatores = [] innatum lista<ImportaSpecificator>

    si p.congruet(SymbolumGenus.Stella) {
        totum = verum
        si p.probaVerbum("ut") {
            p.procede()
            fixum aliasSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
            totumAlias = aliasSym.valor
        }
    } secus {
        # Parse named specifiers
        fac {
            fixum specLocus = p.locusActualis()

            fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
            fixum importatum = nomenSym.valor
            varia locale = importatum

            # Optional alias: ut localName
            si p.probaVerbum("ut") {
                p.procede()
                fixum aliasSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
                locale = aliasSym.valor
            }

            specificatores.adde({
                locus: specLocus,
                importatum: importatum,
                locale: locale,
                residuum: falsum
            } qua ImportaSpecificator)

        } dum p.congruet(SymbolumGenus.Coma)
    }

    redde finge ImportaSententia {
        locus: locus,
        fons: fons,
        specificatores: specificatores,
        totum: totum,
        totumAlias: totumAlias
    } qua Sententia
}
