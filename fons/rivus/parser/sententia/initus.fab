# Entry Point and Resource Management Parsers
#
# Handles: incipit/incipiet (entry points), cura (resource management), ad (dispatch)
#
# GRAMMAR:
#   incipitStmt := 'incipit' (block | 'ergo' stmt)
#   incipietStmt := 'incipiet' (block | 'ergo' stmt)
#   curaStmt := 'cura' curatorKind? expr? ('pro'|'fit'|'fiet') type? IDENT block ('cape' IDENT block)?
#   adStmt := 'ad' STRING '(' args ')' binding? block? ('cape' IDENT block)?
#
# LATIN VOCABULARY:
# - incipit = it begins (present tense - sync)
# - incipiet = it will begin (future tense - async)
# - cura = care (imperative of curare)
# - ad = to/toward (preposition for dispatch)

ex "../resolvitor" importa Resolvitor
ex "../../ast/positio" importa Locus
ex "../../ast/expressia" importa Expressia
ex "../../ast/sententia" importa Sententia, CapeClausula, CuratorGenus, AdVinculum, AdVerbumVinculandi
ex "../../ast/typus" importa TypusAnnotatio
ex "../../ast/lexema" importa SymbolumGenus
ex "../errores" importa ParserErrorCodice
ex "./massa" importa parseMassaSententia

# Parse incipit (sync entry point) statement
#
# GRAMMAR:
#   incipitStmt := 'incipit' (block | 'ergo' stmt)
#
# Examples:
#   incipit { scribe "Hello" }
#   incipit ergo cura arena { ... }
#   incipit ergo runMain()
@ publica
functio parseIncipitSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'incipit'
    p.expectaVerbum("incipit", ParserErrorCodice.ExpectaturIncipit)

    # Check for ergo form
    si p.probaVerbum("ergo") {
        p.procede()
        fixum ergo = r.sententia()
        redde finge IncipitSententia {
            locus: locus,
            corpus: nihil,
            ergo: ergo
        } qua Sententia
    }

    # Block form
    fixum corpus = parseMassaSententia(r)

    redde finge IncipitSententia {
        locus: locus,
        corpus: corpus,
        ergo: nihil
    } qua Sententia
}

# Parse incipiet (async entry point) statement
#
# GRAMMAR:
#   incipietStmt := 'incipiet' (block | 'ergo' stmt)
#
# Examples:
#   incipiet { cede fetchData() }
#   incipiet ergo cura arena { cede fetch() }
@ publica
functio parseIncipietSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'incipiet'
    p.expectaVerbum("incipiet", ParserErrorCodice.ExpectaturIncipiet)

    # Check for ergo form
    si p.probaVerbum("ergo") {
        p.procede()
        fixum ergo = r.sententia()
        redde finge IncipietSententia {
            locus: locus,
            corpus: nihil,
            ergo: ergo
        } qua Sententia
    }

    # Block form
    fixum corpus = parseMassaSententia(r)

    redde finge IncipietSententia {
        locus: locus,
        corpus: corpus,
        ergo: nihil
    } qua Sententia
}

# Parse cura (resource management) statement
#
# GRAMMAR:
#   curaStmt := 'cura' curatorKind? expr? ('pro'|'fit'|'fiet') type? IDENT block ('cape' ...)?
#   curatorKind := 'arena' | 'pagina'
#
# Examples:
#   cura arena fit mem { ... }
#   cura aperi("file.txt") fit fd { lege(fd) }
#   cura connect(url) fiet conn { ... }
@ publica
functio parseCuraSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'cura'
    p.expectaVerbum("cura", ParserErrorCodice.ExpectaturCura)

    # Check for curator kind: arena or pagina
    varia curatorSpecies = nihil qua CuratorGenus?
    si p.probaVerbum("arena") {
        p.procede()
        curatorSpecies = CuratorGenus.Arena
    } sin p.probaVerbum("pagina") {
        p.procede()
        curatorSpecies = CuratorGenus.Pagina
    }

    # Parse optional resource expression
    # Skip if next token starts a binding (pro, fit, fiet) or block
    varia res = nihil qua Expressia?
    si non p.probaVerbum("pro") et non p.probaVerbum("fit") et non p.probaVerbum("fiet") et non p.proba(SymbolumGenus.UncusSin) {
        res = r.expressia()
    }

    # Parse binding verb: pro, fit, or fiet
    varia asynca = falsum
    varia hasBinding = falsum

    si p.probaVerbum("pro") {
        p.procede()
        hasBinding = verum
    } sin p.probaVerbum("fit") {
        p.procede()
        hasBinding = verum
    } sin p.probaVerbum("fiet") {
        p.procede()
        asynca = verum
        hasBinding = verum
    }

    # Parse optional type and binding name
    varia adnotatioTypus = nihil qua TypusAnnotatio?
    varia vinculum = ""

    si hasBinding {
        # Check for type annotation: if two identifiers before {, first is type
        fixum hasType = p.proba(SymbolumGenus.Nomen) et p.specta(1).species === SymbolumGenus.Nomen
        si hasType {
            adnotatioTypus = r.adnotatio()
        }

        fixum vincSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
        vinculum = vincSym.valor
    } secus {
        # Auto-generate binding name
        vinculum = "_cura"
    }

    # Parse body block
    fixum corpus = parseMassaSententia(r)

    # Optional catch clause
    varia cape = nihil qua CapeClausula?
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    redde finge CuraSententia {
        locus: locus,
        curatorSpecies: curatorSpecies,
        res: res,
        vinculum: vinculum,
        typus: adnotatioTypus,
        asynca: asynca,
        corpus: corpus,
        cape: cape
    } qua Sententia
}

# Parse ad (dispatch) statement
#
# GRAMMAR:
#   adStmt := 'ad' STRING '(' args ')' binding? block? ('cape' ...)?
#   binding := ('fit'|'fiet'|'fiunt'|'fient') type? 'pro' IDENT ('ut' IDENT)?
#
# Examples:
#   ad "fasciculus:lege" ("file.txt") fit textus pro content { scribe content }
#   ad "http:pete" (url) fiet Response pro resp { ... }
@ publica
functio parseAdSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'ad'
    p.expectaVerbum("ad", ParserErrorCodice.ExpectaturAd)

    # Parse target string
    fixum scopusSym = p.expecta(SymbolumGenus.Textus, ParserErrorCodice.ExpectaturTextus)
    fixum scopus = scopusSym.valor

    # Parse argument list
    p.expecta(SymbolumGenus.ParensSin, ParserErrorCodice.ExpectaturParensSin)

    varia argumenta = [] qua lista<Expressia>
    si non p.proba(SymbolumGenus.ParensDex) {
        fac {
            argumenta.adde(r.expressia())
        } dum p.congruet(SymbolumGenus.Coma)
    }

    p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)

    # Parse optional binding clause
    varia vinculum = nihil qua AdVinculum?
    si p.probaVerbum("fit") aut p.probaVerbum("fiet") aut p.probaVerbum("fiunt") aut p.probaVerbum("fient") aut p.probaVerbum("pro") {
        fixum vincLocus = p.locusActualis()

        # Parse verb (default to fit)
        varia verbum = AdVerbumVinculandi.Fit
        si p.probaVerbum("fit") {
            p.procede()
            verbum = AdVerbumVinculandi.Fit
        } sin p.probaVerbum("fiet") {
            p.procede()
            verbum = AdVerbumVinculandi.Fiet
        } sin p.probaVerbum("fiunt") {
            p.procede()
            verbum = AdVerbumVinculandi.Fiunt
        } sin p.probaVerbum("fient") {
            p.procede()
            verbum = AdVerbumVinculandi.Fient
        }

        # Optional type before 'pro'
        varia adnotatioTypus = nihil qua TypusAnnotatio?
        si p.proba(SymbolumGenus.Nomen) et non p.probaVerbum("pro") {
            adnotatioTypus = r.adnotatio()
        }

        # Expect 'pro'
        p.expectaVerbum("pro", ParserErrorCodice.ExpectaturPro)

        # Parse binding name
        fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
        fixum nomen = nomenSym.valor

        # Optional alias: ut alias
        varia alias = nihil qua textus?
        si p.probaVerbum("ut") {
            p.procede()
            fixum aliasSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
            alias = aliasSym.valor
        }

        vinculum = {
            locus: vincLocus,
            verbum: verbum,
            typus: adnotatioTypus,
            nomen: nomen,
            alias: alias
        } qua AdVinculum
    }

    # Parse optional body block
    varia corpus = nihil qua Sententia?
    si p.proba(SymbolumGenus.UncusSin) {
        corpus = parseMassaSententia(r)
    }

    # Optional catch clause
    varia cape = nihil qua CapeClausula?
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    redde finge AdSententia {
        locus: locus,
        scopus: scopus,
        argumenta: argumenta,
        vinculum: vinculum,
        corpus: corpus,
        cape: cape
    } qua Sententia
}

# Parse catch clause (helper)
@ publica
functio parseCapeClausula(Resolvitor r) -> CapeClausula {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # 'cape' already checked, consume it
    p.procede()

    # Parse error binding name
    fixum paramSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum param = paramSym.valor

    # Parse body
    fixum corpus = parseMassaSententia(r)

    redde {
        locus: locus,
        param: param,
        corpus: corpus
    } qua CapeClausula
}
