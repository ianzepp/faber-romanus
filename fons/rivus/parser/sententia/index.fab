# Statement Dispatcher
#
# Central dispatcher for parsing statements based on leading keyword.
# Handles comment attachment and error recovery.
#
# GRAMMAR:
#   statement := importDecl | varDecl | funcDecl | typeAliasDecl | ifStmt
#              | whileStmt | forStmt | returnStmt | throwStmt | tryStmt
#              | blockStmt | exprStmt | ...
#
# LATIN VOCABULARY:
# - sententia = statement (sentence/thought)
# - declara = declare
# - imperium = control (command)

ex "../resolvitor" importa Resolvitor
ex "../../ast/positio" importa Locus
ex "../../ast/expressia" importa Expressia
ex "../../ast/sententia" importa Sententia, ScribeGradus
ex "../../ast/lexema" importa SymbolumGenus, VerbumId
ex "../../ast/radix" importa NodusRadix
ex "../errores" importa ParserErrorCodice

# Import statement parsers from submodules
ex "./actio" importa parseReddeSententia, parseRumpeSententia, parsePergeSententia, parseIaceSententia, parseScribeSententia
ex "./declara" importa parseFunctioDeclaratio, parseGenusDeclaratio, parsePactumDeclaratio, parseOrdoDeclaratio, parseDiscretioDeclaratio, parseTypusAliasDeclaratio, parseImportaSententia
ex "./error" importa parseTemptaSententia, parseFacSententia, parseAdfirmaSententia
ex "./imperium" importa parseSiSententia, parseDumSententia, parseExSententia, parseDeSententia
ex "./imperium" importa parseInSententia
ex "./fluxus" importa parseEligeSententia, parseDiscerneSententia, parseCustodiSententia
ex "./initus" importa parseIncipitSententia, parseIncipietSententia, parseCuraSententia, parseAdSententia
ex "./massa" importa parseMassaSententia, parseExpressiaSententia
ex "./varia" importa parseVariaSententia, parseDestructuraSententia, parseNomenVelVerbum
ex "./proba" importa parseProbandumSententia, parseProbaSententia, parsePraeparaMassa

# Parse a statement
#
# Main dispatcher that routes to appropriate parser based on leading token.
# Collects and attaches leading/trailing comments.
@ publica
functio parseSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()

    # Capture any leading comments before the statement.
    p.colligeNotas()

    fixum stmt = parseSententiaSineNotis(r)

    # Attach leading/trailing comments (if any).
    fixum radix = stmt qua ignotum qua NodusRadix
    radix.notaePrae = p.consumeNotas()
    radix.notaePost = p.colligeNotamTrahentem(radix.locus.linea)

    redde stmt
}

functio parseSententiaSineNotis(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum sym = p.specta(0)

    # Annotation prefix (e.g. `@ futura`)
    si sym.species === SymbolumGenus.At {
        varia annotationes = [] qua lista<textus>
        dum p.congruet(SymbolumGenus.At) {
            annotationes.adde(parseNomenVelVerbum(r))
        }

        fixum stmt = parseSententiaSineNotis(r)

        ex annotationes pro a {
            si a == "futura" {
                discerne stmt {
                    casu FunctioDeclaratio ut f {
                        f.asynca = verum
                    }
                }
            }
        }

        redde stmt
    }

    # Block statement
    si sym.species === SymbolumGenus.UncusSin {
        redde parseMassaSententia(r)
    }

    # Keyword-based dispatch
    si sym.species === SymbolumGenus.Verbum {
        fixum verbumId = sym.verbumId

        # Variable declarations
        si verbumId inter [VerbumId.Varia, VerbumId.Fixum, VerbumId.Figendum, VerbumId.Variandum] {
            redde parseVariaSententia(r)
        }

        # Return statement
        si verbumId === VerbumId.Redde {
            redde parseReddeSententia(r)
        }

        # Break/continue
        si verbumId === VerbumId.Rumpe {
            redde parseRumpeSententia(r)
        }
        si verbumId === VerbumId.Perge {
            redde parsePergeSententia(r)
        }

        # Throw/panic
        si verbumId === VerbumId.Iace {
            redde parseIaceSententia(r, falsum)
        }
        si verbumId === VerbumId.Mori {
            redde parseIaceSententia(r, verum)
        }

        # Output statements
        si verbumId === VerbumId.Scribe {
            redde parseScribeSententia(r, ScribeGradus.Scribe)
        }
        si verbumId === VerbumId.Vide {
            redde parseScribeSententia(r, ScribeGradus.Vide)
        }
        si verbumId === VerbumId.Mone {
            redde parseScribeSententia(r, ScribeGradus.Mone)
        }

        # Error handling
        si verbumId === VerbumId.Tempta {
            redde parseTemptaSententia(r)
        }
        si verbumId === VerbumId.Fac {
            redde parseFacSententia(r)
        }
        si verbumId === VerbumId.Adfirma {
            redde parseAdfirmaSententia(r)
        }

        # Control flow
        si verbumId === VerbumId.Si {
            redde parseSiSententia(r)
        }
        si verbumId === VerbumId.Dum {
            redde parseDumSententia(r)
        }
        si verbumId === VerbumId.Ex {
            # Look ahead: ex (IDENTIFIER|STRING) importa -> import
            fixum nextSym = p.specta(1)
            si (nextSym.species === SymbolumGenus.Nomen aut nextSym.species === SymbolumGenus.Textus) {
                fixum afterSym = p.specta(2)
                si afterSym.species === SymbolumGenus.Verbum et afterSym.verbumId === VerbumId.Importa {
                    redde parseImportaSententia(r)
                }
            }

            # Destructure: ex <expr> fixum/varia/figendum/variandum ...
            varia i = 1
            dum i < 32 et non p.estFinis() {
                fixum s = p.specta(i)
                si s.species === SymbolumGenus.Verbum {
                    si s.verbumId inter [VerbumId.Fixum, VerbumId.Varia, VerbumId.Figendum, VerbumId.Variandum] {
                        redde parseDestructuraSententia(r)
                    }
                    si s.verbumId === VerbumId.Pro {
                        rumpe
                    }
                }
                i += 1
            }

            # Otherwise it's a for-of loop
            redde parseExSententia(r)
        }
        si verbumId === VerbumId.De {
            redde parseDeSententia(r)
        }
        si verbumId === VerbumId.In {
            redde parseInSententia(r)
        }

        # Declarations
        si verbumId === VerbumId.Functio {
            redde parseFunctioDeclaratio(r)
        }
        si verbumId === VerbumId.Genus {
            redde parseGenusDeclaratio(r, falsum)
        }
        si verbumId === VerbumId.Abstractus {
            # WHY: Allow abstract genus modifier before the declaration keyword.
            si p.specta(1).species == SymbolumGenus.Verbum et p.specta(1).verbumId == VerbumId.Genus {
                p.procede()
                redde parseGenusDeclaratio(r, verum)
            }
        }
        si verbumId === VerbumId.Pactum {
            redde parsePactumDeclaratio(r)
        }
        si verbumId === VerbumId.Ordo {
            redde parseOrdoDeclaratio(r)
        }
        si verbumId === VerbumId.Discretio {
            redde parseDiscretioDeclaratio(r)
        }
        si verbumId === VerbumId.Typus {
            redde parseTypusAliasDeclaratio(r)
        }

        # Pattern matching and flow control
        si verbumId === VerbumId.Elige {
            redde parseEligeSententia(r)
        }
        si verbumId === VerbumId.Discerne {
            redde parseDiscerneSententia(r)
        }
        si verbumId === VerbumId.Custodi {
            redde parseCustodiSententia(r)
        }

        # Entry points
        si verbumId === VerbumId.Incipit {
            redde parseIncipitSententia(r)
        }
        si verbumId === VerbumId.Incipiet {
            redde parseIncipietSententia(r)
        }

        # Resource management and dispatch
        si verbumId === VerbumId.Cura {
            redde parseCuraSententia(r)
        }
        si verbumId === VerbumId.Ad {
            redde parseAdSententia(r)
        }

        # Testing
        si verbumId === VerbumId.Probandum {
            redde parseProbandumSententia(r)
        }
        si verbumId === VerbumId.Proba {
            redde parseProbaSententia(r)
        }
        si verbumId inter [VerbumId.Praepara, VerbumId.Praeparabit, VerbumId.Postpara, VerbumId.Postparabit] {
            # WHY: Allow hooks at top level for test files.
            redde parsePraeparaMassa(r)
        }
    }

    # Fall through to expression statement
    redde parseExpressiaSententia(r)
}
