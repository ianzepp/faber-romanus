# Statement Dispatcher
#
# Central dispatcher for parsing statements based on leading keyword.
# Handles comment attachment and error recovery.
#
# GRAMMAR:
#   statement := importDecl | varDecl | funcDecl | typeAliasDecl | ifStmt
#              | whileStmt | forStmt | returnStmt | throwStmt | tryStmt
#              | blockStmt | exprStmt | ...
#
# LATIN VOCABULARY:
# - sententia = statement (sentence/thought)
# - declara = declare
# - imperium = control (command)

ex "../resolvitor" importa Resolvitor
ex "../../ast/positio" importa Locus
ex "../../ast/expressia" importa Expressia
ex "../../ast/sententia" importa Sententia, ScribeGradus
ex "../../ast/lexema" importa SymbolumGenus
ex "../errores" importa ParserErrorCodice

# Import statement parsers from submodules
ex "./actio" importa parseReddeSententia, parseRumpeSententia, parsePergeSententia, parseIaceSententia, parseScribeSententia
ex "./declara" importa parseFunctioDeclaratio, parseGenusDeclaratio, parsePactumDeclaratio, parseOrdoDeclaratio, parseDiscretioDeclaratio, parseTypusAliasDeclaratio, parseImportaSententia
ex "./error" importa parseTemptaSententia, parseFacSententia, parseAdfirmaSententia
ex "./imperium" importa parseSiSententia, parseDumSententia, parseExSententia, parseDeSententia
ex "./fluxus" importa parseEligeSententia, parseDiscerneSententia, parseCustodiSententia
ex "./initus" importa parseIncipitSententia, parseIncipietSententia, parseCuraSententia, parseAdSententia
ex "./massa" importa parseMassaSententia, parseExpressiaSententia
ex "./varia" importa parseVariaSententia
ex "./proba" importa parseProbandumSententia, parseProbaSententia, parsePraeparaMassa

# Parse a statement
#
# Main dispatcher that routes to appropriate parser based on leading token.
@ publica
functio parseSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum sym = p.specta(0)

    # Block statement
    si sym.species === SymbolumGenus.UncusSin {
        redde parseMassaSententia(r)
    }

    # Keyword-based dispatch
    si sym.species === SymbolumGenus.Verbum {
        fixum verbum = sym.verbum

        # Variable declarations
        si verbum inter ["varia", "fixum", "figendum", "variandum"] {
            redde parseVariaSententia(r)
        }

        # Return statement
        si verbum === "redde" {
            redde parseReddeSententia(r)
        }

        # Break/continue
        si verbum === "rumpe" {
            redde parseRumpeSententia(r)
        }
        si verbum === "perge" {
            redde parsePergeSententia(r)
        }

        # Throw/panic
        si verbum === "iace" {
            redde parseIaceSententia(r, falsum)
        }
        si verbum === "mori" {
            redde parseIaceSententia(r, verum)
        }

        # Output statements
        si verbum === "scribe" {
            redde parseScribeSententia(r, ScribeGradus.Scribe)
        }
        si verbum === "vide" {
            redde parseScribeSententia(r, ScribeGradus.Vide)
        }
        si verbum === "mone" {
            redde parseScribeSententia(r, ScribeGradus.Mone)
        }

        # Error handling
        si verbum === "tempta" {
            redde parseTemptaSententia(r)
        }
        si verbum === "fac" {
            redde parseFacSententia(r)
        }
        si verbum === "adfirma" {
            redde parseAdfirmaSententia(r)
        }

        # Control flow
        si verbum === "si" {
            redde parseSiSententia(r)
        }
        si verbum === "dum" {
            redde parseDumSententia(r)
        }
        si verbum === "ex" {
            # Look ahead: ex (IDENTIFIER|STRING) importa -> import
            # Otherwise it's a for-of loop
            fixum nextSym = p.specta(1)
            si (nextSym.species === SymbolumGenus.Nomen aut nextSym.species === SymbolumGenus.Textus) {
                fixum afterSym = p.specta(2)
                si afterSym.species === SymbolumGenus.Verbum et afterSym.verbum === "importa" {
                    redde parseImportaSententia(r)
                }
            }
            redde parseExSententia(r)
        }
        si verbum === "de" {
            redde parseDeSententia(r)
        }

        # Declarations
        si verbum === "functio" {
            redde parseFunctioDeclaratio(r)
        }
        si verbum === "genus" {
            redde parseGenusDeclaratio(r, falsum)
        }
        si verbum === "abstractus" {
            # WHY: Allow abstract genus modifier before the declaration keyword.
            si p.specta(1).species == SymbolumGenus.Verbum et p.specta(1).verbum == "genus" {
                p.procede()
                redde parseGenusDeclaratio(r, verum)
            }
        }
        si verbum === "pactum" {
            redde parsePactumDeclaratio(r)
        }
        si verbum === "ordo" {
            redde parseOrdoDeclaratio(r)
        }
        si verbum === "discretio" {
            redde parseDiscretioDeclaratio(r)
        }
        si verbum === "typus" {
            redde parseTypusAliasDeclaratio(r)
        }

        # Pattern matching and flow control
        si verbum === "elige" {
            redde parseEligeSententia(r)
        }
        si verbum === "discerne" {
            redde parseDiscerneSententia(r)
        }
        si verbum === "custodi" {
            redde parseCustodiSententia(r)
        }

        # Entry points
        si verbum === "incipit" {
            redde parseIncipitSententia(r)
        }
        si verbum === "incipiet" {
            redde parseIncipietSententia(r)
        }

        # Resource management and dispatch
        si verbum === "cura" {
            redde parseCuraSententia(r)
        }
        si verbum === "ad" {
            redde parseAdSententia(r)
        }

        # Testing
        si verbum === "probandum" {
            redde parseProbandumSententia(r)
        }
        si verbum === "proba" {
            redde parseProbaSententia(r)
        }
        si verbum inter ["praepara", "praeparabit", "postpara", "postparabit"] {
            # WHY: Allow hooks at top level for test files.
            redde parsePraeparaMassa(r)
        }
    }

    # Fall through to expression statement
    redde parseExpressiaSententia(r)
}
