# Type Annotation Parser
#
# Parses type annotations in the Faber language.
# Handles generics, nullable types, union types, and array shorthand.
#
# GRAMMAR:
#   typeAnnotation := ('de' | 'in')? IDENTIFIER typeParams? '?'? arrayBrackets*
#   typeParams := '<' typeParameter (',' typeParameter)* '>'
#   typeParameter := typeAnnotation | NUMBER | MODIFIER
#   arrayBrackets := '[]' '?'?
#
# EXAMPLES:
#   textus                    -> simple type
#   lista<numerus>            -> generic type
#   textus?                   -> nullable type
#   numerus[]                 -> array shorthand (desugars to lista<numerus>)
#   unio<textus, numerus>     -> union type
#   de textus                 -> borrowed type (preposition)
#
# LATIN VOCABULARY:
# - typus = type
# - annotatio = annotation
# - parametra = parameters
# - nullabilis = nullable

ex "./resolvitor" importa Resolvitor
ex "../ast/positio" importa Locus
ex "../ast/typus" importa TypusAnnotatio, TypusParametrum
ex "../ast/lexema" importa SymbolumGenus
ex "./errores" importa ParserErrorCodice

# Parse a type annotation
# Handles generics, nullable, array shorthand, and union types
@ publica
functio parseTypusAnnotatio(Resolvitor r) -> TypusAnnotatio {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # -------------------------------------------------------------------------
    # Check for borrow preposition (de/in for ownership semantics)
    # -------------------------------------------------------------------------
    varia praepositio = nihil qua textus?

    si p.estPraepositio(p.specta(0)) {
        praepositio = p.procede().verbum
    }

    # -------------------------------------------------------------------------
    # Parse type name (identifier or keyword like nihil/textus)
    # -------------------------------------------------------------------------
    varia nomen = "" qua textus

    si p.proba(SymbolumGenus.Nomen) {
        # Regular identifier (Persona, MyType, etc.)
        nomen = p.procede().valor
    } sin p.proba(SymbolumGenus.Verbum) {
        # Keywords can be type names (nihil, textus, numerus, etc.)
        nomen = p.procede().valor
    } secus {
        # Error: expected type name
        p.renuncia(ParserErrorCodice.ExpectaturTypusNomen, scriptum("got 'ยง'", p.specta(0).valor))
        nomen = p.specta(0).valor
        p.procede()  # Skip to avoid infinite loop
    }

    # -------------------------------------------------------------------------
    # Parse optional type parameters: <T, U, ...>
    # -------------------------------------------------------------------------
    varia typusParametra = nihil qua lista<TypusParametrum>?

    si p.congruet(SymbolumGenus.Minor) {
        typusParametra = [] qua lista<TypusParametrum>
        fixum parametra = typusParametra qua lista<TypusParametrum>

        # Parse first type parameter
        si p.proba(SymbolumGenus.Numerus) {
            # Numeric literal parameter (e.g., numerus<32>)
            # TODO: Handle numeric type params properly
            fixum litSym = p.procede()
            parametra.adde(finge Littera {
                valor: litSym.valor
            } qua TypusParametrum)
        } secus {
            # Recursive type annotation parameter - use Resolvitor
            fixum param = r.adnotatio()
            parametra.adde(finge Typus {
                adnotatio: param
            } qua TypusParametrum)
        }

        # Parse remaining comma-separated type parameters
        dum p.congruet(SymbolumGenus.Coma) {
            si p.proba(SymbolumGenus.Numerus) {
                fixum litSym = p.procede()
                parametra.adde(finge Littera {
                    valor: litSym.valor
                } qua TypusParametrum)
            } secus {
                fixum param = r.adnotatio()
                parametra.adde(finge Typus {
                    adnotatio: param
                } qua TypusParametrum)
            }
        }

        # Expect closing angle bracket
        p.expecta(SymbolumGenus.Maior, ParserErrorCodice.ExpectaturAngulusDex)
    }

    # -------------------------------------------------------------------------
    # Parse optional nullable marker: ?
    # -------------------------------------------------------------------------
    varia nullabilis = falsum

    si p.congruet(SymbolumGenus.Rogatio) {
        nullabilis = verum
    }

    # -------------------------------------------------------------------------
    # Handle unio<A, B> -> union type
    # Union types use type parameters as union members
    # -------------------------------------------------------------------------
    si nomen === "unio" et nonnihil typusParametra {
        fixum parametra = typusParametra qua lista<TypusParametrum>
        si parametra.longitudo() == 0 {
            redde {
                locus: locus,
                nomen: "union",
                typusParametra: nihil,
                nullabilis: nullabilis,
                unio: [] qua lista<TypusAnnotatio>,
                compendiumSeries: falsum,
                praepositio: praepositio
            } qua TypusAnnotatio
        }
        varia unioParametra = [] qua lista<TypusAnnotatio>
        ex parametra pro param {
            discerne param {
                casu Typus ut t {
                    unioParametra.adde(t.adnotatio)
                }
            }
        }
        redde {
            locus: locus,
            nomen: "union",
            typusParametra: nihil,
            nullabilis: nullabilis,
            unio: unioParametra,
            compendiumSeries: falsum,
            praepositio: praepositio
        } qua TypusAnnotatio
    }

    # -------------------------------------------------------------------------
    # Build base type result
    # -------------------------------------------------------------------------
    varia resultatum = {
        locus: locus,
        nomen: nomen,
        typusParametra: typusParametra,
        nullabilis: nullabilis,
        unio: nihil,
        compendiumSeries: falsum,
        praepositio: praepositio
    } qua TypusAnnotatio

    # -------------------------------------------------------------------------
    # Handle array shorthand: T[] -> lista<T>
    # Each [] wraps in lista, preserving arrayShorthand flag for round-trip
    # -------------------------------------------------------------------------
    dum p.proba(SymbolumGenus.QuadratusSin) et p.specta(1).species === SymbolumGenus.QuadratusDex {
        p.procede()  # [
        p.procede()  # ]

        # Check for nullable array: []?
        varia arrayNullabilis = falsum
        si p.congruet(SymbolumGenus.Rogatio) {
            arrayNullabilis = verum
        }

        # Wrap in lista<...> with shorthand flag
        resultatum = {
            locus: locus,
            nomen: "lista",
            typusParametra: [finge Typus { adnotatio: resultatum } qua TypusParametrum],
            nullabilis: arrayNullabilis,
            unio: nihil,
            compendiumSeries: verum,
            praepositio: nihil
        } qua TypusAnnotatio
    }

    redde resultatum
}
