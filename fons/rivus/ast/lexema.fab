# Token AST - Token types and structures for lexical analysis
#
# WHY: The tokenizer produces a stream of tokens that the parser consumes.
#      Each token has a type, value, and position.

ex "./positio" importa Locus

# ============================================================================
# TOKEN TYPES
# ============================================================================

# Token type enumeration
@ publicum
ordo SymbolumGenus {
    # -------------------------------------------------------------------------
    # Literals
    # -------------------------------------------------------------------------
    Numerus       # integer literal: 42
    Fractus       # float literal: 3.14
    Textus        # string literal: "hello"
    Exemplar      # template literal: `hello ${x}`

    # -------------------------------------------------------------------------
    # Boolean/Null Literals
    # -------------------------------------------------------------------------
    Verum         # true
    Falsum        # false
    Nihil         # null

    # -------------------------------------------------------------------------
    # Identifiers and Keywords
    # -------------------------------------------------------------------------
    Nomen         # user-defined name
    Verbum        # reserved word (valor contains which)

    # -------------------------------------------------------------------------
    # Grouping
    # -------------------------------------------------------------------------
    ParensSin     # (
    ParensDex     # )
    UncusSin      # {
    UncusDex      # }
    QuadratusSin  # [
    QuadratusDex  # ]

    # -------------------------------------------------------------------------
    # Operators - Arithmetic
    # -------------------------------------------------------------------------
    Plus          # +
    Minus         # -
    Stella        # *
    Virgula       # /
    Centum        # %
    PlusAequum    # +=
    MinusAequum   # -=
    StellaAequum  # *=
    VirgulaAequum # /=
    CentumAequum  # %=

    # -------------------------------------------------------------------------
    # Operators - Comparison
    # -------------------------------------------------------------------------
    Aequum        # =
    AequumBis     # ==
    AequumTer     # ===
    NonAequum     # !=
    NonAequumBis  # !==
    Minor         # <
    MinorAequum   # <=
    Maior         # >
    MaiorAequum   # >=

    # -------------------------------------------------------------------------
    # Operators - Logical
    # -------------------------------------------------------------------------
    Non           # !
    EtEt          # &&
    VelVel        # ||
    Rogatio       # ?
    RogatioBis    # ??
    RogatioPunctum    # ?.
    NonPunctum        # !.

    # -------------------------------------------------------------------------
    # Operators - Bitwise
    # -------------------------------------------------------------------------
    Et            # &
    Vel           # |
    Apex          # ^
    Unda          # ~
    MinorBis      # <<
    MaiorBis      # >>
    MaiorTer      # >>>
    EtAequum      # &=
    VelAequum     # |=

    # -------------------------------------------------------------------------
    # Punctuation
    # -------------------------------------------------------------------------
    Coma          # ,
    Punctum       # .
    Colon         # :
    PunctumColon  # ;
    At            # @
    Sagitta       # ->
    SagittaCrassa # =>
    PunctumBis    # ..
    PunctumTer    # ...

    # -------------------------------------------------------------------------
    # Comments
    # -------------------------------------------------------------------------
    NotaLinea     # # comment
    NotaMassa     # /* comment */
    NotaDocens    # # comment

    # -------------------------------------------------------------------------
    # Special
    # -------------------------------------------------------------------------
    Finis         # end of file
    Malum         # lexer error token
}

# ============================================================================
# KEYWORD IDENTITIES
# ============================================================================

# Keyword identity (canonical, dialect-independent)
#
# WHY: Parsing against raw keyword strings bakes Latin spellings into semantics.
#      This enum allows multiple surface spellings (dialects) to map to the same
#      internal meaning.
@ publicum
ordo VerbumId {
    # -------------------------------------------------------------------------
    # Control Flow
    # -------------------------------------------------------------------------
    Si
    Secus
    Sin
    Casu
    Ceterum
    Dum
    Fac
    Pro
    Elige
    Ergo
    Rumpe
    Perge
    Redde
    Reddit
    Custodi
    Adfirma
    Discerne
    Incipit
    Incipiet

    # -------------------------------------------------------------------------
    # Testing
    # -------------------------------------------------------------------------
    Probandum
    Proba
    Praepara
    Praeparabit
    Postpara
    Postparabit
    Cura
    Arena
    Pagina
    Tempta
    Cape
    Demum
    Iace
    Mori
    Scribe
    Vide
    Mone
    Lege
    Lineam
    Scriptum
    Cede

    # -------------------------------------------------------------------------
    # Declarations
    # -------------------------------------------------------------------------
    Varia
    Fixum
    Figendum
    Variandum
    Functio
    Novum
    Finge
    Importa
    Exporta
    Typus
    Genus
    Pactum
    Ordo
    Discretio

    # -------------------------------------------------------------------------
    # Modifiers
    # -------------------------------------------------------------------------
    Futura
    Prae
    Praefixum
    Cursor
    Curata
    Publicus
    Privatus
    Generis
    Implet
    Sub
    Abstractus
    Protectus
    Nexum
    Omitte
    Futurum
    Omnia

    # -------------------------------------------------------------------------
    # Operators
    # -------------------------------------------------------------------------
    Et
    Aut
    Non
    Est
    Sic
    Fit
    Fiet
    Fiunt
    Fient
    Vel
    Ante
    Usque
    Intra
    Inter
    Sparge
    Ceteri
    Nulla
    Nonnulla
    Nihil
    Nonnihil
    Negativum
    Positivum

    # -------------------------------------------------------------------------
    # Literal Values
    # -------------------------------------------------------------------------
    Verum
    Falsum
    Ego

    # -------------------------------------------------------------------------
    # Prepositions
    # -------------------------------------------------------------------------
    De
    In
    Ex
    Ad
    Per
    Qua
    Ut

    # -------------------------------------------------------------------------
    # Domain Specific (DSL)
    # -------------------------------------------------------------------------
    Ab
    Ubi
    Prima
    Ultima
    Summa
    Ordina
    Collige
    Grupa
    Sed
}

# ============================================================================
# TOKEN STRUCTURE
# ============================================================================

# A single token from the source
@ publicum
genus Symbolum {
    SymbolumGenus species
    textus valor       # raw text of the token
    Locus locus
    textus? verbum     # if Verbum, surface spelling
    VerbumId? verbumId # if Verbum, canonical identity
}

# ============================================================================
# FACTORY FUNCTIONS
# ============================================================================

# Create a token
@ publica
functio symbolum(SymbolumGenus species, textus valor, Locus locus) -> Symbolum {
    redde { species: species, valor: valor, locus: locus, verbum: nihil, verbumId: nihil } qua Symbolum
}

# Create a keyword token
@ publica
functio symbolumVerbum(textus verbum, Locus locus) -> Symbolum {
    redde {
        species: SymbolumGenus.Verbum,
        valor: verbum,
        locus: locus,
        verbum: verbum,
        verbumId: nihil
    } qua Symbolum
}

# Create a keyword token with canonical identity
@ publica
functio symbolumVerbumId(textus verbum, VerbumId verbumId, Locus locus) -> Symbolum {
    redde {
        species: SymbolumGenus.Verbum,
        valor: verbum,
        locus: locus,
        verbum: verbum,
        verbumId: verbumId
    } qua Symbolum
}

# ============================================================================
# QUERY FUNCTIONS
# ============================================================================

# Check if token is a specific keyword (surface spelling)
@ publica
functio estVerbum(Symbolum sym, textus verbum) -> bivalens {
    redde sym.species == SymbolumGenus.Verbum && sym.verbum == verbum
}

# Check if token is a specific keyword (canonical identity)
@ publica
functio estVerbumId(Symbolum sym, VerbumId verbumId) -> bivalens {
    redde sym.species == SymbolumGenus.Verbum && sym.verbumId == verbumId
}

# Check if token is EOF
@ publica
functio estFinis(Symbolum sym) -> bivalens {
    redde sym.species == SymbolumGenus.Finis
}
