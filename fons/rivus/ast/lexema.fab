# Token types and Token structure for lexical analysis
#
# WHY: The tokenizer produces a stream of tokens that the parser consumes.
#      Each token has a type, value, and position.

ex "./positio" importa Locus

# Token type enumeration
@ publicum
ordo SymbolumGenus {
    # Literals
    Numerus       # integer literal: 42
    Fractus       # float literal: 3.14
    Textus        # string literal: "hello"
    Exemplar      # template literal: `hello ${x}`

    # Boolean/null literals (as tokens, not keywords)
    Verum         # true
    Falsum        # false
    Nihil         # null

    # Identifiers and keywords
    Nomen         # user-defined name
    Verbum        # reserved word (valor contains which)

    # Grouping
    ParensSin     # (
    ParensDex     # )
    UncusSin      # {
    UncusDex      # }
    QuadratusSin  # [
    QuadratusDex  # ]

    # Operators - arithmetic
    Plus          # +
    Minus         # -
    Stella        # *
    Virgula       # /
    Centum        # %
    PlusAequum    # +=
    MinusAequum   # -=
    StellaAequum  # *=
    VirgulaAequum # /=
    CentumAequum  # %=

    # Operators - comparison
    Aequum        # =
    AequumBis     # ==
    AequumTer     # ===
    NonAequum     # !=
    NonAequumBis  # !==
    Minor         # <
    MinorAequum   # <=
    Maior         # >
    MaiorAequum   # >=

    # Operators - logical
    Non           # !
    EtEt          # &&
    VelVel        # ||
    Rogatio       # ?
    RogatioBis    # ??
    RogatioPunctum    # ?.
    NonPunctum        # !.

    # Operators - bitwise
    Et            # &
    Vel           # |
    Apex          # ^
    Unda          # ~
    MinorBis      # <<
    MaiorBis      # >>
    MaiorTer      # >>>
    EtAequum      # &=
    VelAequum     # |=

    # Punctuation
    Coma          # ,
    Punctum       # .
    Colon         # :
    PunctumColon  # ;
    Sagitta       # ->
    SagittaCrassa # =>
    PunctumBis    # ..
    PunctumTer    # ...

    # Comments (preserved for formatting)
    NotaLinea     # # comment
    NotaMassa     # /* comment */
    NotaDocens    # # comment

    # Special
    Finis         # end of file
    Malum         # lexer error token
}

# Keyword identity (canonical, dialect-independent)
#
# WHY: Parsing against raw keyword strings bakes Latin spellings into semantics.
#      This enum allows multiple surface spellings (dialects) to map to the same
#      internal meaning.
@ publicum
ordo VerbumId {
    Fit
    Fiet
    Fiunt
    Fient
}

# A single token from the source
@ publicum
genus Symbolum {
    SymbolumGenus species
    textus valor       # raw text of the token
    Locus locus
    textus? verbum     # if species == Verbum, which keyword (surface spelling)
    VerbumId? verbumId # if species == Verbum, canonical keyword identity
}

# Create a token
@ publica
functio symbolum(SymbolumGenus species, textus valor, Locus locus) -> Symbolum {
    redde { species: species, valor: valor, locus: locus, verbum: nihil, verbumId: nihil } qua Symbolum
}

# Create a keyword token
@ publica
functio symbolumVerbum(textus verbum, Locus locus) -> Symbolum {
    redde {
        species: SymbolumGenus.Verbum,
        valor: verbum,
        locus: locus,
        verbum: verbum,
        verbumId: nihil
    } qua Symbolum
}

# Create a keyword token with canonical identity
@ publica
functio symbolumVerbumId(textus verbum, VerbumId verbumId, Locus locus) -> Symbolum {
    redde {
        species: SymbolumGenus.Verbum,
        valor: verbum,
        locus: locus,
        verbum: verbum,
        verbumId: verbumId
    } qua Symbolum
}

# Check if token is a specific keyword (surface spelling)
@ publica
functio estVerbum(Symbolum sym, textus verbum) -> bivalens {
    redde sym.species == SymbolumGenus.Verbum && sym.verbum == verbum
}

# Check if token is a specific keyword (canonical identity)
@ publica
functio estVerbumId(Symbolum sym, VerbumId verbumId) -> bivalens {
    redde sym.species == SymbolumGenus.Verbum && sym.verbumId == verbumId
}

# Check if token is EOF
@ publica
functio estFinis(Symbolum sym) -> bivalens {
    redde sym.species == SymbolumGenus.Finis
}
