# Expression AST - All expression types as a unified discretio
#
# WHY: Single file defines all expression variants for pattern matching.
#      Parsers construct variants with `finge VariantName { ... } qua Expressia`.

ex "./positio" importa Locus
ex "./typus" importa TypusAnnotatio

# ============================================================================
# SUPPORTING TYPES
# ============================================================================

# Literal value type - what kind of constant this is
@ publicum
ordo LitteraGenus {
    Numerus    # integer: 42
    Fractus    # float: 3.14
    Textus     # string: "hello"
    Exemplar   # template: `hello ${x}`
    Verum      # true
    Falsum     # false
    Nihil      # null
}

# Object property in object literal
# Example: name: "Alice", or shorthand: name
@ publicum
genus ObiectumProprietas {
    Locus locus
    Expressia clavis         # key - usually Nomen or Littera
    Expressia valor
    bivalens brevitas        # true for { name } meaning { name: name }
    bivalens computatum      # true for { [expr]: value }
    bivalens dispersum       # true for { sparge expr }
}

# Lambda parameter (simplified vs full Parametrum)
# Example: pro x, y: x + y
@ publicum
genus LambdaParametrum {
    Locus locus
    textus nomen
    TypusAnnotatio? typus
}

# Chain step for collection DSL
# Examples: prima 5, ultima 3, summa, ordina per nomen
@ publicum
genus CatenaGradus {
    Locus locus
    textus verbum            # prima, ultima, summa, ordina, collige, grupa
    Expressia? argumentum    # optional argument (5 in "prima 5")
}

# Ab filter clause (ubi condition or boolean shorthand)
@ publicum
genus AbFiltrum {
    Locus locus
    bivalens habetUbi        # true if 'ubi' form was used
    Expressia condicio
}

# Morphology dispatch info for method calls
@ publicum
genus MorphologiaInvocatio {
    textus recipiens
    textus radix
    textus forma
}

# ============================================================================
# EXPRESSIA DISCRETIO
# ============================================================================

# All expression types as a tagged union
#
# Each variant contains its fields directly. Use `finge` to construct:
#   finge Nomen { locus: loc, valor: "x" } qua Expressia
#   finge Littera { locus: loc, species: LitteraGenus.Numerus, crudus: "42" } qua Expressia
@ publicum
discretio Expressia {
    # -------------------------------------------------------------------------
    # Identifiers
    # -------------------------------------------------------------------------

    # Simple identifier - a named reference
    # Example: x, nomen, calculateTotal
    Nomen {
        Locus locus
        textus valor
    }

    # Self-reference expression ('ego' in Faber, 'this' in JS, 'self' in Rust/Py)
    EgoExpressia {
        Locus locus
    }

    # -------------------------------------------------------------------------
    # Literals
    # -------------------------------------------------------------------------

    # Literal constant value
    # Examples: 42, 3.14, "hello", verum, falsum, nihil
    Littera {
        Locus locus
        LitteraGenus species
        textus crudus           # original source text
    }

    # Template literal with interpolations
    # Example: `Hello, ${name}!`
    LitteraExemplar {
        Locus locus
        lista<textus> partes       # static string parts
        lista<Expressia> expressiae    # interpolated expressions
    }

    # Regex literal
    # Example: sed "pattern" flags
    LitteraRegex {
        Locus locus
        textus forma         # pattern
        textus vexilla       # flags
    }

    # -------------------------------------------------------------------------
    # Binary and Unary Operations
    # -------------------------------------------------------------------------

    # Binary expression - two operands with an operator
    # Examples: a + b, x == y, foo && bar
    BinariaExpressia {
        Locus locus
        Expressia sinister       # left operand
        textus signum            # +, -, *, /, %, ==, !=, <, >, <=, >=, &&, ||, ??
        Expressia dexter         # right operand
    }

    # Unary expression - one operand with a prefix operator
    # Examples: -x, !flag, ~bits
    UnariaExpressia {
        Locus locus
        textus signum            # -, !, ~
        Expressia argumentum
    }

    # Assignment expression
    # Examples: x = 5, obj.prop = value
    AssignatioExpressia {
        Locus locus
        Expressia sinister       # must be assignable (identifier, member, etc.)
        textus signum            # =, +=, -=, *=, /=, etc.
        Expressia dexter
    }

    # Conditional (ternary) expression
    # Faber: condition sic consequent secus alternate
    # JS: condition ? consequent : alternate
    CondicioExpressia {
        Locus locus
        Expressia condicio
        Expressia consequens
        Expressia alternans
    }

    # Range expression for slicing and iteration
    # Examples: 1..10 (exclusive), 1 usque 10 (inclusive)
    AmbitusExpressia {
        Locus locus
        Expressia initium
        Expressia finis
        Expressia? gradus
        bivalens inclusivum      # true for 'usque', false for '..'
    }

    # Type cast expression
    # Example: value qua numerus
    QuaExpressia {
        Locus locus
        Expressia expressia
        TypusAnnotatio scopus    # target type
    }

    # Type check expression
    # Example: value est numerus
    EstExpressia {
        Locus locus
        Expressia expressia
        TypusAnnotatio scopus    # type to check against
    }

    # Chain expression (collection DSL pipeline)
    # Example: ex items prima 5, ex prices summa
    CatenaExpressia {
        Locus locus
        Expressia fons           # source collection
        lista<CatenaGradus> gradus
    }

    # Compile-time expression
    # Example: praefixum { ... }
    PraefixumExpressia {
        Locus locus
        ignotum corpus
    }

    # -------------------------------------------------------------------------
    # Calls and Member Access
    # -------------------------------------------------------------------------

    # Function/method call expression
    # Examples: foo(1, 2), obj.method(), await fetch()
    VocatioExpressia {
        Locus locus
        Expressia vocatum        # what's being called (callee)
        lista<Expressia> argumenta
        bivalens optivum         # ?. optional call
        MorphologiaInvocatio? morphologia
    }

    # Member access expression
    # Examples: obj.prop, arr[0], obj?.prop, obj!.prop
    MembrumExpressia {
        Locus locus
        Expressia obiectum       # the object being accessed
        Expressia proprietas     # property name or index
        bivalens computatum      # true for arr[0], false for obj.prop
        bivalens optivum         # true for ?.
        bivalens nonNullum       # true for !.
    }

    # New instance creation
    # Example: novum Person de { name: "Alice" }
    NovumExpressia {
        Locus locus
        Expressia vocatum        # the type/constructor
        lista<Expressia> argumenta
        Expressia? initor        # optional 'de { ... }' object
    }

    # Await expression (cede in Faber)
    # Example: cede fetchData()
    CedeExpressia {
        Locus locus
        Expressia argumentum
    }

    # Scriptum (format string) expression
    # Example: scriptum("Hello, ยง!", name)
    ScriptumExpressia {
        Locus locus
        textus exemplar          # format template
        lista<Expressia> argumenta
    }

    # Lege (stdin read) expression
    # Example: lege (read all), lege lineam (read one line)
    LegeExpressia {
        Locus locus
        textus modus              # "all" | "line"
    }

    # Ab expression for collection filtering DSL
    # Example: ab items activus, prima 5
    AbExpressia {
        Locus locus
        Expressia fons           # source
        bivalens negata          # true if "non" used
        AbFiltrum? filtrum       # optional filter clause
        lista<CatenaGradus>? gradus
    }

    # -------------------------------------------------------------------------
    # Collections
    # -------------------------------------------------------------------------

    # Array literal expression
    # Example: [1, 2, 3], [], [a, ...rest]
    SeriesExpressia {
        Locus locus
        lista<Expressia> elementa    # includes DispersioElementum for spread
    }

    # Object literal expression
    # Example: { name: "Alice", age: 30 }
    ObiectumExpressia {
        Locus locus
        lista<ObiectumProprietas> proprietates
    }

    # Spread element in array or object
    # Example: ...items, ...rest (sparge in Faber)
    DispersioElementum {
        Locus locus
        Expressia argumentum
    }

    # -------------------------------------------------------------------------
    # Lambda
    # -------------------------------------------------------------------------

    # Lambda expression (anonymous function)
    # Example: pro x: x * 2
    # Example: pro x, y: x + y
    LambdaExpressia {
        Locus locus
        lista<LambdaParametrum> parametra
        ignotum corpus           # expression body or MassaSententia
        TypusAnnotatio? typusReditus    # optional return type
    }

    # -------------------------------------------------------------------------
    # Discretio Construction
    # -------------------------------------------------------------------------

    # Construct a discretio variant
    # Example: finge Click { x: 10, y: 20 } qua Event
    FingeExpressia {
        Locus locus
        textus variansNomen      # variant name (e.g., "Click")
        lista<ObiectumProprietas> campi
        TypusAnnotatio? scopus   # qua Type
    }
}
