# Typi - Semantic Type System
#
# Defines the type system used during semantic analysis.

# ============================================================================
# SEMANTIC TYPE (DISCRIMINATED UNION)
# ============================================================================

# All possible types in the type system
@ publicum
discretio SemanticTypus {
    # Primitive types: textus, numerus, fractus, decimus, magnus, bivalens, nihil, vacuum, octeti
    Primitivum {
        textus nomen                                    # "textus" | "numerus" | etc.
        bivalens nullabilis                             # T? types
        numerus? amplitudo                              # bit width for numerus<32>
    }

    # Generic types: lista<T>, tabula<K,V>, promissum<T>
    Genericum {
        textus nomen                                    # "lista" | "tabula" | etc.
        lista<SemanticTypus> parametri                  # type parameters
        bivalens nullabilis
    }

    # Function types
    Functio {
        lista<SemanticTypus> parametriTypi              # parameter types
        SemanticTypus reditusTypus                      # return type
        bivalens asyncronum                             # async function?
        bivalens habetCuratorem                         # has curator param?
    }

    # Union types: A | B | C
    Unio {
        lista<SemanticTypus> typi
    }

    # Unknown type for unresolved/error cases
    Ignotum {
        textus? ratio                                   # reason for being unknown
    }

    # User-defined type (class, interface, etc.)
    Usitatum {
        textus nomen
        bivalens nullabilis
    }

    # Enum type (ordo) with named members
    Ordo {
        textus nomen
        tabula<textus, SemanticTypus> membra
        bivalens nullabilis
    }

    # Genus (class/struct) with fields and methods
    Genus {
        textus nomen
        tabula<textus, SemanticTypus> agri              # fields
        tabula<textus, SemanticTypus> methodi           # methods
        tabula<textus, SemanticTypus> agriStatici       # static fields
        tabula<textus, SemanticTypus> methodiStatici    # static methods
        bivalens nullabilis
    }

    # Pactum (interface/protocol) with method signatures
    Pactum {
        textus nomen
        tabula<textus, SemanticTypus> methodi           # method signatures
        bivalens nullabilis
    }
}

# ============================================================================
# TYPE CONSTRUCTORS
# ============================================================================

# Create a primitive type
@ publica
functio primitivumTypus(textus nomen, bivalens nullabilis) -> SemanticTypus {
    redde finge Primitivum {
        nomen: nomen,
        nullabilis: nullabilis,
        amplitudo: nihil
    } qua SemanticTypus
}

# Create a primitive type with size
@ publica
functio primitivumTypusCumAmplitudine(textus nomen, numerus amplitudo, bivalens nullabilis) -> SemanticTypus {
    redde finge Primitivum {
        nomen: nomen,
        nullabilis: nullabilis,
        amplitudo: amplitudo
    } qua SemanticTypus
}

# Create a generic type
@ publica
functio genericumTypus(textus nomen, lista<SemanticTypus> parametri, bivalens nullabilis) -> SemanticTypus {
    redde finge Genericum {
        nomen: nomen,
        parametri: parametri,
        nullabilis: nullabilis
    } qua SemanticTypus
}

# Create a function type
@ publica
functio functioTypus(
    lista<SemanticTypus> parametriTypi,
    SemanticTypus reditusTypus,
    bivalens asyncronum,
    bivalens habetCuratorem
) -> SemanticTypus {
    redde finge Functio {
        parametriTypi: parametriTypi,
        reditusTypus: reditusTypus,
        asyncronum: asyncronum,
        habetCuratorem: habetCuratorem
    } qua SemanticTypus
}

# Create a union type
@ publica
functio unioTypus(lista<SemanticTypus> typi) -> SemanticTypus {
    redde finge Unio { typi: typi } qua SemanticTypus
}

# Create an unknown type
@ publica
functio ignotumTypus(si textus ratio) -> SemanticTypus {
    redde finge Ignotum { ratio: ratio } qua SemanticTypus
}

# Create a user-defined type
@ publica
functio usitatumTypus(textus nomen, bivalens nullabilis) -> SemanticTypus {
    redde finge Usitatum {
        nomen: nomen,
        nullabilis: nullabilis
    } qua SemanticTypus
}

# Create an enum type
@ publica
functio ordoTypus(textus nomen, tabula<textus, SemanticTypus> membra, bivalens nullabilis) -> SemanticTypus {
    redde finge Ordo {
        nomen: nomen,
        membra: membra,
        nullabilis: nullabilis
    } qua SemanticTypus
}

# Create a genus type
@ publica
functio genusTypus(
    textus nomen,
    tabula<textus, SemanticTypus> agri,
    tabula<textus, SemanticTypus> methodi,
    tabula<textus, SemanticTypus> agriStatici,
    tabula<textus, SemanticTypus> methodiStatici,
    bivalens nullabilis
) -> SemanticTypus {
    redde finge Genus {
        nomen: nomen,
        agri: agri,
        methodi: methodi,
        agriStatici: agriStatici,
        methodiStatici: methodiStatici,
        nullabilis: nullabilis
    } qua SemanticTypus
}

# Create a pactum type
@ publica
functio pactumTypus(textus nomen, tabula<textus, SemanticTypus> methodi, bivalens nullabilis) -> SemanticTypus {
    redde finge Pactum {
        nomen: nomen,
        methodi: methodi,
        nullabilis: nullabilis
    } qua SemanticTypus
}

# ============================================================================
# COMMON TYPE CONSTANTS
# ============================================================================

@ publicum
fixum TEXTUS = primitivumTypus("textus", falsum)

@ publicum
fixum NUMERUS = primitivumTypus("numerus", falsum)

@ publicum
fixum FRACTUS = primitivumTypus("fractus", falsum)

@ publicum
fixum DECIMUS = primitivumTypus("decimus", falsum)

@ publicum
fixum MAGNUS = primitivumTypus("magnus", falsum)

@ publicum
fixum BIVALENS = primitivumTypus("bivalens", falsum)

@ publicum
fixum NIHIL = primitivumTypus("nihil", falsum)

@ publicum
fixum VACUUM = primitivumTypus("vacuum", falsum)

@ publicum
fixum OCTETI = primitivumTypus("octeti", falsum)

@ publicum
fixum IGNOTUM = ignotumTypus(nihil)

# ============================================================================
# TYPE UTILITIES
# ============================================================================

# Check if two types are equal
@ publica
functio typiAequales(SemanticTypus a, SemanticTypus b) -> bivalens {
    # Compare by variant tag and key fields
    # WHY: Use multi-discriminant discerne to avoid nested non-exhaustive matches.
    discerne a, b {
        casu Primitivum ut pa, Primitivum ut pb {
            redde pa.nomen == pb.nomen
        }

        casu Genericum ut ga, Genericum ut gb {
            si ga.nomen != gb.nomen {
                redde falsum
            }
            si ga.parametri.longitudo() != gb.parametri.longitudo() {
                redde falsum
            }

            varia i = 0
            ex ga.parametri pro t {
                si non typiAequales(t, gb.parametri[i]) {
                    redde falsum
                }
                i += 1
            }

            redde verum
        }

        casu Functio ut fa, Functio ut fb {
            si fa.asyncronum != fb.asyncronum {
                redde falsum
            }
            si fa.parametriTypi.longitudo() != fb.parametriTypi.longitudo() {
                redde falsum
            }
            si non typiAequales(fa.reditusTypus, fb.reditusTypus) {
                redde falsum
            }

            varia i = 0
            ex fa.parametriTypi pro t {
                si non typiAequales(t, fb.parametriTypi[i]) {
                    redde falsum
                }
                i += 1
            }

            redde verum
        }

        casu Unio ut ua, Unio ut ub {
            si ua.typi.longitudo() != ub.typi.longitudo() {
                redde falsum
            }

            varia i = 0
            ex ua.typi pro t {
                si non typiAequales(t, ub.typi[i]) {
                    redde falsum
                }
                i += 1
            }

            redde verum
        }

        casu Ignotum, Ignotum {
            redde verum
        }

        casu Usitatum ut usa, Usitatum ut usb {
            redde usa.nomen == usb.nomen
        }

        casu Ordo ut oa, Ordo ut ob {
            redde oa.nomen == ob.nomen
        }

        casu Genus ut gea, Genus ut geb {
            redde gea.nomen == geb.nomen
        }

        casu Pactum ut paa, Pactum ut pab {
            redde paa.nomen == pab.nomen
        }

        casu _, _ {
            redde falsum
        }
    }
}

# Check if a type is assignable to another type
@ publica
functio assignabileAd(SemanticTypus fons, SemanticTypus scopus) -> bivalens {
    # Unknown is assignable to anything
    discerne fons {
        casu Ignotum {
            redde verum
        }
        casu _ { }
    }

    discerne scopus {
        casu Ignotum {
            redde verum
        }
        casu _ { }
    }

    # nihil is assignable to nullable types
    discerne fons {
        casu Primitivum ut p {
            si p.nomen == "nihil" {
                discerne scopus {
                    casu Primitivum ut sp {
                        redde sp.nullabilis
                    }
                    casu Genericum ut sg {
                        redde sg.nullabilis
                    }
                    casu Usitatum ut su {
                        redde su.nullabilis
                    }
                    casu Ordo ut so {
                        redde so.nullabilis
                    }
                    casu Genus ut sge {
                        redde sge.nullabilis
                    }
                    casu Pactum ut spa {
                        redde spa.nullabilis
                    }
                    casu _ {
                        redde falsum
                    }
                }
            }
        }
        casu _ { }
    }

    # Numeric type promotion: numerus -> fractus, numerus -> decimus
    discerne fons {
        casu Primitivum ut pf {
            discerne scopus {
                casu Primitivum ut ps {
                    si estNumericum(pf.nomen) et estNumericum(ps.nomen) {
                        redde verum
                    }
                }
                casu _ { }
            }
        }
        casu _ { }
    }

    # Check if source is in target union
    discerne scopus {
        casu Unio ut u {
            ex u.typi pro t {
                si assignabileAd(fons, t) {
                    redde verum
                }
            }
            redde falsum
        }
        casu _ { }
    }

    # Source union must have all types assignable to target
    discerne fons {
        casu Unio ut u {
            ex u.typi pro t {
                si non assignabileAd(t, scopus) {
                    redde falsum
                }
            }
            redde verum
        }
        casu _ { }
    }

    # Otherwise check equality
    redde typiAequales(fons, scopus)
}

# Helper: check if type name is numeric
@ publica
functio estNumericum(textus nomen) -> bivalens {
    redde nomen inter ["numerus", "fractus", "decimus"]
}

# Format a type for error messages
@ publica
functio formaTypum(SemanticTypus t) -> textus {
    discerne t {
        casu Primitivum ut p {
            varia resultatum = p.nomen
            si p.amplitudo != nihil {
                resultatum = scriptum("§<§>", resultatum, p.amplitudo)
            }
            si p.nullabilis {
                resultatum = scriptum("§?", resultatum)
            }
            redde resultatum
        }

        casu Genericum ut g {
            # Build parameter list
            varia params = [] innatum lista<textus>
            ex g.parametri pro typ {
                params.adde(formaTypum(typ))
            }
            varia resultatum = scriptum("§<§>", g.nomen, params.coniunge(", "))
            si g.nullabilis {
                resultatum = scriptum("§?", resultatum)
            }
            redde resultatum
        }

        casu Functio ut f {
            # Build parameter list
            varia params = [] innatum lista<textus>
            ex f.parametriTypi pro typ {
                params.adde(formaTypum(typ))
            }
            fixum asyncPraefix = f.asyncronum sic "futura " secus ""
            redde scriptum("§(§) -> §", asyncPraefix, params.coniunge(", "), formaTypum(f.reditusTypus))
        }

        casu Unio ut u {
            varia parts = [] innatum lista<textus>
            ex u.typi pro typ {
                parts.adde(formaTypum(typ))
            }
            redde parts.coniunge(" | ")
        }

        casu Ignotum ut ig {
            si ig.ratio != nihil {
                redde scriptum("ignotum(§)", ig.ratio)
            }
            redde "ignotum"
        }

        casu Usitatum ut u {
            si u.nullabilis {
                redde scriptum("§?", u.nomen)
            }
            redde u.nomen
        }

        casu Ordo ut o {
            si o.nullabilis {
                redde scriptum("ordo §?", o.nomen)
            }
            redde scriptum("ordo §", o.nomen)
        }

        casu Genus ut g {
            si g.nullabilis {
                redde scriptum("genus §?", g.nomen)
            }
            redde scriptum("genus §", g.nomen)
        }

        casu Pactum ut p {
            si p.nullabilis {
                redde scriptum("pactum §?", p.nomen)
            }
            redde scriptum("pactum §", p.nomen)
        }
    }

    redde "ignotum"
}
