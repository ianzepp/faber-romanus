# Errores - Semantic Error Catalog
#
# Defines all error codes and messages for semantic analysis.

# ============================================================================
# ERROR CODES
# ============================================================================

# Semantic error codes (S-prefix identifies semantic phase)
@ publicus
ordo SemanticErrorCodice {
    UndefinedVariable       # S001: Undefined variable
    AlreadyDefined          # S002: Already defined in scope
    ImmutableAssignment     # S003: Cannot assign to immutable
    TypeMismatch            # S004: Type mismatch
    ReturnTypeMismatch      # S005: Return type mismatch
    NoTypeOrInitializer     # S006: Variable needs type or initializer
    NotExportedFromModule   # S007: Name not exported from module
    IncompatibleComparison  # S008: Cannot compare these types
    CedeOutsideAsync        # S009: cede requires async/generator
    AwaitOutsideAsync       # S010: await requires async
    DefaultWithBorrowedParam # S011: Cannot use default with borrowed param
    ModuleNotFound          # S012: Cannot find module
    CircularImport          # S013: Circular import detected
    ModuleParseError        # S014: Failed to parse module
    MissingFunctionBody     # S016: Function has no body (not @ externa)
}

# ============================================================================
# ERROR MESSAGE STRUCTURE
# ============================================================================

# Error message with text and help
@ publicum
genus SemanticErrorNuntius {
    textus textus               # user-facing error message
    textus auxilium             # helpful guidance
}

# ============================================================================
# ERROR MESSAGE FUNCTIONS
# ============================================================================

# Undefined variable error
@ publica
functio undefinedVariableError(textus nomen) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Undefined variable '§'", nomen),
        auxilium: "Variables must be declared with 'varia' or 'fixum' before use"
    } qua SemanticErrorNuntius
}

# Already defined error
@ publica
functio alreadyDefinedError(textus nomen, numerus linea) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("'§' is already defined at line §", nomen, linea),
        auxilium: "Each name can only be defined once in the same scope. Use a different name or assign to the existing variable."
    } qua SemanticErrorNuntius
}

# Immutable assignment error
@ publica
functio immutableAssignmentError(textus nomen) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Cannot assign to immutable variable '§'", nomen),
        auxilium: "Variables declared with 'fixum' cannot be reassigned. Use 'varia' for mutable variables."
    } qua SemanticErrorNuntius
}

# Type mismatch error
@ publica
functio typeMismatchError(textus sourceType, textus targetType) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Type '§' is not assignable to type '§'", sourceType, targetType),
        auxilium: "Ensure the types are compatible. You may need a type conversion or to change the variable type."
    } qua SemanticErrorNuntius
}

# Return type mismatch error
@ publica
functio returnTypeMismatchError(textus returnType, textus functionType) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Return type '§' is not assignable to function return type '§'", returnType, functionType),
        auxilium: "The returned value must match the function return type annotation."
    } qua SemanticErrorNuntius
}

# No type or initializer error
@ publica
functio noTypeOrInitializerError(textus nomen) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Variable '§' has no type annotation or initializer", nomen),
        auxilium: "Variables must have either a type annotation (e.g., 'numerus x') or an initializer (e.g., 'varia x = 5')."
    } qua SemanticErrorNuntius
}

# Not exported from module error
@ publica
functio notExportedFromModuleError(textus nomen, textus modulus) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("'§' is not exported from '§'", nomen, modulus),
        auxilium: "Check the module documentation for available exports. You may have a typo in the import name."
    } qua SemanticErrorNuntius
}

# Incompatible comparison error
@ publica
functio incompatibleComparisonError(textus leftType, textus rightType, textus operator) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Cannot compare '§' with '§' using '§'", leftType, rightType, operator),
        auxilium: "Comparison operators require operands of the same type. Both sides must be numbers or both must be strings."
    } qua SemanticErrorNuntius
}

# Cede outside async error
@ publica
functio cedeOutsideAsyncError() -> SemanticErrorNuntius {
    redde {
        textus: "'cede' requires an async or generator function context",
        auxilium: "Use 'fiet' for async functions, 'fiunt' for generators, or 'fient' for async generators."
    } qua SemanticErrorNuntius
}

# Await outside async error
@ publica
functio awaitOutsideAsyncError(textus keyword) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("'§' requires an async function context", keyword),
        auxilium: "Use 'fiet' or 'fient' to declare an async function."
    } qua SemanticErrorNuntius
}

# Default with borrowed param error
@ publica
functio defaultWithBorrowedParamError(textus preposition) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Cannot use default value with '§' (borrowed) parameter", preposition),
        auxilium: "Default values require owned parameters. Remove the 'de' or 'in' preposition, or remove the default value."
    } qua SemanticErrorNuntius
}

# Module not found error
@ publica
functio moduleNotFoundError(textus path) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Cannot find module '§'", path),
        auxilium: "Verify the file path is correct and the file exists. Relative paths are resolved from the importing file."
    } qua SemanticErrorNuntius
}

# Circular import error
@ publica
functio circularImportError(textus path, textus cycle) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Circular import detected: §", cycle),
        auxilium: "Break the cycle by restructuring your modules or using forward declarations for types."
    } qua SemanticErrorNuntius
}

# Module parse error
@ publica
functio moduleParseError(textus path) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Failed to parse module '§'", path),
        auxilium: "Fix the syntax errors in the imported module before importing it."
    } qua SemanticErrorNuntius
}

# Missing function body error
@ publica
functio missingFunctionBodyError(textus nomen) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Function '§' has no body", nomen),
        auxilium: "Regular functions require a body. Use '@ externa' annotation for external declarations."
    } qua SemanticErrorNuntius
}

# Morphologia stem not declared error
@ publica
functio morphologiaRadixNonDeclarataError(textus methodus, textus radix, textus forma, textus recipiens, lista<textus> formae) -> SemanticErrorNuntius {
    fixum aux = formae.longitudo() == 0 sic "Allowed forms for this stem: (none)" secus scriptum("Allowed forms for this stem: §", formae.coniunge(", "))
    redde {
        textus: scriptum("Morphologia stem '§' is not declared for '§' (method '§', forma '§'). §", radix, recipiens, methodus, forma, aux),
        auxilium: aux
    } qua SemanticErrorNuntius
}

# Morphologia form not permitted error
@ publica
functio morphologiaFormaNonPermissaError(textus methodus, textus radix, textus forma, textus recipiens, lista<textus> formae) -> SemanticErrorNuntius {
    fixum aux = scriptum("Allowed forms for this stem: §", formae.coniunge(", "))
    redde {
        textus: scriptum("Morphologia forma '§' is not allowed for stem '§' on '§' (method '§'). §", forma, radix, recipiens, methodus, aux),
        auxilium: aux
    } qua SemanticErrorNuntius
}
