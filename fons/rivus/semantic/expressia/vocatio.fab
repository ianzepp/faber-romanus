# Call and Member Expression Resolution
#
# Handles: function calls, method calls, member access

ex "../resolvitor" importa Resolvitor
ex "../typi" importa SemanticTypus, TEXTUS, NUMERUS, BIVALENS, IGNOTUM
ex "../errores" importa morphologiaRadixNonDeclarataError, morphologiaFormaNonPermissaError
ex "../../ast/expressia" importa Expressia, MorphologiaInvocatio
ex "../../parser/morphologia" importa parseMethodum, formaExFlagga

# =============================================================================
# CALL EXPRESSION RESOLUTION
# =============================================================================

# Resolve a function call expression
@ publica
functio resolveVocatio(Resolvitor r, Expressia vocatioExpr) -> SemanticTypus {
    discerne vocatioExpr {
        casu VocatioExpressia ut v {
            fixum vocatumTypus = r.expressia(v.vocatum)

            # Resolve all arguments
            ex v.argumenta pro arg {
                r.expressia(arg)
            }

            # Morphologia dispatch validation (receiver-bound)
            discerne v.vocatum {
                casu MembrumExpressia ut m {
                    si non (m.computatum qua bivalens) {
                        discerne m.proprietas {
                            casu Nomen ut n {
                                fixum parsed = parseMethodum(n.valor)
                                si nonnihil parsed {
                                    fixum obiectumTypus = r.expressia(m.obiectum)
                                    fixum recipiens = nomenReceptor(obiectumTypus)
                                    si nonnihil recipiens {
                                        fixum receiver = recipiens qua textus
                                        si r.analyzator().habetMorphologiam(receiver) {
                                            fixum formae = r.analyzator().formaeMorphologiae(receiver, parsed.radix)

                                            # EDGE: Avoid lexical hijacking. Only treat a call as morphologia if
                                            # the stem is actually declared for this receiver.
                                            si nonnihil formae {
                                                fixum forma = formaExFlagga(parsed.flagga)
                                                si non estFormaPermissa(formae qua lista<textus>, forma) {
                                                    fixum err = morphologiaFormaNonPermissaError(n.valor, parsed.radix, forma, receiver, formae qua lista<textus>)
                                                    r.analyzator().error(err.textus, n.locus)
                                                } secus {
                                                    v.morphologia = {
                                                        recipiens: receiver,
                                                        radix: parsed.radix,
                                                        forma: forma
                                                    } qua MorphologiaInvocatio
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            # If callee is a function type, return its return type
            discerne vocatumTypus {
                casu Functio ut f {
                    redde f.reditusTypus
                }
            }

            # Otherwise unknown
            redde IGNOTUM
        }
    }

    redde IGNOTUM
}

functio nomenReceptor(SemanticTypus t) -> textus? {
    discerne t {
        casu Genericum ut g {
            redde g.nomen
        }
        casu Genus ut g {
            redde g.nomen
        }
        casu Pactum ut p {
            redde p.nomen
        }
        casu Usitatum ut u {
            redde u.nomen
        }
    }
    redde nihil
}

functio estFormaPermissa(lista<textus> formae, textus forma) -> bivalens {
    ex formae pro item {
        si item == forma {
            redde verum
        }
    }
    redde falsum
}

# =============================================================================
# MEMBER EXPRESSION RESOLUTION
# =============================================================================

# Resolve a member access expression (obj.prop or obj[key])
@ publica
functio resolveMembrum(Resolvitor r, Expressia membrumExpr) -> SemanticTypus {
    discerne membrumExpr {
        casu MembrumExpressia ut m {
            fixum obiectumTypus = r.expressia(m.obiectum)

            # If computed access (obj[key]), resolve the key
            si m.computatum {
                r.expressia(m.proprietas)
            }

            # Handle known collection methods
            discerne obiectumTypus {
                casu Genericum ut g {
                    # lista methods
                    si g.nomen == "lista" {
                        discerne m.proprietas {
                            casu Nomen ut n {
                                # lista.longitudo -> numerus
                                si n.valor == "longitudo" {
                                    redde NUMERUS
                                }
                                # lista.primus, lista.ultimus -> element type
                                si n.valor inter ["primus", "ultimus"] {
                                    si g.parametri.longitudo() > 0 {
                                        redde g.parametri.primus()
                                    }
                                }
                                # lista.vacua -> bivalens
                                si n.valor == "vacua" {
                                    redde BIVALENS
                                }
                            }
                        }

                        # Indexed access: lista[i] -> element type
                        si m.computatum et g.parametri.longitudo() > 0 {
                            redde g.parametri.primus()
                        }
                    }
                }

                casu Primitivum ut p {
                    si p.nomen == "textus" {
                        discerne m.proprietas {
                            casu Nomen ut n {
                                si n.valor == "longitudo" {
                                    redde NUMERUS
                                }
                            }
                        }
                        # Indexed access: textus[i] -> textus (single char)
                        si m.computatum {
                            redde TEXTUS
                        }
                    }
                }

                # Genus type - look up field/method
                casu Genus ut ge {
                    discerne m.proprietas {
                        casu Nomen ut n {
                            si nonnihil ge.agri[n.valor] {
                                redde ge.agri[n.valor]
                            }
                            si nonnihil ge.methodi[n.valor] {
                                redde ge.methodi[n.valor]
                            }
                        }
                    }
                }
            }

            redde IGNOTUM
        }
    }

    redde IGNOTUM
}
