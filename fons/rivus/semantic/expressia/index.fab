# Expressia - Expression Resolution Dispatcher
#
# Routes expression AST nodes to their appropriate resolution functions.

ex "../resolvitor" importa Resolvitor
ex "../typi" importa SemanticTypus, TEXTUS, NUMERUS, BIVALENS, NIHIL, IGNOTUM
ex "../typi" importa usitatumTypus, genericumTypus
ex "../typi" importa formaTypum, assignabileAd
ex "../errores" importa immutableAssignmentError, typeMismatchError, undefinedVariableError
ex "../../ast/expressia" importa Expressia, CatenaGradus
ex "../../ast/typus" importa TypusAnnotatio

ex "./primaria" importa resolveNomen, resolveLittera, resolveSeries, resolveObiectum
ex "./binaria" importa resolveBinaria
ex "./unaria" importa resolveUnaria
ex "./vocatio" importa resolveVocatio, resolveMembrum
ex "./alia" importa resolveLambda, resolveFingeExpr, resolveCedeExpr, resolveNovumExpr, resolveCondicio
ex "../sententia/declara" importa resolveTypusAnnotatio

# ============================================================================
# MAIN DISPATCHER
# ============================================================================

# Resolve any expression and return its semantic type
@ publica
functio resolveExpressia(Resolvitor r, Expressia expr) -> SemanticTypus {
    discerne expr {
        # Identifiers (variable references)
        casu Nomen {
            redde resolveNomen(r, expr)
        }

        # Literals (numbers, strings, booleans)
        casu Littera {
            redde resolveLittera(r, expr)
        }

        # Template literals (interpolated strings)
        casu LitteraExemplar {
            redde TEXTUS
        }

        # Binary expressions (+, -, *, /, ==, etc.)
        casu BinariaExpressia {
            redde resolveBinaria(r, expr)
        }

        # Unary expressions (!, -, non, etc.)
        casu UnariaExpressia {
            redde resolveUnaria(r, expr)
        }

        # Function calls
        casu VocatioExpressia {
            redde resolveVocatio(r, expr)
        }

        # Member access (obj.prop)
        casu MembrumExpressia {
            redde resolveMembrum(r, expr)
        }

        # Assignment (x = value)
        casu AssignatioExpressia ut as {
            redde resolveAssignatio(r, as)
        }

        # Await expression (cede)
        casu CedeExpressia {
            redde resolveCedeExpr(r, expr)
        }

        # New expression (novum)
        casu NovumExpressia {
            redde resolveNovumExpr(r, expr)
        }

        # Tagged union construction (finge)
        casu FingeExpressia {
            redde resolveFingeExpr(r, expr)
        }

        # Ternary conditional
        casu CondicioExpressia {
            redde resolveCondicio(r, expr)
        }

        # Range expression (1..10)
        casu AmbitusExpressia {
            redde genericumTypus("lista", [NUMERUS], falsum)
        }

        # Object literal { key: value }
        casu ObiectumExpressia {
            redde resolveObiectum(r, expr)
        }

        # Array literal [1, 2, 3]
        casu SeriesExpressia {
            redde resolveSeries(r, expr)
        }

        # Lambda expression (pro x: x + 1)
        casu LambdaExpressia {
            redde resolveLambda(r, expr)
        }

        # Self reference (ego/hoc)
        casu EgoExpressia {
            # ego type depends on enclosing class context
            redde IGNOTUM
        }

        # Type cast (expr qua Type)
        casu QuaExpressia ut q {
            r.expressia(q.expressia)
            # Resolve target type annotation and return it
            fixum targetTypus = resolveTypusAnnotatio(r, q.scopus)
            redde targetTypus
        }

        # Native type construction ([] innatum lista<T>, {} innatum tabula<K,V>)
        casu InnatumExpressia ut i {
            r.expressia(i.expressia)
            fixum targetTypus = resolveTypusAnnotatio(r, i.scopus)
            redde targetTypus
        }

        # Type check (expr est Type)
        casu EstExpressia {
            redde BIVALENS
        }

        # Format string (scriptum)
        casu ScriptumExpressia ut s {
            ex s.argumenta pro arg {
                r.expressia(arg)
            }
            redde TEXTUS
        }

        # Read stdin (lege)
        casu LegeExpressia {
            redde TEXTUS
        }

        # Regex literal
        casu LitteraRegex {
            redde usitatumTypus("Regex", falsum)
        }

        # Collection DSL pipeline (ex items prima 5)
        casu CatenaExpressia ut c {
            # WHY: DSL expressions resolve to source type after transforms.
            # Most operations (prima, ultima, ordina) preserve element type.
            # summa would change to numerus, but basic inference returns source type.
            fixum fonsTypus = r.expressia(c.fons)
            redde fonsTypus
        }

        # Filter DSL (ab items activus)
        casu AbExpressia ut abExpr {
            # WHY: Filtering doesn't change element type, only reduces collection.
            fixum fonsTypus = r.expressia(abExpr.fons)

            # Resolve filter condition if present (ubi form)
            si nonnihil abExpr.filtrum {
                fixum filtrum = abExpr.filtrum
                si filtrum.habetUbi {
                    r.expressia(filtrum.condicio)
                }
            }

            redde fonsTypus
        }

        # Type conversion (numeratum, fractatum, textatum, bivalentum)
        casu ConversioExpressia ut c {
            r.expressia(c.expressia)

            # Resolve fallback if present
            si nonnihil c.fallback {
                r.expressia(c.fallback qua Expressia)
            }

            # Resolve target type if present
            si nonnihil c.scopusTypus {
                resolveTypusAnnotatio(r, c.scopusTypus qua TypusAnnotatio)
            }

            # Return type depends on conversion operator
            elige c.signum qua textus {
                casu "numeratum" reddit NUMERUS
                casu "fractatum" reddit usitatumTypus("fractus", falsum)
                casu "textatum" reddit TEXTUS
                casu "bivalentum" reddit BIVALENS
            }

            redde IGNOTUM
        }

        casu _ { }
    }

    redde IGNOTUM
}

# ============================================================================
# HELPER RESOLVERS
# ============================================================================

# Resolve assignment expression
@ publica
functio resolveAssignatio(Resolvitor r, Expressia assignatioExpr) -> SemanticTypus {
    fixum a = r.analyzator()

    discerne assignatioExpr {
        casu AssignatioExpressia ut as {
            fixum dexterTypus = r.expressia(as.dexter)

            discerne as.sinister {
                casu Nomen ut n {
                    fixum symbolum = a.quaere(n.valor)
                    si nihil symbolum {
                        fixum err = undefinedVariableError(n.valor)
                        a.error(err.textus, n.locus)
                        redde IGNOTUM
                    }

                    si non symbolum.mutabilis {
                        fixum err = immutableAssignmentError(symbolum.nomen)
                        a.error(err.textus, as.locus)
                    }

                    si non assignabileAd(dexterTypus, symbolum.semanticTypus) {
                        fixum err = typeMismatchError(formaTypum(dexterTypus), formaTypum(symbolum.semanticTypus))
                        a.error(err.textus, as.locus)
                    }

                    redde symbolum.semanticTypus
                }

                casu MembrumExpressia ut m {
                    # TODO: Resolve member types once genus metadata exists.
                    r.expressia(m.obiectum)
                    # WHY: Only resolve property for computed (indexed) access.
                    # For dot access (obj.field), property is a field name, not a variable.
                    si m.computatum {
                        r.expressia(m.proprietas)
                    }
                    redde dexterTypus
                }
                casu _ { }
            }

            redde dexterTypus
        }
        casu _ { }
    }

    redde IGNOTUM
}
