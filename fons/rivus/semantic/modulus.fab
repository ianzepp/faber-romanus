# Modulus - Module Resolution for Local File Imports
#
# Handles resolution of local .fab file imports during semantic analysis.
# Provides path resolution, file loading, export extraction, and caching.
#
# Resolution rules:
# - Paths starting with "./" or "../" are local file imports
# - ".fab" extension is implicit and added automatically
# - "norma" and "norma/*" are handled as compiler intrinsics (not files)
# - Other paths pass through to target language (external packages)

ex "./typi" importa SemanticTypus, IGNOTUM, VACUUM, functioTypus, usitatumTypus
ex "./scopus" importa SymbolumSpecies
ex "../ast/positio" importa Locus
ex "../ast/radix" importa Programma
ex "../ast/sententia" importa Sententia
ex "../lexor/index" importa lexare, LexorResultatum
ex "../parser/index" importa resolvere, ParserResultatum

# ============================================================================
# FILE I/O DECLARATIONS (extern - implementations injected post-build)
# ============================================================================

@ externa
functio _readFileSync(textus via) -> textus

@ externa
functio _existsSync(textus via) -> bivalens

@ externa
functio _dirname(textus via) -> textus

@ externa
functio _resolve(textus basis, textus relativum) -> textus

# ============================================================================
# TYPES
# ============================================================================

# Export information extracted from a module
@ publicum
genus ModulusExportum {
    textus nomen                    # exported name
    SymbolumSpecies species         # symbol kind (Functio, Genus, etc.)
    SemanticTypus typus             # type (IGNOTUM for most)
    Locus locus                     # source location
}

# Resolved module with its exports
@ publicum
genus ModulusResolutum {
    tabula<textus, ModulusExportum> exporta    # map of name -> export info
    textus via                                  # absolute file path
    Programma? programma                        # parsed AST (for future multi-file codegen)
}

# ============================================================================
# PATH HELPERS
# ============================================================================

# Check if import source is a local file (starts with ./ or ../)
@ publica
functio estLocaleImportum(textus fons) -> bivalens {
    redde fons.startsWith("./") aut fons.startsWith("../")
}

# Check if import source is norma stdlib
@ publica
functio estNormaImportum(textus fons) -> bivalens {
    redde fons == "norma" aut fons.startsWith("norma/")
}

# Resolve import path to absolute filesystem path
# Returns nihil if file doesn't exist
@ publica
functio resolveViaModuli(textus fons, textus viaBasica) -> textus? {
    # Get directory of importing file
    fixum directorium = _dirname(viaBasica)

    # Add .fab extension if missing
    varia via = fons
    si non via.endsWith(".fab") {
        via = via + ".fab"
    }

    # Resolve to absolute path
    fixum viaAbsoluta = _resolve(directorium, via)

    # Check existence
    si non _existsSync(viaAbsoluta) {
        redde nihil
    }

    redde viaAbsoluta
}

# ============================================================================
# EXPORT EXTRACTION
# ============================================================================

# Extract exports from a parsed program
# All top-level declarations become exports
@ publica
functio extraheExporta(Programma programma, textus via) -> ModulusResolutum {
    varia exporta = {} innatum tabula<textus, ModulusExportum>

    ex programma.corpus pro stmt {
        discerne stmt {
            casu FunctioDeclaratio ut f {
                exporta[f.nomen] = {
                    nomen: f.nomen,
                    species: SymbolumSpecies.Functio,
                    typus: functioTypus([], IGNOTUM, f.asynca, falsum),
                    locus: f.locus
                } qua ModulusExportum
            }
            casu GenusDeclaratio ut g {
                exporta[g.nomen] = {
                    nomen: g.nomen,
                    species: SymbolumSpecies.Genus,
                    typus: usitatumTypus(g.nomen, falsum),
                    locus: g.locus
                } qua ModulusExportum
            }
            casu PactumDeclaratio ut p {
                exporta[p.nomen] = {
                    nomen: p.nomen,
                    species: SymbolumSpecies.Pactum,
                    typus: usitatumTypus(p.nomen, falsum),
                    locus: p.locus
                } qua ModulusExportum
            }
            casu OrdoDeclaratio ut o {
                exporta[o.nomen] = {
                    nomen: o.nomen,
                    species: SymbolumSpecies.Ordo,
                    typus: usitatumTypus(o.nomen, falsum),
                    locus: o.locus
                } qua ModulusExportum
            }
            casu DiscretioDeclaratio ut d {
                exporta[d.nomen] = {
                    nomen: d.nomen,
                    species: SymbolumSpecies.TypusAlias,
                    typus: usitatumTypus(d.nomen, falsum),
                    locus: d.locus
                } qua ModulusExportum
            }
            casu TypusAliasDeclaratio ut t {
                exporta[t.nomen] = {
                    nomen: t.nomen,
                    species: SymbolumSpecies.TypusAlias,
                    typus: usitatumTypus(t.nomen, falsum),
                    locus: t.locus
                } qua ModulusExportum
            }
            casu VariaSententia ut v {
                # VariaSententia.nomen is a string (destructuring has separate types)
                exporta[v.nomen] = {
                    nomen: v.nomen,
                    species: SymbolumSpecies.Variabilis,
                    typus: IGNOTUM,
                    locus: v.locus
                } qua ModulusExportum
            }
            casu _ { }
        }
    }

    redde {
        exporta: exporta,
        via: via,
        programma: programma
    } qua ModulusResolutum
}

# ============================================================================
# MODULE RESOLUTION
# ============================================================================

# Main entry point: resolve and load a local module
# Returns nihil on error (file not found, parse error, etc.)
#
# Parameters:
#   fons - import source string (e.g., "./utils")
#   viaBasica - absolute path of the importing file
#   cache - module cache (path -> resolved module)
#   inProgressu - set of paths currently being resolved (for cycle detection)
#
@ publica
functio resolveModulum(
    textus fons,
    textus viaBasica,
    tabula<textus, ModulusResolutum> cache,
    copia<textus> inProgressu
) -> ModulusResolutum? {
    # Resolve to absolute path
    fixum viaAbsoluta = resolveViaModuli(fons, viaBasica)
    si nihil viaAbsoluta {
        redde nihil  # File not found
    }

    fixum via = viaAbsoluta qua textus

    # Check cache first
    si nonnihil cache[via] {
        redde cache[via]
    }

    # Check for cycles - return empty exports (JS/TS hoisting behavior)
    si inProgressu.has(via) {
        redde {
            exporta: {} innatum tabula<textus, ModulusExportum>,
            via: via,
            programma: nihil
        } qua ModulusResolutum
    }

    # Mark as in progress
    inProgressu.add(via)

    # Load and parse
    fixum sourceCode = _readFileSync(via)
    fixum lexResult = lexare(sourceCode)
    si lexResult.errores.longitudo() > 0 {
        inProgressu.delete(via)
        redde nihil  # Lexer error
    }

    fixum parseResult = resolvere(lexResult.symbola)
    si parseResult.errores.longitudo() > 0 aut nihil parseResult.programma {
        inProgressu.delete(via)
        redde nihil  # Parse error
    }

    # Extract exports
    fixum modulus = extraheExporta(parseResult.programma qua Programma, via)

    # Cache before recursing (handles diamond dependencies)
    cache[via] = modulus

    # Recursively resolve child imports (for cycle detection)
    ex (parseResult.programma qua Programma).corpus pro stmt {
        discerne stmt {
            casu ImportaSententia ut imp {
                si estLocaleImportum(imp.fons) {
                    resolveModulum(imp.fons, via, cache, inProgressu)
                }
            }
            casu _ { }
        }
    }

    # Remove from in progress
    inProgressu.delete(via)

    redde modulus
}
