# Semantic - Entry Point
#
# Performs semantic analysis on the AST. Resolves types, builds symbol tables.

ex "./resolvitor" importa Resolvitor
ex "./nucleus" importa Analyzator, SemanticResultatum, novumAnalyzator
ex "./typi" importa SemanticTypus, IGNOTUM, VACUUM, functioTypus, usitatumTypus
ex "./scopus" importa Symbolum, SymbolumSpecies
ex "./modulus" importa estLocaleImportum, estNormaImportum, resolveModulum, ModulusExportum
ex "./expressia/index" importa resolveExpressia
ex "./sententia/index" importa analyzeSententia
ex "../ast/radix" importa Programma
ex "../ast/expressia" importa Expressia
ex "../ast/sententia" importa Sententia, MorphologiaDeclaratio
ex "../parser/morphologia" importa parseMethodum

# ============================================================================
# RESOLVITOR IMPLEMENTATION
# ============================================================================

# Concrete implementation of the Resolvitor pactum
@ publicum
genus ResolvitorImpl implet Resolvitor {
    Analyzator a

    @ publica
    functio analyzator() -> Analyzator {
        redde ego.a
    }

    @ publica
    functio expressia(Expressia expr) -> SemanticTypus {
        redde resolveExpressia(ego qua Resolvitor, expr)
    }

    @ publica
    functio sententia(Sententia stmt) -> vacuum {
        analyzeSententia(ego qua Resolvitor, stmt)
    }
}

# Create a new Resolvitor
@ publica
functio novumResolvitor(Analyzator a) -> Resolvitor {
    redde { a: a } qua ResolvitorImpl qua Resolvitor
}

# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

# Perform semantic analysis on a program
# viaIngressus: optional path to the entry file (needed for local import resolution)
@ publica
functio analyze(Programma programma, textus? viaIngressus) -> SemanticResultatum {
    # Create analyzer state
    fixum a = novumAnalyzator(viaIngressus)
    fixum r = novumResolvitor(a)

    # Phase 1: Predeclare all top-level names
    # (allows forward references)
    ex programma.corpus pro stmt {
        predeclare(r, stmt)
    }

    # Phase 2: Analyze all statements
    ex programma.corpus pro stmt {
        r.sententia(stmt)
    }

    # Return result
    redde {
        programma: programma,
        errores: a.errores
    } qua SemanticResultatum
}

# ============================================================================
# PREDECLARATION
# ============================================================================

# Predeclare a top-level statement (registers placeholder types)
@ publica
functio predeclare(Resolvitor r, Sententia stmt) -> vacuum {
    fixum a = r.analyzator()

    discerne stmt {
        # Function declaration - register name with function type
        casu FunctioDeclaratio ut f {
            # Build placeholder function type
            # WHY: Use IGNOTUM (not VACUUM) when return type is declared, matching faber.
            # This allows forward function calls to pass type checks during body analysis.
            varia paramTypi = [] innatum lista<SemanticTypus>
            ex f.parametra pro param {
                paramTypi.adde(IGNOTUM)
            }
            fixum reditusTypus = nonnihil f.typusReditus sic IGNOTUM secus VACUUM
            fixum fnTypus = functioTypus(paramTypi, reditusTypus, f.asynca, falsum)

            a.definie({
                nomen: f.nomen,
                semanticTypus: fnTypus,
                species: SymbolumSpecies.Functio,
                mutabilis: falsum,
                locus: f.locus
            } qua Symbolum)
        }

        # Genus declaration - register name with user type
        casu GenusDeclaratio ut g {
            a.definie({
                nomen: g.nomen,
                semanticTypus: usitatumTypus(g.nomen, falsum),
                species: SymbolumSpecies.Genus,
                mutabilis: falsum,
                locus: g.locus
            } qua Symbolum)

            ex g.methodi pro methodus {
                discerne methodus {
                    casu FunctioDeclaratio ut f {
                        si nonnihil f.morphologia {
                            fixum parsed = parseMethodum(f.nomen)
                            si nonnihil parsed {
                                fixum nota = f.morphologia qua MorphologiaDeclaratio
                                a.addeMorphologiam(g.nomen, parsed.radix, nota.formae)
                            }
                        }
                    }
                    casu _ { }
                }
            }
        }

        # Pactum declaration - register name with user type
        casu PactumDeclaratio ut p {
            a.definie({
                nomen: p.nomen,
                semanticTypus: usitatumTypus(p.nomen, falsum),
                species: SymbolumSpecies.Pactum,
                mutabilis: falsum,
                locus: p.locus
            } qua Symbolum)

            ex p.methodi pro methodus {
                si nonnihil methodus.morphologia {
                    fixum parsed = parseMethodum(methodus.nomen)
                    si nonnihil parsed {
                        fixum nota = methodus.morphologia qua MorphologiaDeclaratio
                        a.addeMorphologiam(p.nomen, parsed.radix, nota.formae)
                    }
                }
            }
        }

        # Ordo declaration - register name with user type
        casu OrdoDeclaratio ut o {
            a.definie({
                nomen: o.nomen,
                semanticTypus: usitatumTypus(o.nomen, falsum),
                species: SymbolumSpecies.Ordo,
                mutabilis: falsum,
                locus: o.locus
            } qua Symbolum)
        }

        # Discretio declaration - register name with user type
        casu DiscretioDeclaratio ut d {
            a.definie({
                nomen: d.nomen,
                semanticTypus: usitatumTypus(d.nomen, falsum),
                species: SymbolumSpecies.TypusAlias,
                mutabilis: falsum,
                locus: d.locus
            } qua Symbolum)
        }

        # Typus alias - register name with user type
        casu TypusAliasDeclaratio ut t {
            a.definie({
                nomen: t.nomen,
                semanticTypus: usitatumTypus(t.nomen, falsum),
                species: SymbolumSpecies.TypusAlias,
                mutabilis: falsum,
                locus: t.locus
            } qua Symbolum)
        }

        # Import declaration - resolve module and register symbols
        casu ImportaSententia ut imp {
            # Skip norma imports (handled by intrinsics)
            si estNormaImportum(imp.fons) {
                # Norma symbols are defined via definieIntrinsica()
                # No additional work needed
            }
            # Handle local file imports
            sin estLocaleImportum(imp.fons) {
                # Need file path context for resolution
                si nihil a.viaIngressus {
                    a.error(scriptum("Cannot resolve local import without file context: ยง", imp.fons), imp.locus)
                } secus {
                    fixum modulus = resolveModulum(
                        imp.fons,
                        a.viaIngressus qua textus,
                        a.modulusCache,
                        a.modulusInProgressu
                    )

                    si nihil modulus {
                        a.error(scriptum("Module not found: ยง", imp.fons), imp.locus)
                    } secus {
                        # Wildcard import: ex "./x" importa * ut alias
                        si imp.totum {
                            si nonnihil imp.totumAlias {
                                # Define namespace alias
                                a.definie({
                                    nomen: imp.totumAlias qua textus,
                                    semanticTypus: IGNOTUM,
                                    species: SymbolumSpecies.Variabilis,
                                    mutabilis: falsum,
                                    locus: imp.locus
                                } qua Symbolum)
                            }
                            # Also add all individual exports to scope
                            de modulus.exporta pro nomen {
                                fixum exportum = modulus.exporta[nomen] qua ModulusExportum
                                a.definie({
                                    nomen: exportum.nomen,
                                    semanticTypus: exportum.typus,
                                    species: exportum.species,
                                    mutabilis: falsum,
                                    locus: exportum.locus
                                } qua Symbolum)
                            }
                        } secus {
                            # Named imports: ex "./x" importa foo, bar ut b
                            ex imp.specificatores pro spec {
                                si nonnihil modulus.exporta[spec.importatum] {
                                    fixum exportum = modulus.exporta[spec.importatum] qua ModulusExportum
                                    a.definie({
                                        nomen: spec.locale,  # Use local alias if provided
                                        semanticTypus: exportum.typus,
                                        species: exportum.species,
                                        mutabilis: falsum,
                                        locus: spec.locus
                                    } qua Symbolum)
                                } secus {
                                    a.error(scriptum("'ยง' is not exported from 'ยง'", spec.importatum, imp.fons), spec.locus)
                                }
                            }
                        }
                    }
                }
            }
            # External package imports pass through to codegen unchanged
        }

        # Other statements don't need predeclaration
        casu _ { }
    }
}
