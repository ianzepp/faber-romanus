# Semantic - Entry Point
#
# Performs semantic analysis on the AST. Resolves types, builds symbol tables.

ex "./resolvitor" importa Resolvitor
ex "./nucleus" importa Analyzator, SemanticResultatum, novumAnalyzator
ex "./typi" importa SemanticTypus, IGNOTUM, VACUUM, functioTypus, usitatumTypus
ex "./scopus" importa Symbolum, SymbolumSpecies
ex "./expressia/index" importa resolveExpressia
ex "./sententia/index" importa analyzeSententia
ex "../ast/radix" importa Programma
ex "../ast/expressia" importa Expressia
ex "../ast/sententia" importa Sententia, MorphologiaDeclaratio
ex "../parser/morphologia" importa parseMethodum

# ============================================================================
# RESOLVITOR IMPLEMENTATION
# ============================================================================

# Concrete implementation of the Resolvitor pactum
@ publicum
genus ResolvitorImpl implet Resolvitor {
    Analyzator a

    @ publica
    functio analyzator() -> Analyzator {
        redde ego.a
    }

    @ publica
    functio expressia(Expressia expr) -> SemanticTypus {
        redde resolveExpressia(ego qua Resolvitor, expr)
    }

    @ publica
    functio sententia(Sententia stmt) -> vacuum {
        analyzeSententia(ego qua Resolvitor, stmt)
    }
}

# Create a new Resolvitor
@ publica
functio novumResolvitor(Analyzator a) -> Resolvitor {
    redde { a: a } qua ResolvitorImpl qua Resolvitor
}

# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

# Perform semantic analysis on a program
@ publica
functio analyze(Programma programma) -> SemanticResultatum {
    # Create analyzer state
    fixum a = novumAnalyzator()
    fixum r = novumResolvitor(a)

    # Phase 1: Predeclare all top-level names
    # (allows forward references)
    ex programma.corpus pro stmt {
        predeclare(r, stmt)
    }

    # Phase 2: Analyze all statements
    ex programma.corpus pro stmt {
        r.sententia(stmt)
    }

    # Return result
    redde {
        programma: programma,
        errores: a.errores
    } qua SemanticResultatum
}

# ============================================================================
# PREDECLARATION
# ============================================================================

# Predeclare a top-level statement (registers placeholder types)
@ publica
functio predeclare(Resolvitor r, Sententia stmt) -> vacuum {
    fixum a = r.analyzator()

    discerne stmt {
        # Function declaration - register name with function type
        casu FunctioDeclaratio ut f {
            # Build placeholder function type
            varia paramTypi = [] innatum lista<SemanticTypus>
            ex f.parametra pro param {
                paramTypi.adde(IGNOTUM)
            }
            fixum fnTypus = functioTypus(paramTypi, VACUUM, f.asynca, falsum)

            a.definie({
                nomen: f.nomen,
                semanticTypus: fnTypus,
                species: SymbolumSpecies.Functio,
                mutabilis: falsum,
                locus: f.locus
            } qua Symbolum)
        }

        # Genus declaration - register name with user type
        casu GenusDeclaratio ut g {
            a.definie({
                nomen: g.nomen,
                semanticTypus: usitatumTypus(g.nomen, falsum),
                species: SymbolumSpecies.Genus,
                mutabilis: falsum,
                locus: g.locus
            } qua Symbolum)

            ex g.methodi pro methodus {
                discerne methodus {
                    casu FunctioDeclaratio ut f {
                        si nonnihil f.morphologia {
                            fixum parsed = parseMethodum(f.nomen)
                            si nonnihil parsed {
                                fixum nota = f.morphologia qua MorphologiaDeclaratio
                                a.addeMorphologiam(g.nomen, parsed.radix, nota.formae)
                            }
                        }
                    }
                }
            }
        }

        # Pactum declaration - register name with user type
        casu PactumDeclaratio ut p {
            a.definie({
                nomen: p.nomen,
                semanticTypus: usitatumTypus(p.nomen, falsum),
                species: SymbolumSpecies.Pactum,
                mutabilis: falsum,
                locus: p.locus
            } qua Symbolum)

            ex p.methodi pro methodus {
                si nonnihil methodus.morphologia {
                    fixum parsed = parseMethodum(methodus.nomen)
                    si nonnihil parsed {
                        fixum nota = methodus.morphologia qua MorphologiaDeclaratio
                        a.addeMorphologiam(p.nomen, parsed.radix, nota.formae)
                    }
                }
            }
        }

        # Ordo declaration - register name with user type
        casu OrdoDeclaratio ut o {
            a.definie({
                nomen: o.nomen,
                semanticTypus: usitatumTypus(o.nomen, falsum),
                species: SymbolumSpecies.Ordo,
                mutabilis: falsum,
                locus: o.locus
            } qua Symbolum)
        }

        # Discretio declaration - register name with user type
        casu DiscretioDeclaratio ut d {
            a.definie({
                nomen: d.nomen,
                semanticTypus: usitatumTypus(d.nomen, falsum),
                species: SymbolumSpecies.TypusAlias,
                mutabilis: falsum,
                locus: d.locus
            } qua Symbolum)
        }

        # Typus alias - register name with user type
        casu TypusAliasDeclaratio ut t {
            a.definie({
                nomen: t.nomen,
                semanticTypus: usitatumTypus(t.nomen, falsum),
                species: SymbolumSpecies.TypusAlias,
                mutabilis: falsum,
                locus: t.locus
            } qua Symbolum)
        }

        # Other statements don't need predeclaration
    }
}
