# Statement Analysis - Main Dispatcher
#
# Routes statement AST nodes to their appropriate analysis functions.

ex "../resolvitor" importa Resolvitor
ex "../../ast/sententia" importa Sententia

# Import analyzers - no circular dependency since they only use Resolvitor
ex "./declara" importa analyzeVariaDeclaratio, analyzeFunctioDeclaratio
ex "./declara" importa analyzeGenusDeclaratio, analyzePactumDeclaratio
ex "./declara" importa analyzeOrdoDeclaratio, analyzeDiscretioDeclaratio, analyzeTypusAlias
ex "./imperium" importa analyzeSi, analyzeDum, analyzeIteratio, analyzeIn
ex "./imperium" importa analyzeElige, analyzeDiscerne, analyzeCustodi
ex "./actio" importa analyzeRedde, analyzeIace, analyzeScribe, analyzeAdfirma
ex "./error" importa analyzeTempta, analyzeFac, analyzeCura

# =============================================================================
# MAIN DISPATCHER
# =============================================================================

# Analyze any statement
@ publica
functio analyzeSententia(Resolvitor r, Sententia stmt) -> vacuum {
    discerne stmt {
        # Declarations
        casu VariaSententia {
            analyzeVariaDeclaratio(r, stmt)
        }

        casu DestructuraSententia ut s {
            r.expressia(s.fons)
        }

        casu SeriesDestructuraSententia ut s {
            r.expressia(s.fons)
        }

        casu FunctioDeclaratio {
            analyzeFunctioDeclaratio(r, stmt)
        }

        casu GenusDeclaratio {
            analyzeGenusDeclaratio(r, stmt)
        }

        casu PactumDeclaratio {
            analyzePactumDeclaratio(r, stmt)
        }

        casu OrdoDeclaratio {
            analyzeOrdoDeclaratio(r, stmt)
        }

        casu DiscretioDeclaratio {
            analyzeDiscretioDeclaratio(r, stmt)
        }

        casu TypusAliasDeclaratio {
            analyzeTypusAlias(r, stmt)
        }

        # Control flow
        casu SiSententia {
            analyzeSi(r, stmt)
        }

        casu DumSententia {
            analyzeDum(r, stmt)
        }

        casu IteratioSententia {
            analyzeIteratio(r, stmt)
        }

        casu InSententia {
            analyzeIn(r, stmt)
        }

        casu EligeSententia {
            analyzeElige(r, stmt)
        }

        casu DiscerneSententia {
            analyzeDiscerne(r, stmt)
        }

        casu CustodiSententia {
            analyzeCustodi(r, stmt)
        }

        # Action statements
        casu ReddeSententia {
            analyzeRedde(r, stmt)
        }

        casu IaceSententia {
            analyzeIace(r, stmt)
        }

        casu ScribeSententia {
            analyzeScribe(r, stmt)
        }

        casu AdfirmaSententia {
            analyzeAdfirma(r, stmt)
        }

        # Error handling
        casu TemptaSententia {
            analyzeTempta(r, stmt)
        }

        casu FacSententia {
            analyzeFac(r, stmt)
        }

        casu CuraSententia {
            analyzeCura(r, stmt)
        }

        # Block
        casu MassaSententia ut m {
            ex m.corpus pro s {
                r.sententia(s)
            }
        }

        # Expression statement
        casu ExpressiaSententia ut e {
            r.expressia(e.expressia)
        }

        # Rumpe/Perge - no analysis needed
        casu RumpeSententia {
            # break - no semantic analysis needed
        }

        casu PergeSententia {
            # continue - no semantic analysis needed
        }

        # Imports - handled separately during predeclaration
        casu ImportaSententia {
            # Imports are processed in predeclaration phase
        }
    }
}
