# Declaration Statement Analysis
#
# Handles: varia/fixum, functio, genus, pactum, ordo, discretio, typus

ex "../resolvitor" importa Resolvitor
ex "../typi" importa SemanticTypus, VACUUM, IGNOTUM, NIHIL
ex "../typi" importa primitivumTypus, genericumTypus, unioTypus
ex "../typi" importa functioTypus, usitatumTypus, genusTypus, pactumTypus, ordoTypus
ex "../typi" importa formaTypum, assignabileAd
ex "../scopus" importa Symbolum, SymbolumSpecies, ScopusSpecies, quaereSymbolumLocale
ex "../nucleus" importa estGenericusTypus
ex "../errores" importa noTypeOrInitializerError, typeMismatchError, awaitOutsideAsyncError
ex "../../ast/sententia" importa Sententia, VariaGenus
ex "../../ast/typus" importa TypusAnnotatio, TypusParametrum

functio resolveTypusAnnotatio(Resolvitor r, TypusAnnotatio annotatio) -> SemanticTypus {
    # WHY: Self-hosting needs full type annotation resolution for the compiler itself
    # (AST nodes, generics, and nullable types).

    # Union type: unio<A, B>
    si nonnihil annotatio.unio {
        varia typi = [] qua lista<SemanticTypus>
        ex (annotatio.unio qua lista<TypusAnnotatio>) pro t {
            typi.adde(resolveTypusAnnotatio(r, t))
        }
        si annotatio.nullabilis {
            typi.adde(NIHIL)
        }
        redde unioTypus(typi)
    }

    # Generic types: lista<T>, tabula<K,V>, etc.
    varia resolvedParametri = [] qua lista<SemanticTypus>
    si nonnihil annotatio.typusParametra {
        ex (annotatio.typusParametra qua lista<TypusParametrum>) pro p {
            discerne p {
                casu Typus ut tp {
                    resolvedParametri.adde(resolveTypusAnnotatio(r, tp.adnotatio))
                }
                casu Littera {
                    # EDGE: Numeric literal type params are not needed for self-host yet.
                    resolvedParametri.adde(IGNOTUM)
                }
            }
        }
    }

    si estGenericusTypus(annotatio.nomen) {
        redde genericumTypus(annotatio.nomen, resolvedParametri, annotatio.nullabilis)
    }

    # Primitive types
    si annotatio.nomen inter ["textus", "numerus", "fractus", "decimus", "magnus", "bivalens", "nihil", "vacuum", "octeti", "numquam", "objectum"] {
        redde primitivumTypus(annotatio.nomen, annotatio.nullabilis)
    }

    # User-defined types (genus/pactum/etc.)
    redde usitatumTypus(annotatio.nomen, annotatio.nullabilis)
}

# =============================================================================
# VARIABLE DECLARATION
# =============================================================================

# Analyze varia/fixum declaration
@ publica
functio analyzeVariaDeclaratio(Resolvitor r, Sententia variaStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne variaStmt {
        casu VariaSententia ut v {
            # Determine type from annotation or initializer
            varia resolvedTypus = IGNOTUM qua SemanticTypus

            si nonnihil v.typus {
                resolvedTypus = resolveTypusAnnotatio(r, v.typus qua TypusAnnotatio)
            }
            sin nonnihil v.valor {
                resolvedTypus = r.expressia(v.valor)
            }
            secus {
                # External declarations require type annotation but no initializer
                # Non-externa without type or initializer is an error
                si non v.externa {
                    fixum err = noTypeOrInitializerError(v.nomen)
                    a.error(err.textus, v.locus)
                }
            }

            # Check initializer type compatibility
            si nonnihil v.typus et nonnihil v.valor {
                fixum initTypus = r.expressia(v.valor)
                si non assignabileAd(initTypus, resolvedTypus) {
                    fixum err = typeMismatchError(formaTypum(initTypus), formaTypum(resolvedTypus))
                    a.error(err.textus, v.locus)
                }
            }

            si (v.species == VariaGenus.Figendum aut v.species == VariaGenus.Variandum) et non a.currentFunctioAsync {
                fixum keyword = v.species == VariaGenus.Figendum sic "figendum" secus "variandum"
                fixum err = awaitOutsideAsyncError(keyword)
                a.error(err.textus, v.locus)
            }

            # Define in symbol table
            fixum mutabilis = v.species == VariaGenus.Varia aut v.species == VariaGenus.Variandum
            a.definie({
                nomen: v.nomen,
                semanticTypus: resolvedTypus,
                species: SymbolumSpecies.Variabilis,
                mutabilis: mutabilis,
                locus: v.locus
            } qua Symbolum)
        }
    }
}

# =============================================================================
# FUNCTION DECLARATION
# =============================================================================

# Analyze functio declaration
@ publica
functio analyzeFunctioDeclaratio(Resolvitor r, Sententia functioStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne functioStmt {
        casu FunctioDeclaratio ut f {
            # Build parameter types
            varia paramTypi = [] qua lista<SemanticTypus>
            ex f.parametra pro param {
                si nonnihil param.typus {
                    paramTypi.adde(resolveTypusAnnotatio(r, param.typus qua TypusAnnotatio))
                } secus {
                    paramTypi.adde(IGNOTUM)
                }
            }

            # Resolve return type
            varia reditusTypus = VACUUM qua SemanticTypus
            si nonnihil f.typusReditus {
                reditusTypus = resolveTypusAnnotatio(r, f.typusReditus qua TypusAnnotatio)
            }

            # Build function type
            fixum fnTypus = functioTypus(paramTypi, reditusTypus, f.asynca, falsum)

            # Define in symbol table (predeclare creates placeholder)
            fixum existens = quaereSymbolumLocale(a.scopus, f.nomen)
            si nonnihil existens {
                a.scopus.symbola[f.nomen].semanticTypus = fnTypus
            } secus {
                a.definie({
                    nomen: f.nomen,
                    semanticTypus: fnTypus,
                    species: SymbolumSpecies.Functio,
                    mutabilis: falsum,
                    locus: f.locus
                } qua Symbolum)
            }

            # Analyze body in new scope
            si nonnihil f.corpus {
                # Save function context
                fixum prevReditus = a.currentFunctioReditus
                fixum prevAsync = a.currentFunctioAsync
                fixum prevGenerator = a.currentFunctioGenerator

                a.currentFunctioReditus = reditusTypus
                a.currentFunctioAsync = f.asynca
                a.currentFunctioGenerator = f.generator

                # Enter function scope
                a.intraScopum(ScopusSpecies.Functio)

                # Define parameters
                varia i = 0
                ex f.parametra pro param {
                    a.scopus.symbola[param.nomen] = {
                        nomen: param.nomen,
                        semanticTypus: paramTypi[i],
                        species: SymbolumSpecies.Parametrum,
                        mutabilis: falsum,
                        locus: param.locus
                    }
                    i += 1
                }

                # Analyze body
                r.sententia(f.corpus qua Sententia)

                # Exit scope and restore context
                a.exiScopum()
                a.currentFunctioReditus = prevReditus
                a.currentFunctioAsync = prevAsync
                a.currentFunctioGenerator = prevGenerator
            }
        }
    }
}

# =============================================================================
# TYPE DECLARATIONS
# =============================================================================

# Analyze genus declaration
@ publica
functio analyzeGenusDeclaratio(Resolvitor r, Sententia genusStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne genusStmt {
        casu GenusDeclaratio ut g {
            # Create genus type with empty maps (filled during body analysis)
            fixum genTypus = genusTypus(
                g.nomen,
                {} qua tabula<textus, SemanticTypus>,
                {} qua tabula<textus, SemanticTypus>,
                {} qua tabula<textus, SemanticTypus>,
                {} qua tabula<textus, SemanticTypus>,
                falsum
            )

            # Define in symbol table
            a.scopus.symbola[g.nomen] = {
                nomen: g.nomen,
                semanticTypus: genTypus,
                species: SymbolumSpecies.Genus,
                mutabilis: falsum,
                locus: g.locus
            }

            # TODO: Analyze fields and methods
        }
    }
}

# Analyze pactum declaration
@ publica
functio analyzePactumDeclaratio(Resolvitor r, Sententia pactumStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne pactumStmt {
        casu PactumDeclaratio ut p {
            # Create pactum type
            fixum pacTypus = pactumTypus(
                p.nomen,
                {} qua tabula<textus, SemanticTypus>,
                falsum
            )

            # Define in symbol table
            a.scopus.symbola[p.nomen] = {
                nomen: p.nomen,
                semanticTypus: pacTypus,
                species: SymbolumSpecies.Pactum,
                mutabilis: falsum,
                locus: p.locus
            }

            # TODO: Analyze method signatures
        }
    }
}

# Analyze ordo declaration
@ publica
functio analyzeOrdoDeclaratio(Resolvitor r, Sententia ordoStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne ordoStmt {
        casu OrdoDeclaratio ut o {
            # Create ordo type
            fixum ordTypus = ordoTypus(
                o.nomen,
                {} qua tabula<textus, SemanticTypus>,
                falsum
            )

            # Define in symbol table
            a.scopus.symbola[o.nomen] = {
                nomen: o.nomen,
                semanticTypus: ordTypus,
                species: SymbolumSpecies.Ordo,
                mutabilis: falsum,
                locus: o.locus
            }

            # TODO: Analyze members
        }
    }
}

# Analyze discretio declaration
@ publica
functio analyzeDiscretioDeclaratio(Resolvitor r, Sententia discretioStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne discretioStmt {
        casu DiscretioDeclaratio ut d {
            # Create user type for discretio
            fixum discTypus = usitatumTypus(d.nomen, falsum)

            # Define in symbol table
            a.scopus.symbola[d.nomen] = {
                nomen: d.nomen,
                semanticTypus: discTypus,
                species: SymbolumSpecies.TypusAlias,
                mutabilis: falsum,
                locus: d.locus
            }

            # TODO: Analyze variants
        }
    }
}

# Analyze typus alias declaration
@ publica
functio analyzeTypusAlias(Resolvitor r, Sententia typusStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne typusStmt {
        casu TypusAliasDeclaratio ut t {
            # TODO: resolve type annotation
            fixum aliasTypus = IGNOTUM

            # Define in symbol table
            a.scopus.symbola[t.nomen] = {
                nomen: t.nomen,
                semanticTypus: aliasTypus,
                species: SymbolumSpecies.TypusAlias,
                mutabilis: falsum,
                locus: t.locus
            }
        }
    }
}
