# Error - Error Handling Statement Analysis
#
# Handles tempta/cape, fac...dum, and cura statements.

ex "../resolvitor" importa Resolvitor
ex "../typi" importa IGNOTUM
ex "../scopus" importa ScopusSpecies, SymbolumSpecies
ex "../../ast/sententia" importa Sententia, CapeClausula
ex "../../ast/expressia" importa Expressia

# =============================================================================
# TRY-CATCH
# =============================================================================

# Analyze tempta (try) statement
@ publica
functio analyzeTempta(Resolvitor r, Sententia temptaStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne temptaStmt {
        casu TemptaSententia ut t {
            # Analyze try block
            r.sententia(t.corpus)

            # Analyze catch clause if present
            si nonnihil t.cape {
                fixum cape = t.cape qua CapeClausula

                # Enter scope for catch parameter
                a.intraScopum(ScopusSpecies.Massa)

                # Define error parameter
                a.scopus.symbola[cape.param] = {
                    nomen: cape.param,
                    semanticTypus: IGNOTUM,  # Error type
                    species: SymbolumSpecies.Variabilis,
                    mutabilis: falsum,
                    locus: cape.locus
                }

                # Analyze catch body
                r.sententia(cape.corpus)

                a.exiScopum()
            }

            # Analyze finally block if present
            si nonnihil t.demum {
                r.sententia(t.demum qua Sententia)
            }
        }
    }
}

# =============================================================================
# DO-WHILE
# =============================================================================

# Analyze fac...dum (do-while) statement
@ publica
functio analyzeFac(Resolvitor r, Sententia facStmt) -> vacuum {
    discerne facStmt {
        casu FacSententia ut f {
            # Analyze body first (executed at least once)
            r.sententia(f.corpus)

            # Analyze condition
            si nonnihil f.condicio {
                r.expressia(f.condicio qua Expressia)
            }

            # Analyze catch clause if present
            # (fac can have catch for loop errors)
            si nonnihil f.cape {
                fixum a = r.analyzator()
                fixum cape = f.cape

                a.intraScopum(ScopusSpecies.Massa)

                a.scopus.symbola[cape.param] = {
                    nomen: cape.param,
                    semanticTypus: IGNOTUM,
                    species: SymbolumSpecies.Variabilis,
                    mutabilis: falsum,
                    locus: cape.locus
                }

                r.sententia(cape.corpus)

                a.exiScopum()
            }
        }
    }
}

# =============================================================================
# RESOURCE MANAGEMENT
# =============================================================================

# Analyze cura (resource scope) statement
@ publica
functio analyzeCura(Resolvitor r, Sententia curaStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne curaStmt {
        casu CuraSententia ut c {
            # Analyze resource expression
            varia resourceTypus = IGNOTUM
            si nonnihil c.res {
                resourceTypus = r.expressia(c.res qua Expressia)
            }

            # Enter scope for resource binding
            a.intraScopum(ScopusSpecies.Massa)

            # Define resource variable
            a.scopus.symbola[c.vinculum] = {
                nomen: c.vinculum,
                semanticTypus: resourceTypus,
                species: SymbolumSpecies.Variabilis,
                mutabilis: falsum,
                locus: c.locus
            }

            # Analyze body
            r.sententia(c.corpus)

            a.exiScopum()
        }
    }
}
