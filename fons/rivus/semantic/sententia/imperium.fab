# Control Flow Statement Analysis
#
# Handles: si, dum, ex/de...pro, elige, discerne, custodi

ex "../resolvitor" importa Resolvitor
ex "../typi" importa SemanticTypus, IGNOTUM
ex "../scopus" importa ScopusSpecies, SymbolumSpecies
ex "../../ast/sententia" importa Sententia

# =============================================================================
# CONDITIONAL
# =============================================================================

# Analyze si (if) statement
@ publica
functio analyzeSi(Resolvitor r, Sententia siStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne siStmt {
        casu SiSententia ut s {
            # Analyze condition
            r.expressia(s.condicio)

            # Analyze consequent in its own block scope
            a.intraScopum(ScopusSpecies.Massa)
            r.sententia(s.consequens)
            a.exiScopum()

            # Analyze alternate (sin/secus) if present
            si nonnihil s.alternans {
                # Check if alternate is another si statement (chained if)
                discerne s.alternans {
                    casu SiSententia {
                        # Recursively analyze chained si
                        analyzeSi(r, s.alternans qua Sententia)
                    }
                    casu _ {
                        # else block needs its own scope
                        a.intraScopum(ScopusSpecies.Massa)
                        r.sententia(s.alternans qua Sententia)
                        a.exiScopum()
                    }
                }
            }
        }
        casu _ { }
    }
}

# =============================================================================
# LOOPS
# =============================================================================

# Analyze dum (while) statement
@ publica
functio analyzeDum(Resolvitor r, Sententia dumStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne dumStmt {
        casu DumSententia ut d {
            # Analyze condition
            r.expressia(d.condicio)

            # Analyze body in its own block scope
            a.intraScopum(ScopusSpecies.Massa)
            r.sententia(d.corpus)
            a.exiScopum()
        }
        casu _ { }
    }
}

# Analyze iteratio (ex/de...pro) statement
@ publica
functio analyzeIteratio(Resolvitor r, Sententia iteratioStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne iteratioStmt {
        casu IteratioSententia ut i {
            # Analyze source expression
            fixum sourceTypus = r.expressia(i.iterabile)

            # Enter block scope for loop variable
            a.intraScopum(ScopusSpecies.Massa)

            # Infer loop variable type from source
            varia elemTypus = IGNOTUM qua SemanticTypus
            discerne sourceTypus {
                casu Genericum ut g {
                    si g.nomen == "lista" et g.parametri.longitudo() > 0 {
                        elemTypus = g.parametri.primus()
                    }
                }
                casu _ { }
            }

            # Define loop variable
            a.scopus.symbola[i.variabilis] = {
                nomen: i.variabilis,
                semanticTypus: elemTypus,
                species: SymbolumSpecies.Variabilis,
                mutabilis: falsum,
                locus: i.locus
            }

            # Analyze body
            r.sententia(i.corpus)

            # Exit scope
            a.exiScopum()
        }
        casu _ { }
    }
}

# Analyze in (context block) statement
@ publica
functio analyzeIn(Resolvitor r, Sententia inStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne inStmt {
        casu InSententia ut i {
            # Analyze source expression
            r.expressia(i.obiectum)

            # Enter scope for body
            a.intraScopum(ScopusSpecies.Massa)

            # Analyze body
            r.sententia(i.corpus)

            # Exit scope
            a.exiScopum()
        }
        casu _ { }
    }
}

# =============================================================================
# PATTERN MATCHING
# =============================================================================

# Analyze elige (switch) statement
@ publica
functio analyzeElige(Resolvitor r, Sententia eligeStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne eligeStmt {
        casu EligeSententia ut e {
            # Analyze discriminant
            r.expressia(e.discriminans)

            # Analyze each case in its own scope
            ex e.casus pro casus {
                # Analyze case test
                r.expressia(casus.condicio)

                # Analyze case body in its own block scope
                a.intraScopum(ScopusSpecies.Massa)
                r.sententia(casus.consequens)
                a.exiScopum()
            }

            # Analyze default (aliter) if present
            si nonnihil e.praedefinitum {
                a.intraScopum(ScopusSpecies.Massa)
                r.sententia(e.praedefinitum qua Sententia)
                a.exiScopum()
            }
        }
        casu _ { }
    }
}

# Analyze discerne (pattern match) statement
@ publica
functio analyzeDiscerne(Resolvitor r, Sententia discerneStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne discerneStmt {
        casu DiscerneSententia ut d {
            # Analyze all discriminants
            ex d.discriminantes pro disc {
                r.expressia(disc)
            }

            # Analyze each variant case
            ex d.casus pro casus {
                # Enter scope for pattern bindings
                a.intraScopum(ScopusSpecies.Massa)

                # Define bound variables for all patterns in this case
                # WHY: Each pattern can introduce 'ut' alias or 'pro' field bindings.
                ex casus.exemplaria pro pattern {
                    # Skip wildcards - they have no bindings
                    si pattern.estWildcard {
                        perge
                    }

                    # Define alias if present
                    si nonnihil pattern.alias {
                        fixum alias = pattern.alias qua textus
                        a.scopus.symbola[alias] = {
                            nomen: alias,
                            semanticTypus: IGNOTUM,  # TODO: infer from variant
                            species: SymbolumSpecies.Variabilis,
                            mutabilis: falsum,
                            locus: pattern.locus
                        }
                    }

                    # Define field bindings if present
                    ex pattern.vincula pro vinculum {
                        a.scopus.symbola[vinculum] = {
                            nomen: vinculum,
                            semanticTypus: IGNOTUM,  # TODO: infer from variant
                            species: SymbolumSpecies.Variabilis,
                            mutabilis: falsum,
                            locus: pattern.locus
                        }
                    }
                }

                # Analyze case body
                r.sententia(casus.consequens)

                a.exiScopum()
            }
        }
        casu _ { }
    }
}

# Analyze custodi (guard) statement
@ publica
functio analyzeCustodi(Resolvitor r, Sententia custodiStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne custodiStmt {
        casu CustodiSententia ut c {
            # Analyze each guard clause
            ex c.clausulae pro clausula {
                # Analyze condition
                r.expressia(clausula.condicio)

                # Analyze body in its own block scope
                a.intraScopum(ScopusSpecies.Massa)
                r.sententia(clausula.consequens)
                a.exiScopum()
            }
        }
        casu _ { }
    }
}
