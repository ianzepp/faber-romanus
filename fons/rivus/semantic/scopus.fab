# Scopus - Symbol Tables and Lexical Scoping
#
# Implements lexical scoping with a chain of symbol tables for name resolution.

ex "./typi" importa SemanticTypus
ex "../ast/positio" importa Locus

# =============================================================================
# SYMBOL DEFINITIONS
# =============================================================================

# Kind of binding this symbol represents
@ publicus
ordo SymbolumSpecies {
    Variabilis                  # varia/fixum
    Functio                     # function
    Parametrum                  # function parameter
    TypusAlias                  # type alias
    Ordo                        # enum
    Genus                       # class/struct
    Pactum                      # interface
}

# Kind of scope this is
@ publicus
ordo ScopusSpecies {
    Globalis                    # global/module scope
    Functio                     # function scope
    Massa                       # block scope
}

# A symbol binding in the symbol table
@ publicum
genus Symbolum {
    textus nomen                    # binding name
    SemanticTypus semanticTypus     # resolved type
    SymbolumSpecies species         # kind of symbol
    bivalens mutabilis              # true if varia (mutable)
    Locus locus                     # declaration location
}

# A lexical scope containing symbol bindings
@ publicum
genus Scopus {
    tabula<textus, Symbolum> symbola  # name -> symbol bindings
    Scopus? parens                    # parent scope (nil for global)
    ScopusSpecies species             # kind of scope
}

# =============================================================================
# SCOPE MANAGEMENT
# =============================================================================

# Create the global scope
@ publica
functio creaScopumGlobalem() -> Scopus {
    redde {
        symbola: {} innatum tabula<textus, Symbolum>,
        parens: nihil,
        species: ScopusSpecies.Globalis
    } qua Scopus
}

# Create a child scope
@ publica
functio creaScopum(Scopus parentScopus, ScopusSpecies scopusSpecies) -> Scopus {
    redde {
        symbola: {} innatum tabula<textus, Symbolum>,
        parens: parentScopus,
        species: scopusSpecies
    } qua Scopus
}

# Define a symbol in current scope (returns error if duplicate)
@ publica
functio definieSymbolum(Scopus scopus, Symbolum symbolum) -> textus? {
    fixum existens = scopus.symbola[symbolum.nomen]
    si nonnihil existens {
        redde scriptum("'ยง' is already defined at line ยง", symbolum.nomen, existens.locus.linea)
    }

    scopus.symbola[symbolum.nomen] = symbolum
    redde nihil
}

# Look up a symbol by name, walking up the scope chain
@ publica
functio quaereSymbolum(Scopus scopus, textus nomen) -> Symbolum? {
    si nonnihil scopus.symbola[nomen] {
        redde scopus.symbola[nomen]
    }

    # Walk up the scope chain
    si nonnihil scopus.parens {
        redde quaereSymbolum(scopus.parens qua Scopus, nomen)
    }

    redde nihil
}

# Look up a symbol only in the current scope (no parent traversal)
@ publica
functio quaereSymbolumLocale(Scopus scopus, textus nomen) -> Symbolum? {
    si nonnihil scopus.symbola[nomen] {
        redde scopus.symbola[nomen]
    }

    redde nihil
}

# Update an existing symbol's type (for two-pass analysis)
@ publica
functio renovaSymbolumTypum(Scopus scopus, textus nomen, SemanticTypus novusTypus) -> bivalens {
    si nihil scopus.symbola[nomen] {
        redde falsum
    }

    fixum symbolum = scopus.symbola[nomen]
    symbolum.semanticTypus = novusTypus
    scopus.symbola[nomen] = symbolum
    redde verum
}

# Find the enclosing function scope (for return type checking)
@ publica
functio inveniScopumFunctionis(Scopus scopus) -> Scopus? {
    si scopus.species == ScopusSpecies.Functio {
        redde scopus
    }

    # parens is guaranteed non-nil here due to the check
    si nonnihil scopus.parens {
        redde inveniScopumFunctionis(scopus.parens qua Scopus)
    }

    redde nihil
}
