# Nucleus - Core Analyzer State and Infrastructure
#
# Provides the Analyzator genus that manages semantic analysis state.

ex "./typi" importa SemanticTypus, TEXTUS, NUMERUS, FRACTUS, BIVALENS, NIHIL, VACUUM, IGNOTUM
ex "./typi" importa primitivumTypus, genericumTypus, functioTypus, usitatumTypus
ex "./typi" importa formaTypum, assignabileAd, typiAequales
ex "./scopus" importa Scopus, Symbolum, SymbolumSpecies, ScopusSpecies
ex "./scopus" importa creaScopumGlobalem, creaScopum, definieSymbolum, quaereSymbolum
ex "./errores" importa SemanticErrorCodice, SemanticErrorNuntius
ex "../ast/positio" importa Locus
ex "../ast/radix" importa Programma
ex "../ast/sententia" importa Sententia
ex "../ast/expressia" importa Expressia

# ============================================================================
# SEMANTIC ERROR
# ============================================================================

# A semantic error with source location
@ publicum
genus SemanticError {
    textus nuntius
    Locus locus
}

# ============================================================================
# ANALYSIS RESULT
# ============================================================================

# Result of semantic analysis
@ publicum
genus SemanticResultatum {
    Programma programma
    lista<SemanticError> errores
}

# ============================================================================
# LATIN TYPE MAPPING
# ============================================================================

# Map Latin type name to semantic type
@ publica
functio latinTypusAd(textus nomen) -> SemanticTypus {
    elige nomen {
        casu "textus" reddit TEXTUS
        casu "numerus" reddit NUMERUS
        casu "fractus" reddit FRACTUS
        casu "bivalens" reddit BIVALENS
        casu "nihil" reddit NIHIL
        casu "vacuum" reddit VACUUM
    }
    redde IGNOTUM
}

# Check if a type name is a generic type
@ publica
functio estGenericusTypus(textus nomen) -> bivalens {
    redde nomen inter ["lista", "tabula", "copia", "promissum", "cursor", "fluxus"]
}

# ============================================================================
# ANALYZER STATE
# ============================================================================

# The semantic analyzer state
@ publicum
genus Analyzator {
    lista<SemanticError> errores                                          # collected errors
    Scopus scopus                                                         # current scope chain
    SemanticTypus? currentFunctioReditus                                  # for return type checking
    bivalens currentFunctioAsync                                          # in async function?
    bivalens currentFunctioGenerator                                      # in generator function?
    lista<textus> resolvendoTypusAliases                                  # cycle detection
    tabula<textus, tabula<textus, lista<textus> > > morphologiaRegistra   # receiver -> stem -> forms

    # ========================================================================
    # ERROR REPORTING
    # ========================================================================

    # Report a semantic error
    @ publica
    functio error(textus nuntius, Locus locus) {
        ego.errores.adde({
            nuntius: nuntius,
            locus: locus
        } qua SemanticError)
    }

    # ========================================================================
    # SCOPE MANAGEMENT
    # ========================================================================

    # Enter a new scope
    @ publica
    functio intraScopum(ScopusSpecies species) {
        ego.scopus = creaScopum(ego.scopus, species)
    }

    # Exit the current scope
    @ publica
    functio exiScopum() {
        si nonnihil ego.scopus.parens {
            ego.scopus = ego.scopus.parens qua Scopus
        }
    }

    # Define a symbol in current scope (reports error if duplicate)
    @ publica
    functio definie(Symbolum symbolum) {
        fixum err = definieSymbolum(ego.scopus, symbolum)
        si nonnihil err {
            ego.error(err qua textus, symbolum.locus)
        }
    }

    # Look up a symbol in scope chain
    @ publica
    functio quaere(textus nomen) -> Symbolum? {
        redde quaereSymbolum(ego.scopus, nomen)
    }

    # ========================================================================
    # BUILTINS
    # ========================================================================

    # Define built-in functions (intrinsics) in global scope
    @ publica
    functio definieIntrinsica() {
        fixum builtinLocus = { linea: 0, columna: 0, index: 0 } qua Locus

        # I/O Intrinsics (always available - prefixed with _ for internal use)
        ego.definieIntrinsicaFunctio("_scribe", [], VACUUM, builtinLocus)
        ego.definieIntrinsicaFunctio("_vide", [], VACUUM, builtinLocus)
        ego.definieIntrinsicaFunctio("_mone", [], VACUUM, builtinLocus)
        ego.definieIntrinsicaFunctio("_lege", [], TEXTUS, builtinLocus)

        # Register morphology for built-in collection types
        fixum formae = ["imperativus", "perfectum", "futurum_indicativum", "futurum_activum"] qua lista<textus>

        # lista verb stems
        ego.addeMorphologiam("lista", "add", formae)
        ego.addeMorphologiam("lista", "praepon", formae)
        ego.addeMorphologiam("lista", "remov", formae)
        ego.addeMorphologiam("lista", "decapit", formae)
        ego.addeMorphologiam("lista", "filtr", formae)
        ego.addeMorphologiam("lista", "mapp", formae)
        ego.addeMorphologiam("lista", "ordin", formae)
        ego.addeMorphologiam("lista", "invert", formae)
    }

    # Helper to define a single intrinsic function
    @ publica
    functio definieIntrinsicaFunctio(textus nomen, lista<SemanticTypus> parametri, SemanticTypus reditus, Locus locus) {
        fixum typusFunctionis = functioTypus(parametri, reditus, falsum, falsum)
        ego.scopus.symbola[nomen] = {
            nomen: nomen,
            semanticTypus: typusFunctionis,
            species: SymbolumSpecies.Functio,
            mutabilis: falsum,
            locus: locus
        } qua Symbolum
    }

    # ========================================================================
    # MORPHOLOGIA REGISTRY
    # ========================================================================

    @ publica
    functio habetMorphologiam(textus recipiens) -> bivalens {
        redde nonnihil ego.morphologiaRegistra[recipiens]
    }

    @ publica
    functio formaeMorphologiae(textus recipiens, textus radix) -> lista<textus>? {
        fixum perRecipiens = ego.morphologiaRegistra[recipiens]
        si nihil perRecipiens {
            redde nihil
        }
        redde perRecipiens[radix]
    }

    @ publica
    functio addeMorphologiam(textus recipiens, textus radix, lista<textus> formae) -> vacuum {
        si nihil ego.morphologiaRegistra[recipiens] {
            ego.morphologiaRegistra[recipiens] = {} qua tabula<textus, lista<textus> >
        }

        fixum perRecipiens = ego.morphologiaRegistra[recipiens]
        si nihil perRecipiens[radix] {
            perRecipiens[radix] = [] qua lista<textus>
        }

        fixum existentes = perRecipiens[radix]
        ex formae pro forma {
            varia iam = falsum
            ex existentes pro existens {
                si existens == forma {
                    iam = verum
                }
            }
            si non iam {
                existentes.adde(forma)
            }
        }
    }
}

# ============================================================================
# FACTORY
# ============================================================================

# Create a new analyzer
@ publica
functio novumAnalyzator() -> Analyzator {
    fixum analyzator = {
        errores: [] qua lista<SemanticError>,
        scopus: creaScopumGlobalem(),
        currentFunctioReditus: nihil,
        currentFunctioAsync: falsum,
        currentFunctioGenerator: falsum,
        resolvendoTypusAliases: [] qua lista<textus>,
        morphologiaRegistra: {} qua tabula<textus, tabula<textus, lista<textus> > >
    } qua Analyzator

    # Define built-in intrinsics
    analyzator.definieIntrinsica()

    redde analyzator
}
