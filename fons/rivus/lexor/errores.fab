# Lexor Errors - Error Codes and Messages
#
# Centralized error definitions for lexical analysis.

ex "../ast/positio" importa Locus

# ============================================================================
# ERROR CODES
# ============================================================================

# Error codes for lexical failures (L-prefix distinguishes from parser/semantic)
@ publicum
ordo LexorErrorCodice {
    TextusNonClausa = "L001",           # Unterminated string
    ExemplarNonClausum = "L002",        # Unterminated template string
    SignumInopinatum = "L003",          # Unexpected character
    NumerusHexMalus = "L004",           # Invalid hex literal
    NumerusBinariusMalus = "L005",      # Invalid binary literal
    NumerusOctalisMalus = "L006"        # Invalid octal literal
}

# ============================================================================
# ERROR MESSAGE TYPES
# ============================================================================

# Structured error message with brief text and detailed help
@ publicum
genus LexorErrorNuntius {
    textus textus             # Brief error message
    textus auxilium           # Detailed help text
}

# ============================================================================
# MESSAGE LOOKUP
# ============================================================================

# Get the human-readable message for a given error code
@ publica
functio nuntiumErroris(LexorErrorCodice codice) -> LexorErrorNuntius {
    elige codice {
        casu LexorErrorCodice.TextusNonClausa {
            redde {
                textus: "Unterminated string",
                auxilium: "String literals must be closed on the same line. Use backticks for multi-line."
            } qua LexorErrorNuntius
        }
        casu LexorErrorCodice.ExemplarNonClausum {
            redde {
                textus: "Unterminated template string",
                auxilium: "Template strings must end with a closing backtick."
            } qua LexorErrorNuntius
        }
        casu LexorErrorCodice.SignumInopinatum {
            redde {
                textus: "Unexpected character",
                auxilium: "This character is not valid in Latin syntax."
            } qua LexorErrorNuntius
        }
        casu LexorErrorCodice.NumerusHexMalus {
            redde {
                textus: "Invalid hex literal",
                auxilium: "Hex literals must have at least one digit after 0x prefix."
            } qua LexorErrorNuntius
        }
        casu LexorErrorCodice.NumerusBinariusMalus {
            redde {
                textus: "Invalid binary literal",
                auxilium: "Binary literals must have at least one digit after 0b prefix."
            } qua LexorErrorNuntius
        }
        casu LexorErrorCodice.NumerusOctalisMalus {
            redde {
                textus: "Invalid octal literal",
                auxilium: "Octal literals must have at least one digit after 0o prefix."
            } qua LexorErrorNuntius
        }
    }

    # Fallback (should never reach)
    redde {
        textus: "Error ignotus",
        auxilium: "Unknown error occurred."
    } qua LexorErrorNuntius
}

# ============================================================================
# ERROR TYPE
# ============================================================================

# A lexical error with source position for reporting
@ publicum
genus LexorError {
    LexorErrorCodice codice
    textus textus
    textus auxilium
    Locus locus
}

# ============================================================================
# FACTORY
# ============================================================================

# Create an error at a source position
@ publica
functio error(LexorErrorCodice codice, Locus locus) -> LexorError {
    fixum nuntius = nuntiumErroris(codice)
    redde {
        codice: codice,
        textus: nuntius.textus,
        auxilium: nuntius.auxilium,
        locus: locus
    } qua LexorError
}
