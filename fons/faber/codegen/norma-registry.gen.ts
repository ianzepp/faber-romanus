/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by: bun run build:norma
 * Source: fons/norma/*.fab
 * Generated: 2026-01-08T13:57:49.828Z
 */

import type { NormaCollection } from './norma-registry';

export const registry: Map<string, NormaCollection> = new Map([
    ['tabula', {
        name: 'tabula',
        innatum: new Map([
            ['ts', 'Map'],
            ['py', 'dict'],
            ['rs', 'HashMap'],
            ['cpp', 'std::unordered_map'],
            ['zig', 'Tabula'],
        ]),
        methods: new Map([
            ['pone', {
                name: 'pone',
                translations: new Map([
                    ['ts', { method: 'set' }],
                    ['py', { template: '§0[§1] = §2', params: ['ego', 'k', 'v'] }],
                    ['rs', { template: '§0.insert(§1, §2)', params: ['ego', 'k', 'v'] }],
                    ['cpp', { template: '§0.insert_or_assign(§1, §2)', params: ['ego', 'k', 'v'] }],
                    ['zig', { template: '§0.pone(§3, §1, §2)', params: ['ego', 'k', 'v', 'alloc'] }],
                ]),
                radixForms: ['pon', 'imperativus'],
            }],
            ['accipe', {
                name: 'accipe',
                translations: new Map([
                    ['ts', { method: 'get' }],
                    ['py', { template: '§0.get(§1)', params: ['ego', 'k'] }],
                    ['rs', { template: '§0.get(&§1)', params: ['ego', 'k'] }],
                    ['cpp', { template: '§0.at(§1)', params: ['ego', 'k'] }],
                    ['zig', { template: '§0.accipe(§1)', params: ['ego', 'k'] }],
                ]),
            }],
            ['accipeAut', {
                name: 'accipeAut',
                translations: new Map([
                    ['ts', { template: '(§0.get(§1) ?? §2)', params: ['ego', 'k', 'def'] }],
                    ['py', { template: '§0.get(§1, §2)', params: ['ego', 'k', 'def'] }],
                    ['rs', { template: '§0.get(&§1).cloned().unwrap_or(§2)', params: ['ego', 'k', 'def'] }],
                    ['cpp', { template: '(§0.contains(§1) ? §0.at(§1) : §2)', params: ['ego', 'k', 'def'] }],
                    ['zig', { template: '§0.accipeAut(§1, §2)', params: ['ego', 'k', 'def'] }],
                ]),
            }],
            ['habet', {
                name: 'habet',
                translations: new Map([
                    ['ts', { method: 'has' }],
                    ['py', { template: '(§1 in §0)', params: ['ego', 'k'] }],
                    ['rs', { template: '§0.contains_key(&§1)', params: ['ego', 'k'] }],
                    ['cpp', { template: '§0.contains(§1)', params: ['ego', 'k'] }],
                    ['zig', { template: '§0.habet(§1)', params: ['ego', 'k'] }],
                ]),
            }],
            ['dele', {
                name: 'dele',
                translations: new Map([
                    ['ts', { method: 'delete' }],
                    ['py', { template: 'del §0[§1]', params: ['ego', 'k'] }],
                    ['rs', { template: '§0.remove(&§1)', params: ['ego', 'k'] }],
                    ['cpp', { template: '§0.erase(§1)', params: ['ego', 'k'] }],
                    ['zig', { template: '_ = §0.dele(§1)', params: ['ego', 'k'] }],
                ]),
                radixForms: ['del', 'imperativus'],
            }],
            ['longitudo', {
                name: 'longitudo',
                translations: new Map([
                    ['ts', { template: '§.size', params: ['ego'] }],
                    ['py', { template: 'len(§)', params: ['ego'] }],
                    ['rs', { template: '§.len()', params: ['ego'] }],
                    ['cpp', { template: '§.size()', params: ['ego'] }],
                    ['zig', { template: '§.longitudo()', params: ['ego'] }],
                ]),
            }],
            ['vacua', {
                name: 'vacua',
                translations: new Map([
                    ['ts', { template: '§.size === 0', params: ['ego'] }],
                    ['py', { template: 'len(§) == 0', params: ['ego'] }],
                    ['rs', { template: '§.is_empty()', params: ['ego'] }],
                    ['cpp', { template: '§.empty()', params: ['ego'] }],
                    ['zig', { template: '§.vacua()', params: ['ego'] }],
                ]),
            }],
            ['purga', {
                name: 'purga',
                translations: new Map([
                    ['ts', { method: 'clear' }],
                    ['py', { method: 'clear' }],
                    ['rs', { method: 'clear' }],
                    ['cpp', { method: 'clear' }],
                    ['zig', { template: '§.purga()', params: ['ego'] }],
                ]),
                radixForms: ['purg', 'imperativus'],
            }],
            ['claves', {
                name: 'claves',
                translations: new Map([
                    ['ts', { method: 'keys' }],
                    ['py', { method: 'keys' }],
                    ['rs', { template: '§.keys()', params: ['ego'] }],
                    ['cpp', { template: '§ | std::views::keys', params: ['ego'] }],
                    ['zig', { template: '§.claves()', params: ['ego'] }],
                ]),
            }],
            ['valores', {
                name: 'valores',
                translations: new Map([
                    ['ts', { method: 'values' }],
                    ['py', { method: 'values' }],
                    ['rs', { template: '§.values()', params: ['ego'] }],
                    ['cpp', { template: '§ | std::views::values', params: ['ego'] }],
                    ['zig', { template: '§.valores()', params: ['ego'] }],
                ]),
            }],
            ['paria', {
                name: 'paria',
                translations: new Map([
                    ['ts', { method: 'entries' }],
                    ['py', { method: 'items' }],
                    ['rs', { template: '§.iter()', params: ['ego'] }],
                    ['cpp', { template: '§', params: ['ego'] }],
                    ['zig', { template: '§.paria()', params: ['ego'] }],
                ]),
            }],
            ['selecta', {
                name: 'selecta',
                translations: new Map([
                    ['ts', { template: 'new Map([...§0].filter(([k]) => [§1].flat().includes(k)))', params: ['ego', 'claves'] }],
                    ['py', { template: '{k: v for k, v in §0.items() if k in [§1]}', params: ['ego', 'claves'] }],
                    ['rs', { template: 'faber::tabula_selecta(&§0, &§1)', params: ['ego', 'claves'] }],
                    ['cpp', { template: 'faber::tabula_selecta(§0, §1)', params: ['ego', 'claves'] }],
                    ['zig', { template: '@compileError(\"selecta not implemented for Zig - use explicit loop\")', params: ['ego', 'claves'] }],
                ]),
                radixForms: ['select', 'perfectum'],
            }],
            ['omissa', {
                name: 'omissa',
                translations: new Map([
                    ['ts', { template: 'new Map([...§0].filter(([k]) => ![§1].flat().includes(k)))', params: ['ego', 'claves'] }],
                    ['py', { template: '{k: v for k, v in §0.items() if k not in [§1]}', params: ['ego', 'claves'] }],
                    ['rs', { template: 'faber::tabula_omissa(&§0, &§1)', params: ['ego', 'claves'] }],
                    ['cpp', { template: 'faber::tabula_omissa(§0, §1)', params: ['ego', 'claves'] }],
                    ['zig', { template: '@compileError(\"omissa not implemented for Zig - use explicit loop\")', params: ['ego', 'claves'] }],
                ]),
                radixForms: ['omis', 'perfectum'],
            }],
            ['conflata', {
                name: 'conflata',
                translations: new Map([
                    ['ts', { template: 'new Map([...§0, ...§1])', params: ['ego', 'alia'] }],
                    ['py', { template: '{**§0, **§1}', params: ['ego', 'alia'] }],
                    ['rs', { template: 'faber::tabula_conflata(&§0, &§1)', params: ['ego', 'alia'] }],
                    ['cpp', { template: 'faber::tabula_conflata(§0, §1)', params: ['ego', 'alia'] }],
                    ['zig', { template: '§0.conflata(&§1)', params: ['ego', 'alia'] }],
                ]),
                radixForms: ['confl', 'perfectum'],
            }],
            ['inversa', {
                name: 'inversa',
                translations: new Map([
                    ['ts', { template: 'new Map([...§].map(([k, v]) => [v, k]))', params: ['ego'] }],
                    ['py', { template: '{v: k for k, v in §.items()}', params: ['ego'] }],
                    ['rs', { template: 'faber::tabula_inversa(&§)', params: ['ego'] }],
                    ['cpp', { template: 'faber::tabula_inversa(§)', params: ['ego'] }],
                    ['zig', { template: '@compileError(\"inversa not implemented for Zig - use explicit loop\")', params: ['ego'] }],
                ]),
                radixForms: ['inver', 'perfectum'],
            }],
            ['mappaValores', {
                name: 'mappaValores',
                translations: new Map([
                    ['ts', { template: 'new Map([...§0].map(([k, v]) => [k, (§1)(v)]))', params: ['ego', 'fn'] }],
                    ['py', { template: '{k: (§1)(v) for k, v in §0.items()}', params: ['ego', 'fn'] }],
                    ['zig', { template: '@compileError(\"mappaValores not implemented for Zig - use explicit loop\")', params: ['ego', 'fn'] }],
                ]),
            }],
            ['mappaClaves', {
                name: 'mappaClaves',
                translations: new Map([
                    ['ts', { template: 'new Map([...§0].map(([k, v]) => [(§1)(k), v]))', params: ['ego', 'fn'] }],
                    ['py', { template: '{(§1)(k): v for k, v in §0.items()}', params: ['ego', 'fn'] }],
                    ['zig', { template: '@compileError(\"mappaClaves not implemented for Zig - use explicit loop\")', params: ['ego', 'fn'] }],
                ]),
            }],
            ['inLista', {
                name: 'inLista',
                translations: new Map([
                    ['ts', { template: '[...§]', params: ['ego'] }],
                    ['py', { template: 'list(§.items())', params: ['ego'] }],
                    ['rs', { template: 'faber::tabula_in_lista(&§)', params: ['ego'] }],
                    ['cpp', { template: 'faber::tabula_in_lista(§)', params: ['ego'] }],
                    ['zig', { template: '§.inLista(§)', params: ['ego', 'alloc'] }],
                ]),
            }],
            ['inObjectum', {
                name: 'inObjectum',
                translations: new Map([
                    ['ts', { template: 'Object.fromEntries(§)', params: ['ego'] }],
                    ['py', { template: 'dict(§)', params: ['ego'] }],
                    ['zig', { template: '@compileError(\"inObjectum not implemented for Zig - Zig has no object type\")', params: ['ego'] }],
                ]),
            }],
        ]),
    }],
    ['numerus', {
        name: 'numerus',
        innatum: new Map([
            ['ts', 'number'],
            ['py', 'int'],
            ['rs', 'i64'],
            ['cpp', 'int64_t'],
            ['zig', 'i64'],
        ]),
        methods: new Map([
            ['absolutum', {
                name: 'absolutum',
                translations: new Map([
                    ['ts', { template: 'Math.abs(§)', params: ['ego'] }],
                    ['py', { template: 'abs(§)', params: ['ego'] }],
                    ['rs', { template: '§.abs()', params: ['ego'] }],
                    ['cpp', { template: 'std::abs(§)', params: ['ego'] }],
                    ['zig', { template: '@intCast(@abs(§))', params: ['ego'] }],
                ]),
            }],
            ['signum', {
                name: 'signum',
                translations: new Map([
                    ['ts', { template: 'Math.sign(§)', params: ['ego'] }],
                    ['py', { template: '((§0>0)-(§0<0))', params: ['ego'] }],
                    ['rs', { template: '§.signum()', params: ['ego'] }],
                    ['cpp', { template: '((§0 > 0) - (§0 < 0))', params: ['ego'] }],
                    ['zig', { template: 'std.math.sign(§)', params: ['ego'] }],
                ]),
            }],
            ['minimus', {
                name: 'minimus',
                translations: new Map([
                    ['ts', { template: 'Math.min(§, §)', params: ['ego', 'other'] }],
                    ['py', { template: 'min(§, §)', params: ['ego', 'other'] }],
                    ['rs', { template: 'std::cmp::min(§, §)', params: ['ego', 'other'] }],
                    ['cpp', { template: 'std::min(§, §)', params: ['ego', 'other'] }],
                    ['zig', { template: '@min(§, §)', params: ['ego', 'other'] }],
                ]),
            }],
            ['maximus', {
                name: 'maximus',
                translations: new Map([
                    ['ts', { template: 'Math.max(§, §)', params: ['ego', 'other'] }],
                    ['py', { template: 'max(§, §)', params: ['ego', 'other'] }],
                    ['rs', { template: 'std::cmp::max(§, §)', params: ['ego', 'other'] }],
                    ['cpp', { template: 'std::max(§, §)', params: ['ego', 'other'] }],
                    ['zig', { template: '@max(§, §)', params: ['ego', 'other'] }],
                ]),
            }],
        ]),
    }],
    ['fractus', {
        name: 'fractus',
        innatum: new Map([
            ['ts', 'number'],
            ['py', 'float'],
            ['rs', 'f64'],
            ['cpp', 'double'],
            ['zig', 'f64'],
        ]),
        methods: new Map([
            ['absolutum', {
                name: 'absolutum',
                translations: new Map([
                    ['ts', { template: 'Math.abs(§)', params: ['ego'] }],
                    ['py', { template: 'abs(§)', params: ['ego'] }],
                    ['rs', { template: '§.abs()', params: ['ego'] }],
                    ['cpp', { template: 'std::abs(§)', params: ['ego'] }],
                    ['zig', { template: '@abs(§)', params: ['ego'] }],
                ]),
            }],
            ['signum', {
                name: 'signum',
                translations: new Map([
                    ['ts', { template: 'Math.sign(§)', params: ['ego'] }],
                    ['py', { template: 'math.copysign(1, §)', params: ['ego'] }],
                    ['rs', { template: '§.signum()', params: ['ego'] }],
                    ['cpp', { template: 'std::copysign(1.0, §)', params: ['ego'] }],
                    ['zig', { template: 'std.math.sign(§)', params: ['ego'] }],
                ]),
            }],
            ['minimus', {
                name: 'minimus',
                translations: new Map([
                    ['ts', { template: 'Math.min(§, §)', params: ['ego', 'other'] }],
                    ['py', { template: 'min(§, §)', params: ['ego', 'other'] }],
                    ['rs', { template: '§.min(§)', params: ['ego', 'other'] }],
                    ['cpp', { template: 'std::min(§, §)', params: ['ego', 'other'] }],
                    ['zig', { template: '@min(§, §)', params: ['ego', 'other'] }],
                ]),
            }],
            ['maximus', {
                name: 'maximus',
                translations: new Map([
                    ['ts', { template: 'Math.max(§, §)', params: ['ego', 'other'] }],
                    ['py', { template: 'max(§, §)', params: ['ego', 'other'] }],
                    ['rs', { template: '§.max(§)', params: ['ego', 'other'] }],
                    ['cpp', { template: 'std::max(§, §)', params: ['ego', 'other'] }],
                    ['zig', { template: '@max(§, §)', params: ['ego', 'other'] }],
                ]),
            }],
            ['rotunda', {
                name: 'rotunda',
                translations: new Map([
                    ['ts', { template: 'Math.round(§)', params: ['ego'] }],
                    ['py', { template: 'round(§)', params: ['ego'] }],
                    ['rs', { template: '§.round() as i64', params: ['ego'] }],
                    ['cpp', { template: 'static_cast<int64_t>(std::round(§))', params: ['ego'] }],
                    ['zig', { template: '@intFromFloat(@round(§))', params: ['ego'] }],
                ]),
            }],
            ['pavimentum', {
                name: 'pavimentum',
                translations: new Map([
                    ['ts', { template: 'Math.floor(§)', params: ['ego'] }],
                    ['py', { template: 'math.floor(§)', params: ['ego'] }],
                    ['rs', { template: '§.floor() as i64', params: ['ego'] }],
                    ['cpp', { template: 'static_cast<int64_t>(std::floor(§))', params: ['ego'] }],
                    ['zig', { template: '@intFromFloat(@floor(§))', params: ['ego'] }],
                ]),
            }],
            ['tectum', {
                name: 'tectum',
                translations: new Map([
                    ['ts', { template: 'Math.ceil(§)', params: ['ego'] }],
                    ['py', { template: 'math.ceil(§)', params: ['ego'] }],
                    ['rs', { template: '§.ceil() as i64', params: ['ego'] }],
                    ['cpp', { template: 'static_cast<int64_t>(std::ceil(§))', params: ['ego'] }],
                    ['zig', { template: '@intFromFloat(@ceil(§))', params: ['ego'] }],
                ]),
            }],
            ['trunca', {
                name: 'trunca',
                translations: new Map([
                    ['ts', { template: 'Math.trunc(§)', params: ['ego'] }],
                    ['py', { template: 'math.trunc(§)', params: ['ego'] }],
                    ['rs', { template: '§.trunc() as i64', params: ['ego'] }],
                    ['cpp', { template: 'static_cast<int64_t>(std::trunc(§))', params: ['ego'] }],
                    ['zig', { template: '@intFromFloat(@trunc(§))', params: ['ego'] }],
                ]),
            }],
        ]),
    }],
    ['tempus', {
        name: 'tempus',
        innatum: new Map([
            ['ts', 'Date'],
            ['py', 'time'],
            ['rs', 'std::time'],
            ['cpp', 'std::chrono'],
            ['zig', 'std.time'],
        ]),
        methods: new Map([
            ['nunc', {
                name: 'nunc',
                translations: new Map([
                    ['ts', { template: 'Date.now()', params: [] }],
                    ['py', { template: 'int(time.time() * 1000)', params: [] }],
                    ['rs', { template: 'std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_millis() as i64', params: [] }],
                    ['cpp', { template: 'std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count()', params: [] }],
                    ['zig', { template: 'std.time.milliTimestamp()', params: [] }],
                ]),
            }],
            ['nunc_nano', {
                name: 'nunc_nano',
                translations: new Map([
                    ['ts', { template: 'BigInt(Date.now()) * 1000000n', params: [] }],
                    ['py', { template: 'time.time_ns()', params: [] }],
                    ['rs', { template: 'std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_nanos() as i64', params: [] }],
                    ['cpp', { template: 'std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now().time_since_epoch()).count()', params: [] }],
                    ['zig', { template: 'std.time.nanoTimestamp()', params: [] }],
                ]),
            }],
            ['nunc_secunda', {
                name: 'nunc_secunda',
                translations: new Map([
                    ['ts', { template: 'Math.floor(Date.now() / 1000)', params: [] }],
                    ['py', { template: 'int(time.time())', params: [] }],
                    ['rs', { template: 'std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs() as i64', params: [] }],
                    ['cpp', { template: 'std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch()).count()', params: [] }],
                    ['zig', { template: 'std.time.timestamp()', params: [] }],
                ]),
            }],
            ['dormi', {
                name: 'dormi',
                translations: new Map([
                    ['ts', { template: 'new Promise(r => setTimeout(r, §))', params: ['ms'] }],
                    ['py', { template: 'time.sleep(§ / 1000)', params: ['ms'] }],
                    ['rs', { template: 'std::thread::sleep(std::time::Duration::from_millis(§ as u64))', params: ['ms'] }],
                    ['cpp', { template: 'std::this_thread::sleep_for(std::chrono::milliseconds(§))', params: ['ms'] }],
                    ['zig', { template: 'std.time.sleep(§ * 1_000_000)', params: ['ms'] }],
                ]),
            }],
            ['MILLISECUNDUM', {
                name: 'MILLISECUNDUM',
                translations: new Map([
                    ['ts', { template: '1', params: [] }],
                    ['py', { template: '1', params: [] }],
                    ['rs', { template: '1_i64', params: [] }],
                    ['cpp', { template: '1', params: [] }],
                    ['zig', { template: '1', params: [] }],
                ]),
            }],
            ['SECUNDUM', {
                name: 'SECUNDUM',
                translations: new Map([
                    ['ts', { template: '1000', params: [] }],
                    ['py', { template: '1000', params: [] }],
                    ['rs', { template: '1000_i64', params: [] }],
                    ['cpp', { template: '1000', params: [] }],
                    ['zig', { template: '1000', params: [] }],
                ]),
            }],
            ['MINUTUM', {
                name: 'MINUTUM',
                translations: new Map([
                    ['ts', { template: '60000', params: [] }],
                    ['py', { template: '60000', params: [] }],
                    ['rs', { template: '60000_i64', params: [] }],
                    ['cpp', { template: '60000', params: [] }],
                    ['zig', { template: '60000', params: [] }],
                ]),
            }],
            ['HORA', {
                name: 'HORA',
                translations: new Map([
                    ['ts', { template: '3600000', params: [] }],
                    ['py', { template: '3600000', params: [] }],
                    ['rs', { template: '3600000_i64', params: [] }],
                    ['cpp', { template: '3600000', params: [] }],
                    ['zig', { template: '3600000', params: [] }],
                ]),
            }],
            ['DIES', {
                name: 'DIES',
                translations: new Map([
                    ['ts', { template: '86400000', params: [] }],
                    ['py', { template: '86400000', params: [] }],
                    ['rs', { template: '86400000_i64', params: [] }],
                    ['cpp', { template: '86400000', params: [] }],
                    ['zig', { template: '86400000', params: [] }],
                ]),
            }],
        ]),
    }],
    ['mathesis', {
        name: 'mathesis',
        innatum: new Map([
            ['ts', 'Math'],
            ['py', 'math'],
            ['rs', 'f64'],
            ['cpp', 'std::cmath'],
            ['zig', 'std.math'],
        ]),
        methods: new Map([
            ['pavimentum', {
                name: 'pavimentum',
                translations: new Map([
                    ['ts', { template: 'Math.floor(§)', params: ['x'] }],
                    ['py', { template: 'math.floor(§)', params: ['x'] }],
                    ['rs', { template: '§.floor()', params: ['x'] }],
                    ['cpp', { template: 'std::floor(§)', params: ['x'] }],
                    ['zig', { template: '@floor(§)', params: ['x'] }],
                ]),
            }],
            ['tectum', {
                name: 'tectum',
                translations: new Map([
                    ['ts', { template: 'Math.ceil(§)', params: ['x'] }],
                    ['py', { template: 'math.ceil(§)', params: ['x'] }],
                    ['rs', { template: '§.ceil()', params: ['x'] }],
                    ['cpp', { template: 'std::ceil(§)', params: ['x'] }],
                    ['zig', { template: '@ceil(§)', params: ['x'] }],
                ]),
            }],
            ['rotundum', {
                name: 'rotundum',
                translations: new Map([
                    ['ts', { template: 'Math.round(§)', params: ['x'] }],
                    ['py', { template: 'round(§)', params: ['x'] }],
                    ['rs', { template: '§.round()', params: ['x'] }],
                    ['cpp', { template: 'std::round(§)', params: ['x'] }],
                    ['zig', { template: '@round(§)', params: ['x'] }],
                ]),
            }],
            ['truncatum', {
                name: 'truncatum',
                translations: new Map([
                    ['ts', { template: 'Math.trunc(§)', params: ['x'] }],
                    ['py', { template: 'math.trunc(§)', params: ['x'] }],
                    ['rs', { template: '§.trunc()', params: ['x'] }],
                    ['cpp', { template: 'std::trunc(§)', params: ['x'] }],
                    ['zig', { template: '@trunc(§)', params: ['x'] }],
                ]),
            }],
            ['radix', {
                name: 'radix',
                translations: new Map([
                    ['ts', { template: 'Math.sqrt(§)', params: ['x'] }],
                    ['py', { template: 'math.sqrt(§)', params: ['x'] }],
                    ['rs', { template: '§.sqrt()', params: ['x'] }],
                    ['cpp', { template: 'std::sqrt(§)', params: ['x'] }],
                    ['zig', { template: '@sqrt(§)', params: ['x'] }],
                ]),
            }],
            ['potentia', {
                name: 'potentia',
                translations: new Map([
                    ['ts', { template: 'Math.pow(§, §)', params: ['base', 'exp'] }],
                    ['py', { template: 'math.pow(§, §)', params: ['base', 'exp'] }],
                    ['rs', { template: '§.powf(§)', params: ['base', 'exp'] }],
                    ['cpp', { template: 'std::pow(§, §)', params: ['base', 'exp'] }],
                    ['zig', { template: 'std.math.pow(§, §)', params: ['base', 'exp'] }],
                ]),
            }],
            ['logarithmus', {
                name: 'logarithmus',
                translations: new Map([
                    ['ts', { template: 'Math.log(§)', params: ['x'] }],
                    ['py', { template: 'math.log(§)', params: ['x'] }],
                    ['rs', { template: '§.ln()', params: ['x'] }],
                    ['cpp', { template: 'std::log(§)', params: ['x'] }],
                    ['zig', { template: '@log(§)', params: ['x'] }],
                ]),
            }],
            ['logarithmus10', {
                name: 'logarithmus10',
                translations: new Map([
                    ['ts', { template: 'Math.log10(§)', params: ['x'] }],
                    ['py', { template: 'math.log10(§)', params: ['x'] }],
                    ['rs', { template: '§.log10()', params: ['x'] }],
                    ['cpp', { template: 'std::log10(§)', params: ['x'] }],
                    ['zig', { template: 'std.math.log10(§)', params: ['x'] }],
                ]),
            }],
            ['exponens', {
                name: 'exponens',
                translations: new Map([
                    ['ts', { template: 'Math.exp(§)', params: ['x'] }],
                    ['py', { template: 'math.exp(§)', params: ['x'] }],
                    ['rs', { template: '§.exp()', params: ['x'] }],
                    ['cpp', { template: 'std::exp(§)', params: ['x'] }],
                    ['zig', { template: '@exp(§)', params: ['x'] }],
                ]),
            }],
            ['sinus', {
                name: 'sinus',
                translations: new Map([
                    ['ts', { template: 'Math.sin(§)', params: ['x'] }],
                    ['py', { template: 'math.sin(§)', params: ['x'] }],
                    ['rs', { template: '§.sin()', params: ['x'] }],
                    ['cpp', { template: 'std::sin(§)', params: ['x'] }],
                    ['zig', { template: '@sin(§)', params: ['x'] }],
                ]),
            }],
            ['cosinus', {
                name: 'cosinus',
                translations: new Map([
                    ['ts', { template: 'Math.cos(§)', params: ['x'] }],
                    ['py', { template: 'math.cos(§)', params: ['x'] }],
                    ['rs', { template: '§.cos()', params: ['x'] }],
                    ['cpp', { template: 'std::cos(§)', params: ['x'] }],
                    ['zig', { template: '@cos(§)', params: ['x'] }],
                ]),
            }],
            ['tangens', {
                name: 'tangens',
                translations: new Map([
                    ['ts', { template: 'Math.tan(§)', params: ['x'] }],
                    ['py', { template: 'math.tan(§)', params: ['x'] }],
                    ['rs', { template: '§.tan()', params: ['x'] }],
                    ['cpp', { template: 'std::tan(§)', params: ['x'] }],
                    ['zig', { template: '@tan(§)', params: ['x'] }],
                ]),
            }],
            ['absolutum', {
                name: 'absolutum',
                translations: new Map([
                    ['ts', { template: 'Math.abs(§)', params: ['x'] }],
                    ['py', { template: 'abs(§)', params: ['x'] }],
                    ['rs', { template: '§.abs()', params: ['x'] }],
                    ['cpp', { template: 'std::abs(§)', params: ['x'] }],
                    ['zig', { template: '@abs(§)', params: ['x'] }],
                ]),
            }],
            ['signum', {
                name: 'signum',
                translations: new Map([
                    ['ts', { template: 'Math.sign(§)', params: ['x'] }],
                    ['py', { template: '(1 if §0 > 0 else (-1 if §0 < 0 else 0))', params: ['x'] }],
                    ['rs', { template: '§.signum()', params: ['x'] }],
                    ['cpp', { template: '((§0 > 0) - (§0 < 0))', params: ['x'] }],
                    ['zig', { template: 'std.math.sign(§)', params: ['x'] }],
                ]),
            }],
            ['minimus', {
                name: 'minimus',
                translations: new Map([
                    ['ts', { template: 'Math.min(§, §)', params: ['a', 'b'] }],
                    ['py', { template: 'min(§, §)', params: ['a', 'b'] }],
                    ['rs', { template: '§.min(§)', params: ['a', 'b'] }],
                    ['cpp', { template: 'std::min(§, §)', params: ['a', 'b'] }],
                    ['zig', { template: '@min(§, §)', params: ['a', 'b'] }],
                ]),
            }],
            ['maximus', {
                name: 'maximus',
                translations: new Map([
                    ['ts', { template: 'Math.max(§, §)', params: ['a', 'b'] }],
                    ['py', { template: 'max(§, §)', params: ['a', 'b'] }],
                    ['rs', { template: '§.max(§)', params: ['a', 'b'] }],
                    ['cpp', { template: 'std::max(§, §)', params: ['a', 'b'] }],
                    ['zig', { template: '@max(§, §)', params: ['a', 'b'] }],
                ]),
            }],
            ['constringens', {
                name: 'constringens',
                translations: new Map([
                    ['ts', { template: 'Math.min(Math.max(§, §), §)', params: ['x', 'lo', 'hi'] }],
                    ['py', { template: 'max(§1, min(§0, §2))', params: ['x', 'lo', 'hi'] }],
                    ['rs', { template: '§.clamp(§, §)', params: ['x', 'lo', 'hi'] }],
                    ['cpp', { template: 'std::clamp(§, §, §)', params: ['x', 'lo', 'hi'] }],
                    ['zig', { template: 'std.math.clamp(§, §, §)', params: ['x', 'lo', 'hi'] }],
                ]),
            }],
            ['PI', {
                name: 'PI',
                translations: new Map([
                    ['ts', { template: 'Math.PI', params: [] }],
                    ['py', { template: 'math.pi', params: [] }],
                    ['rs', { template: 'std::f64::consts::PI', params: [] }],
                    ['cpp', { template: 'M_PI', params: [] }],
                    ['zig', { template: 'std.math.pi', params: [] }],
                ]),
            }],
            ['E', {
                name: 'E',
                translations: new Map([
                    ['ts', { template: 'Math.E', params: [] }],
                    ['py', { template: 'math.e', params: [] }],
                    ['rs', { template: 'std::f64::consts::E', params: [] }],
                    ['cpp', { template: 'M_E', params: [] }],
                    ['zig', { template: 'std.math.e', params: [] }],
                ]),
            }],
            ['TAU', {
                name: 'TAU',
                translations: new Map([
                    ['ts', { template: '(Math.PI * 2)', params: [] }],
                    ['py', { template: '(math.pi * 2)', params: [] }],
                    ['rs', { template: 'std::f64::consts::TAU', params: [] }],
                    ['cpp', { template: '(M_PI * 2)', params: [] }],
                    ['zig', { template: '(std.math.pi * 2)', params: [] }],
                ]),
            }],
        ]),
    }],
    ['aleator', {
        name: 'aleator',
        innatum: new Map([
            ['ts', 'crypto'],
            ['py', 'random'],
            ['rs', 'rand'],
            ['cpp', 'random'],
            ['zig', 'std.rand'],
        ]),
        methods: new Map([
            ['fractus', {
                name: 'fractus',
                translations: new Map([
                    ['ts', { template: 'Math.random()', params: [] }],
                    ['py', { template: 'random.random()', params: [] }],
                    ['rs', { template: 'rand::random::<f64>()', params: [] }],
                    ['cpp', { template: '[&]{ std::random_device rd; std::mt19937 gen(rd()); std::uniform_real_distribution<> dis(0.0, 1.0); return dis(gen); }()', params: [] }],
                    ['zig', { template: 'blk: { var seed: u64 = undefined; std.crypto.random.bytes(std.mem.asBytes(&seed)); var prng = std.rand.DefaultPrng.init(seed); break :blk prng.random().float(f64); }', params: [] }],
                ]),
            }],
            ['inter', {
                name: 'inter',
                translations: new Map([
                    ['ts', { template: 'Math.floor(Math.random() * (§1 - §0 + 1)) + §0', params: ['min', 'max'] }],
                    ['py', { template: 'random.randint(§0, §1)', params: ['min', 'max'] }],
                    ['rs', { template: 'rand::thread_rng().gen_range(§0..=§1)', params: ['min', 'max'] }],
                    ['cpp', { template: '[&]{ std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution<> dis(§0, §1); return dis(gen); }()', params: ['min', 'max'] }],
                    ['zig', { template: 'blk: { var seed: u64 = undefined; std.crypto.random.bytes(std.mem.asBytes(&seed)); var prng = std.rand.DefaultPrng.init(seed); break :blk prng.random().intRangeAtMost(i64, §0, §1); }', params: ['min', 'max'] }],
                ]),
            }],
            ['octeti', {
                name: 'octeti',
                translations: new Map([
                    ['ts', { template: 'crypto.getRandomValues(new Uint8Array(§))', params: ['n'] }],
                    ['py', { template: 'secrets.token_bytes(§)', params: ['n'] }],
                    ['rs', { template: '{ let mut bytes = vec![0u8; §]; rand::thread_rng().fill(&mut bytes[..]); bytes }', params: ['n'] }],
                    ['cpp', { template: '[&]{ std::vector<uint8_t> bytes(§); std::random_device rd; for (auto& b : bytes) b = static_cast<uint8_t>(rd()); return bytes; }()', params: ['n'] }],
                    ['zig', { template: 'blk: { var buf = §1.alloc(u8, §0) catch unreachable; std.crypto.random.bytes(buf); break :blk buf; }', params: ['n', 'alloc'] }],
                ]),
            }],
            ['uuid', {
                name: 'uuid',
                translations: new Map([
                    ['ts', { template: 'crypto.randomUUID()', params: [] }],
                    ['py', { template: 'str(uuid.uuid4())', params: [] }],
                    ['rs', { template: 'uuid::Uuid::new_v4().to_string()', params: [] }],
                    ['cpp', { template: '[&]{ std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution<> dis(0, 15); auto hex = [](int n) { return \"0123456789abcdef\"[n]; }; std::string uuid; for (int i = 0; i < 36; ++i) { if (i == 8 || i == 13 || i == 18 || i == 23) uuid += \'-\'; else if (i == 14) uuid += \'4\'; else if (i == 19) uuid += hex((dis(gen) & 0x3) | 0x8); else uuid += hex(dis(gen)); } return uuid; }()', params: [] }],
                    ['zig', { template: 'blk: { var buf: [36]u8 = undefined; var bytes: [16]u8 = undefined; std.crypto.random.bytes(&bytes); bytes[6] = (bytes[6] & 0x0f) | 0x40; bytes[8] = (bytes[8] & 0x3f) | 0x80; const hex = \"0123456789abcdef\"; var i: usize = 0; for (bytes, 0..) |b, j| { if (j == 4 or j == 6 or j == 8 or j == 10) { buf[i] = \'-\'; i += 1; } buf[i] = hex[b >> 4]; buf[i + 1] = hex[b & 0x0f]; i += 2; } break :blk buf; }', params: [] }],
                ]),
            }],
            ['selige', {
                name: 'selige',
                translations: new Map([
                    ['ts', { template: '§0[Math.floor(Math.random() * §0.length)]', params: ['lista'] }],
                    ['py', { template: 'random.choice(§0)', params: ['lista'] }],
                    ['rs', { template: '§0.choose(&mut rand::thread_rng()).unwrap().clone()', params: ['lista'] }],
                    ['cpp', { template: '[&]{ std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution<size_t> dis(0, §0.size() - 1); return §0[dis(gen)]; }()', params: ['lista'] }],
                    ['zig', { template: 'blk: { var seed: u64 = undefined; std.crypto.random.bytes(std.mem.asBytes(&seed)); var prng = std.rand.DefaultPrng.init(seed); break :blk §0[prng.random().uintLessThan(usize, §0.len)]; }', params: ['lista'] }],
                ]),
            }],
            ['miscita', {
                name: 'miscita',
                translations: new Map([
                    ['ts', { template: '(() => { const a = [...§0]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; })()', params: ['lista'] }],
                    ['py', { template: 'random.sample(§0, len(§0))', params: ['lista'] }],
                    ['rs', { template: '{ let mut v = §0.clone(); v.shuffle(&mut rand::thread_rng()); v }', params: ['lista'] }],
                    ['cpp', { template: '[&]{ auto v = §0; std::random_device rd; std::mt19937 gen(rd()); std::ranges::shuffle(v, gen); return v; }()', params: ['lista'] }],
                    ['zig', { template: 'blk: { var seed: u64 = undefined; std.crypto.random.bytes(std.mem.asBytes(&seed)); var prng = std.rand.DefaultPrng.init(seed); var copy = §1.dupe(@TypeOf(§0[0]), §0) catch unreachable; prng.random().shuffle(@TypeOf(copy[0]), copy); break :blk copy; }', params: ['lista', 'alloc'] }],
                ]),
                radixForms: ['misc', 'perfectum'],
            }],
            ['semen', {
                name: 'semen',
                translations: new Map([
                    ['ts', { template: 'undefined /* JS Math.random is not seedable */', params: ['n'] }],
                    ['py', { template: 'random.seed(§)', params: ['n'] }],
                    ['rs', { template: '/* seed(§) - use rand::SeedableRng for reproducible results */', params: ['n'] }],
                    ['cpp', { template: '/* seed(§) - C++ requires explicit generator management */', params: ['n'] }],
                    ['zig', { template: '@compileLog(\"seed(§) - Zig requires explicit PRNG state management\")', params: ['n'] }],
                ]),
            }],
        ]),
    }],
    ['solum', {
        name: 'solum',
        innatum: new Map([
            ['ts', 'fs'],
            ['py', 'os'],
            ['rs', 'std::fs'],
            ['cpp', 'std::filesystem'],
            ['zig', 'solum'],
        ]),
        methods: new Map([
            ['legens', {
                name: 'legens',
                translations: new Map([
                    ['ts', { template: 'fs.createReadStream(§)', params: ['path'] }],
                    ['py', { template: 'open(§, \'rb\')', params: ['path'] }],
                    ['zig', { template: 'solum.legens(§)', params: ['path'] }],
                ]),
                radixForms: ['leg', 'participium_praesens'],
            }],
            ['leget', {
                name: 'leget',
                translations: new Map([
                    ['ts', { template: 'fs.promises.readFile(§, \'utf-8\')', params: ['path'] }],
                    ['py', { template: 'aiofiles.open(§).read()', params: ['path'] }],
                    ['zig', { template: 'solum.leget(§1, §0)', params: ['path', 'alloc'] }],
                ]),
                radixForms: ['leg', 'futurum_indicativum'],
            }],
            ['lege', {
                name: 'lege',
                translations: new Map([
                    ['ts', { template: 'fs.readFileSync(§, \'utf-8\')', params: ['path'] }],
                    ['py', { template: 'open(§).read()', params: ['path'] }],
                    ['zig', { template: 'solum.lege(§1, §0)', params: ['path', 'alloc'] }],
                ]),
                radixForms: ['leg', 'imperativus'],
            }],
            ['ausculta', {
                name: 'ausculta',
                translations: new Map([
                    ['ts', { template: 'readline.createInterface({ input: process.stdin })', params: [] }],
                    ['py', { template: 'sys.stdin', params: [] }],
                    ['zig', { template: 'solum.ausculta()', params: [] }],
                ]),
            }],
            ['hauri', {
                name: 'hauri',
                translations: new Map([
                    ['ts', { template: 'fs.readFileSync(0, \'utf-8\')', params: [] }],
                    ['py', { template: 'sys.stdin.read()', params: [] }],
                    ['zig', { template: 'solum.hauri(§)', params: ['alloc'] }],
                ]),
            }],
            ['scribens', {
                name: 'scribens',
                translations: new Map([
                    ['ts', { template: 'fs.createWriteStream(§)', params: ['path'] }],
                    ['py', { template: 'open(§, \'wb\')', params: ['path'] }],
                    ['zig', { template: 'solum.scribens(§)', params: ['path'] }],
                ]),
                radixForms: ['scrib', 'participium_praesens'],
            }],
            ['scribet', {
                name: 'scribet',
                translations: new Map([
                    ['ts', { template: 'fs.promises.writeFile(§, §)', params: ['path', 'data'] }],
                    ['py', { template: 'aiofiles.open(§, \'w\').write(§)', params: ['path', 'data'] }],
                    ['zig', { template: 'solum.scribet(§, §)', params: ['path', 'data'] }],
                ]),
                radixForms: ['scrib', 'futurum_indicativum'],
            }],
            ['inscribe', {
                name: 'inscribe',
                translations: new Map([
                    ['ts', { template: 'fs.writeFileSync(§, §)', params: ['path', 'data'] }],
                    ['py', { template: 'open(§, \'w\').write(§)', params: ['path', 'data'] }],
                    ['zig', { template: 'solum.inscribe(§, §)', params: ['path', 'data'] }],
                ]),
                radixForms: ['inscrib', 'imperativus'],
            }],
            ['apponet', {
                name: 'apponet',
                translations: new Map([
                    ['ts', { template: 'fs.promises.appendFile(§, §)', params: ['path', 'data'] }],
                    ['py', { template: 'aiofiles.open(§, \'a\').write(§)', params: ['path', 'data'] }],
                    ['zig', { template: 'solum.apponet(§, §)', params: ['path', 'data'] }],
                ]),
                radixForms: ['appon', 'futurum_indicativum'],
            }],
            ['appone', {
                name: 'appone',
                translations: new Map([
                    ['ts', { template: 'fs.appendFileSync(§, §)', params: ['path', 'data'] }],
                    ['py', { template: 'open(§, \'a\').write(§)', params: ['path', 'data'] }],
                    ['zig', { template: 'solum.appone(§, §)', params: ['path', 'data'] }],
                ]),
                radixForms: ['appon', 'imperativus'],
            }],
            ['exstat', {
                name: 'exstat',
                translations: new Map([
                    ['ts', { template: 'fs.existsSync(§)', params: ['path'] }],
                    ['py', { template: 'os.path.exists(§)', params: ['path'] }],
                    ['zig', { template: 'solum.exstat(§)', params: ['path'] }],
                ]),
            }],
            ['inspice', {
                name: 'inspice',
                translations: new Map([
                    ['ts', { template: 'fs.promises.stat(§)', params: ['path'] }],
                    ['py', { template: 'os.stat(§)', params: ['path'] }],
                    ['zig', { template: 'solum.inspice(§)', params: ['path'] }],
                ]),
            }],
            ['dele', {
                name: 'dele',
                translations: new Map([
                    ['ts', { template: 'fs.promises.unlink(§)', params: ['path'] }],
                    ['py', { template: 'os.remove(§)', params: ['path'] }],
                    ['zig', { template: 'solum.dele(§)', params: ['path'] }],
                ]),
                radixForms: ['del', 'futurum_indicativum', 'imperativus'],
            }],
            ['duplica', {
                name: 'duplica',
                translations: new Map([
                    ['ts', { template: 'fs.promises.copyFile(§, §)', params: ['src', 'dest'] }],
                    ['py', { template: 'shutil.copy2(§, §)', params: ['src', 'dest'] }],
                    ['zig', { template: 'solum.duplica(§, §)', params: ['src', 'dest'] }],
                ]),
                radixForms: ['duplic', 'futurum_indicativum', 'imperativus'],
            }],
            ['move', {
                name: 'move',
                translations: new Map([
                    ['ts', { template: 'fs.promises.rename(§, §)', params: ['src', 'dest'] }],
                    ['py', { template: 'shutil.move(§, §)', params: ['src', 'dest'] }],
                    ['zig', { template: 'solum.move(§, §)', params: ['src', 'dest'] }],
                ]),
                radixForms: ['mov', 'futurum_indicativum', 'imperativus'],
            }],
            ['trunca', {
                name: 'trunca',
                translations: new Map([
                    ['ts', { template: 'fs.promises.truncate(§, §)', params: ['path', 'size'] }],
                    ['py', { template: 'os.truncate(§, §)', params: ['path', 'size'] }],
                    ['zig', { template: 'solum.trunca(§, §)', params: ['path', 'size'] }],
                ]),
            }],
            ['tange', {
                name: 'tange',
                translations: new Map([
                    ['ts', { template: 'fs.promises.utimes(§, Date.now(), Date.now())', params: ['path'] }],
                    ['py', { template: 'pathlib.Path(§).touch()', params: ['path'] }],
                    ['zig', { template: 'solum.tange(§)', params: ['path'] }],
                ]),
            }],
            ['crea', {
                name: 'crea',
                translations: new Map([
                    ['ts', { template: 'fs.promises.mkdir(§, { recursive: true })', params: ['path'] }],
                    ['py', { template: 'os.makedirs(§, exist_ok=True)', params: ['path'] }],
                    ['zig', { template: 'solum.crea(§)', params: ['path'] }],
                ]),
                radixForms: ['cre', 'futurum_indicativum', 'imperativus'],
            }],
            ['elenca', {
                name: 'elenca',
                translations: new Map([
                    ['ts', { template: 'fs.promises.readdir(§)', params: ['path'] }],
                    ['py', { template: 'os.listdir(§)', params: ['path'] }],
                    ['zig', { template: 'solum.elenca(§1, §0)', params: ['path', 'alloc'] }],
                ]),
                radixForms: ['elenc', 'participium_praesens', 'futurum_indicativum', 'imperativus'],
            }],
            ['ambula', {
                name: 'ambula',
                translations: new Map([
                    ['ts', { template: 'glob.stream(§ + \'/**/*\')', params: ['path'] }],
                    ['py', { template: 'os.walk(§)', params: ['path'] }],
                    ['zig', { template: 'solum.ambula(§)', params: ['path'] }],
                ]),
                radixForms: ['ambul', 'participium_praesens'],
            }],
            ['vacua', {
                name: 'vacua',
                translations: new Map([
                    ['ts', { template: 'fs.promises.rmdir(§)', params: ['path'] }],
                    ['py', { template: 'os.rmdir(§)', params: ['path'] }],
                    ['zig', { template: 'solum.vacua(§)', params: ['path'] }],
                ]),
                radixForms: ['vacu', 'futurum_indicativum', 'imperativus'],
            }],
            ['deleArborem', {
                name: 'deleArborem',
                translations: new Map([
                    ['ts', { template: 'fs.promises.rm(§, { recursive: true })', params: ['path'] }],
                    ['py', { template: 'shutil.rmtree(§)', params: ['path'] }],
                    ['zig', { template: 'solum.deleArborem(§)', params: ['path'] }],
                ]),
            }],
            ['iunge', {
                name: 'iunge',
                translations: new Map([
                    ['ts', { template: 'path.join(...§)', params: ['parts'] }],
                    ['py', { template: 'os.path.join(*§)', params: ['parts'] }],
                    ['zig', { template: 'solum.iunge(§)', params: ['parts'] }],
                ]),
            }],
            ['dir', {
                name: 'dir',
                translations: new Map([
                    ['ts', { template: 'path.dirname(§)', params: ['path'] }],
                    ['py', { template: 'os.path.dirname(§)', params: ['path'] }],
                    ['zig', { template: 'solum.dir(§)', params: ['path'] }],
                ]),
            }],
            ['basis', {
                name: 'basis',
                translations: new Map([
                    ['ts', { template: 'path.basename(§)', params: ['path'] }],
                    ['py', { template: 'os.path.basename(§)', params: ['path'] }],
                    ['zig', { template: 'solum.basis(§)', params: ['path'] }],
                ]),
            }],
            ['extensio', {
                name: 'extensio',
                translations: new Map([
                    ['ts', { template: 'path.extname(§)', params: ['path'] }],
                    ['py', { template: 'os.path.splitext(§)[1]', params: ['path'] }],
                    ['zig', { template: 'solum.extensio(§)', params: ['path'] }],
                ]),
            }],
            ['resolve', {
                name: 'resolve',
                translations: new Map([
                    ['ts', { template: 'path.resolve(§)', params: ['path'] }],
                    ['py', { template: 'os.path.abspath(§)', params: ['path'] }],
                    ['zig', { template: 'solum.resolve(§1, §0)', params: ['path', 'alloc'] }],
                ]),
            }],
            ['domus', {
                name: 'domus',
                translations: new Map([
                    ['ts', { template: 'os.homedir()', params: [] }],
                    ['py', { template: 'os.path.expanduser(\'~\')', params: [] }],
                    ['zig', { template: 'solum.domus()', params: [] }],
                ]),
            }],
        ]),
    }],
    ['textus', {
        name: 'textus',
        innatum: new Map([
            ['ts', 'string'],
            ['py', 'str'],
            ['rs', '&str'],
            ['cpp', 'std::string'],
            ['zig', '[]const u8'],
        ]),
        methods: new Map([
            ['longitudo', {
                name: 'longitudo',
                translations: new Map([
                    ['ts', { template: '§.length', params: ['ego'] }],
                    ['py', { template: 'len(§)', params: ['ego'] }],
                    ['rs', { template: '§.len()', params: ['ego'] }],
                    ['cpp', { template: '§.length()', params: ['ego'] }],
                    ['zig', { template: '§.len', params: ['ego'] }],
                ]),
            }],
            ['sectio', {
                name: 'sectio',
                translations: new Map([
                    ['ts', { method: 'slice' }],
                    ['py', { template: '§[§:§]', params: ['ego', 'start', 'end'] }],
                    ['rs', { template: '&§[§..§]', params: ['ego', 'start', 'end'] }],
                    ['cpp', { template: '§.substr(§, § - §)', params: ['ego', 'start', 'end'] }],
                    ['zig', { template: '§[§..§]', params: ['ego', 'start', 'end'] }],
                ]),
            }],
            ['continet', {
                name: 'continet',
                translations: new Map([
                    ['ts', { method: 'includes' }],
                    ['py', { template: '§ in §', params: ['ego', 'sub'] }],
                    ['rs', { method: 'contains' }],
                    ['cpp', { template: '(§.find(§) != std::string::npos)', params: ['ego', 'sub'] }],
                    ['zig', { template: '(std.mem.indexOf(u8, §, §) != null)', params: ['ego', 'sub'] }],
                ]),
            }],
            ['initium', {
                name: 'initium',
                translations: new Map([
                    ['ts', { method: 'startsWith' }],
                    ['py', { method: 'startswith' }],
                    ['rs', { method: 'starts_with' }],
                    ['cpp', { template: '(§.rfind(§, 0) == 0)', params: ['ego', 'prefix'] }],
                    ['zig', { template: 'std.mem.startsWith(u8, §, §)', params: ['ego', 'prefix'] }],
                ]),
            }],
            ['finis', {
                name: 'finis',
                translations: new Map([
                    ['ts', { method: 'endsWith' }],
                    ['py', { method: 'endswith' }],
                    ['rs', { method: 'ends_with' }],
                    ['cpp', { template: '(§.size() >= §.size() && §.compare(§.size() - §.size(), §.size(), §) == 0)', params: ['ego', 'suffix'] }],
                    ['zig', { template: 'std.mem.endsWith(u8, §, §)', params: ['ego', 'suffix'] }],
                ]),
            }],
            ['maiuscula', {
                name: 'maiuscula',
                translations: new Map([
                    ['ts', { method: 'toUpperCase' }],
                    ['py', { method: 'upper' }],
                    ['rs', { method: 'to_uppercase' }],
                    ['cpp', { template: '[&]{ auto s = §; std::transform(s.begin(), s.end(), s.begin(), ::toupper); return s; }()', params: ['ego'] }],
                    ['zig', { template: 'std.ascii.upperString(§)', params: ['ego'] }],
                ]),
            }],
            ['minuscula', {
                name: 'minuscula',
                translations: new Map([
                    ['ts', { method: 'toLowerCase' }],
                    ['py', { method: 'lower' }],
                    ['rs', { method: 'to_lowercase' }],
                    ['cpp', { template: '[&]{ auto s = §; std::transform(s.begin(), s.end(), s.begin(), ::tolower); return s; }()', params: ['ego'] }],
                    ['zig', { template: 'std.ascii.lowerString(§)', params: ['ego'] }],
                ]),
            }],
            ['recide', {
                name: 'recide',
                translations: new Map([
                    ['ts', { method: 'trim' }],
                    ['py', { method: 'strip' }],
                    ['rs', { method: 'trim' }],
                    ['cpp', { template: '[&]{ auto s = §; s.erase(0, s.find_first_not_of(\" \\t\\n\\r\")); s.erase(s.find_last_not_of(\" \\t\\n\\r\") + 1); return s; }()', params: ['ego'] }],
                    ['zig', { template: 'std.mem.trim(u8, §, \" \\t\\n\\r\")', params: ['ego'] }],
                ]),
            }],
            ['divide', {
                name: 'divide',
                translations: new Map([
                    ['ts', { method: 'split' }],
                    ['py', { method: 'split' }],
                    ['rs', { template: '§.split(§).collect::<Vec<_>>()', params: ['ego', 'sep'] }],
                    ['cpp', { template: '@compileError(\"No single-expression split in C++ - use manual loop\")', params: ['ego', 'sep'] }],
                    ['zig', { template: '@compileError(\"Use std.mem.splitSequence for Zig\")', params: ['ego', 'sep'] }],
                ]),
            }],
            ['muta', {
                name: 'muta',
                translations: new Map([
                    ['ts', { method: 'replaceAll' }],
                    ['py', { method: 'replace' }],
                    ['rs', { method: 'replace' }],
                    ['cpp', { template: 'std::regex_replace(§, std::regex(§), §)', params: ['ego', 'old', 'new'] }],
                    ['zig', { template: '@compileError(\"Use std.mem.replace for Zig\")', params: ['ego', 'old', 'new'] }],
                ]),
            }],
        ]),
    }],
    ['copia', {
        name: 'copia',
        innatum: new Map([
            ['ts', 'Set'],
            ['py', 'set'],
            ['rs', 'HashSet'],
            ['cpp', 'std::unordered_set'],
            ['zig', 'Copia'],
        ]),
        methods: new Map([
            ['adde', {
                name: 'adde',
                translations: new Map([
                    ['ts', { method: 'add' }],
                    ['py', { method: 'add' }],
                    ['rs', { method: 'insert' }],
                    ['cpp', { method: 'insert' }],
                    ['zig', { template: '§0.adde(§2, §1)', params: ['ego', 'elem', 'alloc'] }],
                ]),
                radixForms: ['add', 'imperativus'],
            }],
            ['habet', {
                name: 'habet',
                translations: new Map([
                    ['ts', { method: 'has' }],
                    ['py', { template: '(§1 in §0)', params: ['ego', 'elem'] }],
                    ['rs', { template: '§0.contains(&§1)', params: ['ego', 'elem'] }],
                    ['cpp', { template: '§0.contains(§1)', params: ['ego', 'elem'] }],
                    ['zig', { template: '§0.habet(§1)', params: ['ego', 'elem'] }],
                ]),
            }],
            ['dele', {
                name: 'dele',
                translations: new Map([
                    ['ts', { method: 'delete' }],
                    ['py', { method: 'discard' }],
                    ['rs', { template: '§0.remove(&§1)', params: ['ego', 'elem'] }],
                    ['cpp', { template: '§0.erase(§1)', params: ['ego', 'elem'] }],
                    ['zig', { template: '_ = §0.dele(§1)', params: ['ego', 'elem'] }],
                ]),
                radixForms: ['del', 'imperativus'],
            }],
            ['longitudo', {
                name: 'longitudo',
                translations: new Map([
                    ['ts', { template: '§.size', params: ['ego'] }],
                    ['py', { template: 'len(§)', params: ['ego'] }],
                    ['rs', { template: '§.len()', params: ['ego'] }],
                    ['cpp', { template: '§.size()', params: ['ego'] }],
                    ['zig', { template: '§.longitudo()', params: ['ego'] }],
                ]),
            }],
            ['vacua', {
                name: 'vacua',
                translations: new Map([
                    ['ts', { template: '§.size === 0', params: ['ego'] }],
                    ['py', { template: 'len(§) == 0', params: ['ego'] }],
                    ['rs', { template: '§.is_empty()', params: ['ego'] }],
                    ['cpp', { template: '§.empty()', params: ['ego'] }],
                    ['zig', { template: '§.vacua()', params: ['ego'] }],
                ]),
            }],
            ['purga', {
                name: 'purga',
                translations: new Map([
                    ['ts', { method: 'clear' }],
                    ['py', { method: 'clear' }],
                    ['rs', { method: 'clear' }],
                    ['cpp', { method: 'clear' }],
                    ['zig', { template: '§.purga()', params: ['ego'] }],
                ]),
                radixForms: ['purg', 'imperativus'],
            }],
            ['valores', {
                name: 'valores',
                translations: new Map([
                    ['ts', { method: 'values' }],
                    ['py', { template: 'iter(§)', params: ['ego'] }],
                    ['rs', { template: '§.iter()', params: ['ego'] }],
                    ['cpp', { template: '§', params: ['ego'] }],
                    ['zig', { template: '§.valores()', params: ['ego'] }],
                ]),
            }],
            ['perambula', {
                name: 'perambula',
                translations: new Map([
                    ['ts', { method: 'forEach' }],
                    ['py', { template: '[(§1)(x) for x in §0]', params: ['ego', 'fn'] }],
                    ['rs', { template: '§0.iter().for_each(§1)', params: ['ego', 'fn'] }],
                    ['cpp', { template: 'std::ranges::for_each(§0, §1)', params: ['ego', 'fn'] }],
                    ['zig', { template: '@compileError(\"perambula not implemented for Zig - use \'ex set.valores() pro item { ... }\' loop\")', params: ['ego', 'fn'] }],
                ]),
            }],
            ['unio', {
                name: 'unio',
                translations: new Map([
                    ['ts', { template: 'new Set([...§0, ...§1])', params: ['ego', 'alia'] }],
                    ['py', { template: '§0 | §1', params: ['ego', 'alia'] }],
                    ['rs', { template: 'faber::copia_unio(&§0, &§1)', params: ['ego', 'alia'] }],
                    ['cpp', { template: 'faber::copia_unio(§0, §1)', params: ['ego', 'alia'] }],
                    ['zig', { template: '@compileError(\"unio not implemented for Zig - use explicit loop to merge sets\")', params: ['ego', 'alia'] }],
                ]),
            }],
            ['intersectio', {
                name: 'intersectio',
                translations: new Map([
                    ['ts', { template: 'new Set([...§0].filter(x => §1.has(x)))', params: ['ego', 'alia'] }],
                    ['py', { template: '§0 & §1', params: ['ego', 'alia'] }],
                    ['rs', { template: 'faber::copia_intersectio(&§0, &§1)', params: ['ego', 'alia'] }],
                    ['cpp', { template: 'faber::copia_intersectio(§0, §1)', params: ['ego', 'alia'] }],
                    ['zig', { template: '@compileError(\"intersectio not implemented for Zig - use explicit loop\")', params: ['ego', 'alia'] }],
                ]),
            }],
            ['differentia', {
                name: 'differentia',
                translations: new Map([
                    ['ts', { template: 'new Set([...§0].filter(x => !§1.has(x)))', params: ['ego', 'alia'] }],
                    ['py', { template: '§0 - §1', params: ['ego', 'alia'] }],
                    ['rs', { template: 'faber::copia_differentia(&§0, &§1)', params: ['ego', 'alia'] }],
                    ['cpp', { template: 'faber::copia_differentia(§0, §1)', params: ['ego', 'alia'] }],
                    ['zig', { template: '@compileError(\"differentia not implemented for Zig - use explicit loop\")', params: ['ego', 'alia'] }],
                ]),
            }],
            ['symmetrica', {
                name: 'symmetrica',
                translations: new Map([
                    ['ts', { template: 'new Set([...[...§0].filter(x => !§1.has(x)), ...[...§1].filter(x => !§0.has(x))])', params: ['ego', 'alia'] }],
                    ['py', { template: '§0 ^ §1', params: ['ego', 'alia'] }],
                    ['rs', { template: 'faber::copia_symmetrica(&§0, &§1)', params: ['ego', 'alia'] }],
                    ['cpp', { template: 'faber::copia_symmetrica(§0, §1)', params: ['ego', 'alia'] }],
                    ['zig', { template: '@compileError(\"symmetrica not implemented for Zig - use explicit loop\")', params: ['ego', 'alia'] }],
                ]),
            }],
            ['subcopia', {
                name: 'subcopia',
                translations: new Map([
                    ['ts', { template: '[...§0].every(x => §1.has(x))', params: ['ego', 'alia'] }],
                    ['py', { template: '§0 <= §1', params: ['ego', 'alia'] }],
                    ['rs', { template: '§0.is_subset(&§1)', params: ['ego', 'alia'] }],
                    ['cpp', { template: 'faber::copia_subcopia(§0, §1)', params: ['ego', 'alia'] }],
                    ['zig', { template: '@compileError(\"subcopia not implemented for Zig - use explicit loop\")', params: ['ego', 'alia'] }],
                ]),
            }],
            ['supercopia', {
                name: 'supercopia',
                translations: new Map([
                    ['ts', { template: '[...§1].every(x => §0.has(x))', params: ['ego', 'alia'] }],
                    ['py', { template: '§0 >= §1', params: ['ego', 'alia'] }],
                    ['rs', { template: '§0.is_superset(&§1)', params: ['ego', 'alia'] }],
                    ['cpp', { template: 'faber::copia_supercopia(§0, §1)', params: ['ego', 'alia'] }],
                    ['zig', { template: '@compileError(\"supercopia not implemented for Zig - use explicit loop\")', params: ['ego', 'alia'] }],
                ]),
            }],
            ['inLista', {
                name: 'inLista',
                translations: new Map([
                    ['ts', { template: '[...§]', params: ['ego'] }],
                    ['py', { template: 'list(§)', params: ['ego'] }],
                    ['rs', { template: 'faber::copia_in_lista(&§)', params: ['ego'] }],
                    ['cpp', { template: 'faber::copia_in_lista(§)', params: ['ego'] }],
                    ['zig', { template: '@compileError(\"inLista not implemented for Zig - iterate with ex...pro into ArrayList\")', params: ['ego'] }],
                ]),
            }],
        ]),
    }],
    ['caelum', {
        name: 'caelum',
        innatum: new Map([
            ['ts', 'caelum'],
            ['py', 'caelum'],
            ['rs', 'caelum'],
            ['cpp', 'caelum'],
            ['zig', 'caelum'],
        ]),
        methods: new Map([
            ['pete', {
                name: 'pete',
                translations: new Map([
                    ['ts', { template: 'caelum.pete(§)', params: ['url'] }],
                    ['py', { template: 'caelum.pete(§)', params: ['url'] }],
                    ['rs', { template: 'caelum::pete(§)', params: ['url'] }],
                    ['cpp', { template: 'caelum::pete(§)', params: ['url'] }],
                    ['zig', { template: 'caelum.pete(§)', params: ['url'] }],
                ]),
                radixForms: ['pet', 'imperativus'],
            }],
            ['mitte', {
                name: 'mitte',
                translations: new Map([
                    ['ts', { template: 'caelum.mitte(§, §)', params: ['url', 'corpus'] }],
                    ['py', { template: 'caelum.mitte(§, §)', params: ['url', 'corpus'] }],
                    ['rs', { template: 'caelum::mitte(§, §)', params: ['url', 'corpus'] }],
                    ['cpp', { template: 'caelum::mitte(§, §)', params: ['url', 'corpus'] }],
                    ['zig', { template: 'caelum.mitte(§, §)', params: ['url', 'corpus'] }],
                ]),
                radixForms: ['mitt', 'imperativus'],
            }],
            ['pone', {
                name: 'pone',
                translations: new Map([
                    ['ts', { template: 'caelum.pone(§, §)', params: ['url', 'corpus'] }],
                    ['py', { template: 'caelum.pone(§, §)', params: ['url', 'corpus'] }],
                    ['rs', { template: 'caelum::pone(§, §)', params: ['url', 'corpus'] }],
                    ['cpp', { template: 'caelum::pone(§, §)', params: ['url', 'corpus'] }],
                    ['zig', { template: 'caelum.pone(§, §)', params: ['url', 'corpus'] }],
                ]),
                radixForms: ['pon', 'imperativus'],
            }],
            ['dele', {
                name: 'dele',
                translations: new Map([
                    ['ts', { template: 'caelum.dele(§)', params: ['url'] }],
                    ['py', { template: 'caelum.dele(§)', params: ['url'] }],
                    ['rs', { template: 'caelum::dele(§)', params: ['url'] }],
                    ['cpp', { template: 'caelum::dele(§)', params: ['url'] }],
                    ['zig', { template: 'caelum.dele(§)', params: ['url'] }],
                ]),
                radixForms: ['del', 'imperativus'],
            }],
            ['muta', {
                name: 'muta',
                translations: new Map([
                    ['ts', { template: 'caelum.muta(§, §)', params: ['url', 'corpus'] }],
                    ['py', { template: 'caelum.muta(§, §)', params: ['url', 'corpus'] }],
                    ['rs', { template: 'caelum::muta(§, §)', params: ['url', 'corpus'] }],
                    ['cpp', { template: 'caelum::muta(§, §)', params: ['url', 'corpus'] }],
                    ['zig', { template: 'caelum.muta(§, §)', params: ['url', 'corpus'] }],
                ]),
                radixForms: ['mut', 'imperativus'],
            }],
            ['roga', {
                name: 'roga',
                translations: new Map([
                    ['ts', { template: 'caelum.roga(§, §, §, §)', params: ['modus', 'url', 'capita', 'corpus'] }],
                    ['py', { template: 'caelum.roga(§, §, §, §)', params: ['modus', 'url', 'capita', 'corpus'] }],
                    ['rs', { template: 'caelum::roga(§, §, §, §)', params: ['modus', 'url', 'capita', 'corpus'] }],
                    ['cpp', { template: 'caelum::roga(§, §, §, §)', params: ['modus', 'url', 'capita', 'corpus'] }],
                    ['zig', { template: 'caelum.roga(§, §, §, §)', params: ['modus', 'url', 'capita', 'corpus'] }],
                ]),
                radixForms: ['rog', 'imperativus'],
            }],
            ['exspecta', {
                name: 'exspecta',
                translations: new Map([
                    ['ts', { template: 'caelum.exspecta(§, §)', params: ['handler', 'portus'] }],
                    ['py', { template: 'caelum.exspecta(§, §)', params: ['handler', 'portus'] }],
                    ['rs', { template: 'caelum::exspecta(§, §)', params: ['handler', 'portus'] }],
                    ['cpp', { template: 'caelum::exspecta(§, §)', params: ['handler', 'portus'] }],
                    ['zig', { template: 'caelum.exspecta(§, §)', params: ['handler', 'portus'] }],
                ]),
            }],
            ['siste', {
                name: 'siste',
                translations: new Map([
                    ['ts', { template: '§.siste()', params: ['s'] }],
                    ['py', { template: '§.siste()', params: ['s'] }],
                    ['rs', { template: '§.siste()', params: ['s'] }],
                    ['cpp', { template: '§.siste()', params: ['s'] }],
                    ['zig', { template: '§.siste()', params: ['s'] }],
                ]),
            }],
            ['replicatio', {
                name: 'replicatio',
                translations: new Map([
                    ['ts', { template: 'caelum.replicatio(§, §, §)', params: ['status', 'capita', 'corpus'] }],
                    ['py', { template: 'caelum.replicatio(§, §, §)', params: ['status', 'capita', 'corpus'] }],
                    ['rs', { template: 'caelum::replicatio(§, §, §)', params: ['status', 'capita', 'corpus'] }],
                    ['cpp', { template: 'caelum::replicatio(§, §, §)', params: ['status', 'capita', 'corpus'] }],
                    ['zig', { template: 'caelum.replicatio(§, §, §)', params: ['status', 'capita', 'corpus'] }],
                ]),
            }],
        ]),
    }],
    ['lista', {
        name: 'lista',
        innatum: new Map([
            ['ts', 'Array'],
            ['py', 'list'],
            ['rs', 'Vec'],
            ['cpp', 'std::vector'],
            ['zig', 'Lista'],
        ]),
        methods: new Map([
            ['adde', {
                name: 'adde',
                translations: new Map([
                    ['ts', { method: 'push' }],
                    ['py', { method: 'append' }],
                    ['rs', { method: 'push' }],
                    ['cpp', { method: 'push_back' }],
                    ['zig', { template: '§0.adde(§2, §1)', params: ['ego', 'elem', 'alloc'] }],
                ]),
                radixForms: ['add', 'imperativus', 'perfectum'],
            }],
            ['addita', {
                name: 'addita',
                translations: new Map([
                    ['ts', { template: '[...§, §]', params: ['ego', 'elem'] }],
                    ['py', { template: '[*§, §]', params: ['ego', 'elem'] }],
                    ['rs', { template: 'faber::lista_addita(&§0, §1)', params: ['ego', 'elem'] }],
                    ['cpp', { template: 'faber::lista_addita(§0, §1)', params: ['ego', 'elem'] }],
                    ['zig', { template: '§0.addita(§2, §1)', params: ['ego', 'elem', 'alloc'] }],
                ]),
            }],
            ['praepone', {
                name: 'praepone',
                translations: new Map([
                    ['ts', { method: 'unshift' }],
                    ['py', { template: '§.insert(0, §)', params: ['ego', 'elem'] }],
                    ['rs', { template: '§.insert(0, §)', params: ['ego', 'elem'] }],
                    ['cpp', { template: '§.insert(§.begin(), §)', params: ['ego', 'elem'] }],
                    ['zig', { template: '§0.praepone(§2, §1)', params: ['ego', 'elem', 'alloc'] }],
                ]),
                radixForms: ['praepon', 'imperativus', 'perfectum'],
            }],
            ['praeposita', {
                name: 'praeposita',
                translations: new Map([
                    ['ts', { template: '[§1, ...§0]', params: ['ego', 'elem'] }],
                    ['py', { template: '[§1, *§0]', params: ['ego', 'elem'] }],
                    ['rs', { template: 'faber::lista_praeposita(&§0, §1)', params: ['ego', 'elem'] }],
                    ['cpp', { template: 'faber::lista_praeposita(§0, §1)', params: ['ego', 'elem'] }],
                    ['zig', { template: '§0.praeposita(§2, §1)', params: ['ego', 'elem', 'alloc'] }],
                ]),
            }],
            ['remove', {
                name: 'remove',
                translations: new Map([
                    ['ts', { method: 'pop' }],
                    ['py', { method: 'pop' }],
                    ['rs', { template: '§.pop()', params: ['ego'] }],
                    ['cpp', { template: 'faber::lista_remove(§0)', params: ['ego'] }],
                    ['zig', { template: '§.remove()', params: ['ego'] }],
                ]),
                radixForms: ['remov', 'imperativus', 'perfectum'],
            }],
            ['remota', {
                name: 'remota',
                translations: new Map([
                    ['ts', { template: '§.slice(0, -1)', params: ['ego'] }],
                    ['py', { template: '§[:-1]', params: ['ego'] }],
                    ['rs', { template: '§0[..§0.len().saturating_sub(1)].to_vec()', params: ['ego'] }],
                    ['cpp', { template: 'std::vector(§0.begin(), §0.end() - 1)', params: ['ego'] }],
                    ['zig', { template: '§.remota(§)', params: ['ego', 'alloc'] }],
                ]),
            }],
            ['decapita', {
                name: 'decapita',
                translations: new Map([
                    ['ts', { method: 'shift' }],
                    ['py', { template: '§.pop(0)', params: ['ego'] }],
                    ['rs', { template: '§.remove(0)', params: ['ego'] }],
                    ['cpp', { template: 'faber::lista_decapita(§0)', params: ['ego'] }],
                    ['zig', { template: '§.decapita()', params: ['ego'] }],
                ]),
                radixForms: ['decapit', 'imperativus', 'perfectum'],
            }],
            ['decapitata', {
                name: 'decapitata',
                translations: new Map([
                    ['ts', { template: '§.slice(1)', params: ['ego'] }],
                    ['py', { template: '§[1:]', params: ['ego'] }],
                    ['rs', { template: '§[1..].to_vec()', params: ['ego'] }],
                    ['cpp', { template: 'std::vector(§0.begin() + 1, §0.end())', params: ['ego'] }],
                    ['zig', { template: '§.decapitata(§)', params: ['ego', 'alloc'] }],
                ]),
            }],
            ['purga', {
                name: 'purga',
                translations: new Map([
                    ['ts', { template: '§.length = 0', params: ['ego'] }],
                    ['py', { method: 'clear' }],
                    ['rs', { method: 'clear' }],
                    ['cpp', { method: 'clear' }],
                    ['zig', { template: '§.purga()', params: ['ego'] }],
                ]),
                radixForms: ['purg', 'imperativus'],
            }],
            ['primus', {
                name: 'primus',
                translations: new Map([
                    ['ts', { template: '§[0]', params: ['ego'] }],
                    ['py', { template: '§[0]', params: ['ego'] }],
                    ['rs', { template: '§.first()', params: ['ego'] }],
                    ['cpp', { template: '§.front()', params: ['ego'] }],
                    ['zig', { template: '§.primus()', params: ['ego'] }],
                ]),
            }],
            ['ultimus', {
                name: 'ultimus',
                translations: new Map([
                    ['ts', { template: '§.at(-1)', params: ['ego'] }],
                    ['py', { template: '§[-1]', params: ['ego'] }],
                    ['rs', { template: '§.last()', params: ['ego'] }],
                    ['cpp', { template: '§.back()', params: ['ego'] }],
                    ['zig', { template: '§.ultimus()', params: ['ego'] }],
                ]),
            }],
            ['accipe', {
                name: 'accipe',
                translations: new Map([
                    ['ts', { template: '§[§]', params: ['ego', 'idx'] }],
                    ['py', { template: '§[§]', params: ['ego', 'idx'] }],
                    ['rs', { template: '§.get(§)', params: ['ego', 'idx'] }],
                    ['cpp', { template: '§.at(§)', params: ['ego', 'idx'] }],
                    ['zig', { template: '§.accipe(§)', params: ['ego', 'idx'] }],
                ]),
            }],
            ['longitudo', {
                name: 'longitudo',
                translations: new Map([
                    ['ts', { template: '§.length', params: ['ego'] }],
                    ['py', { template: 'len(§)', params: ['ego'] }],
                    ['rs', { template: '§.len()', params: ['ego'] }],
                    ['cpp', { template: '§.size()', params: ['ego'] }],
                    ['zig', { template: '§.longitudo()', params: ['ego'] }],
                ]),
            }],
            ['vacua', {
                name: 'vacua',
                translations: new Map([
                    ['ts', { template: '§.length === 0', params: ['ego'] }],
                    ['py', { template: 'len(§) == 0', params: ['ego'] }],
                    ['rs', { template: '§.is_empty()', params: ['ego'] }],
                    ['cpp', { template: '§.empty()', params: ['ego'] }],
                    ['zig', { template: '§.vacua()', params: ['ego'] }],
                ]),
            }],
            ['continet', {
                name: 'continet',
                translations: new Map([
                    ['ts', { method: 'includes' }],
                    ['py', { template: '(§1 in §0)', params: ['ego', 'elem'] }],
                    ['rs', { template: '§0.contains(&§1)', params: ['ego', 'elem'] }],
                    ['cpp', { template: '(std::find(§0.begin(), §0.end(), §1) != §0.end())', params: ['ego', 'elem'] }],
                    ['zig', { template: '§.continet(§)', params: ['ego', 'elem'] }],
                ]),
            }],
            ['indiceDe', {
                name: 'indiceDe',
                translations: new Map([
                    ['ts', { method: 'indexOf' }],
                    ['py', { template: '§0.index(§1)', params: ['ego', 'elem'] }],
                    ['rs', { template: '§0.iter().position(|e| e == &§1)', params: ['ego', 'elem'] }],
                    ['cpp', { template: 'faber::lista_indice_de(§0, §1)', params: ['ego', 'elem'] }],
                    ['zig', { template: '§.indiceDe(§)', params: ['ego', 'elem'] }],
                ]),
            }],
            ['inveni', {
                name: 'inveni',
                translations: new Map([
                    ['ts', { method: 'find' }],
                    ['py', { template: 'next(filter(§1, §0), None)', params: ['ego', 'pred'] }],
                    ['rs', { template: '§0.iter().find(§1)', params: ['ego', 'pred'] }],
                    ['cpp', { template: '*std::find_if(§0.begin(), §0.end(), §1)', params: ['ego', 'pred'] }],
                    ['zig', { template: '§.inveni(§)', params: ['ego', 'pred'] }],
                ]),
            }],
            ['inveniIndicem', {
                name: 'inveniIndicem',
                translations: new Map([
                    ['ts', { method: 'findIndex' }],
                    ['py', { template: 'next((i for i, x in enumerate(§0) if (§1)(x)), -1)', params: ['ego', 'pred'] }],
                    ['rs', { template: '§0.iter().position(§1)', params: ['ego', 'pred'] }],
                    ['cpp', { template: 'faber::lista_inveni_indicem(§0, §1)', params: ['ego', 'pred'] }],
                    ['zig', { template: '§.inveniIndicem(§)', params: ['ego', 'pred'] }],
                ]),
            }],
            ['omnes', {
                name: 'omnes',
                translations: new Map([
                    ['ts', { method: 'every' }],
                    ['py', { template: 'all(map(§, §))', params: ['ego', 'pred'] }],
                    ['rs', { template: '§.iter().all(§)', params: ['ego', 'pred'] }],
                    ['cpp', { template: 'std::ranges::all_of(§, §)', params: ['ego', 'pred'] }],
                    ['zig', { template: '§.omnes(§)', params: ['ego', 'pred'] }],
                ]),
            }],
            ['aliquis', {
                name: 'aliquis',
                translations: new Map([
                    ['ts', { method: 'some' }],
                    ['py', { template: 'any(map(§, §))', params: ['ego', 'pred'] }],
                    ['rs', { template: '§.iter().any(§)', params: ['ego', 'pred'] }],
                    ['cpp', { template: 'std::ranges::any_of(§, §)', params: ['ego', 'pred'] }],
                    ['zig', { template: '§.aliquis(§)', params: ['ego', 'pred'] }],
                ]),
            }],
            ['filtrata', {
                name: 'filtrata',
                translations: new Map([
                    ['ts', { method: 'filter' }],
                    ['py', { template: 'list(filter(§, §))', params: ['ego', 'pred'] }],
                    ['rs', { template: '§.iter().filter(§).cloned().collect::<Vec<_>>()', params: ['ego', 'pred'] }],
                    ['cpp', { template: '(§ | std::views::filter(§) | std::ranges::to<std::vector>())', params: ['ego', 'pred'] }],
                    ['zig', { template: '§0.filtrata(§2, §1)', params: ['ego', 'pred', 'alloc'] }],
                ]),
                radixForms: ['filtr', 'imperativus', 'perfectum'],
            }],
            ['mappata', {
                name: 'mappata',
                translations: new Map([
                    ['ts', { method: 'map' }],
                    ['py', { template: 'list(map(§, §))', params: ['ego', 'fn'] }],
                    ['rs', { template: '§.iter().map(§).collect::<Vec<_>>()', params: ['ego', 'fn'] }],
                    ['cpp', { template: '(§ | std::views::transform(§) | std::ranges::to<std::vector>())', params: ['ego', 'fn'] }],
                    ['zig', { template: '§0.mappata(§2, §1)', params: ['ego', 'fn', 'alloc'] }],
                ]),
                radixForms: ['mapp', 'perfectum'],
            }],
            ['explanata', {
                name: 'explanata',
                translations: new Map([
                    ['ts', { method: 'flatMap' }],
                    ['py', { template: '[y for x in § for y in (§)(x)]', params: ['ego', 'fn'] }],
                    ['rs', { template: '§.iter().flat_map(§).collect::<Vec<_>>()', params: ['ego', 'fn'] }],
                    ['cpp', { template: '(§ | std::views::transform(§) | std::views::join | std::ranges::to<std::vector>())', params: ['ego', 'fn'] }],
                ]),
                radixForms: ['explan', 'perfectum'],
            }],
            ['plana', {
                name: 'plana',
                translations: new Map([
                    ['ts', { method: 'flat' }],
                    ['py', { template: '[y for x in § for y in x]', params: ['ego'] }],
                    ['rs', { template: '§.iter().flatten().cloned().collect::<Vec<_>>()', params: ['ego'] }],
                    ['cpp', { template: '(§ | std::views::join | std::ranges::to<std::vector>())', params: ['ego'] }],
                ]),
            }],
            ['inversa', {
                name: 'inversa',
                translations: new Map([
                    ['ts', { template: '[...§].reverse()', params: ['ego'] }],
                    ['py', { template: '§[::-1]', params: ['ego'] }],
                    ['rs', { template: '§.iter().rev().cloned().collect::<Vec<_>>()', params: ['ego'] }],
                    ['cpp', { template: 'faber::lista_inversa(§)', params: ['ego'] }],
                    ['zig', { template: '§.inversa(§)', params: ['ego', 'alloc'] }],
                ]),
                radixForms: ['inver', 'perfectum'],
            }],
            ['ordinata', {
                name: 'ordinata',
                translations: new Map([
                    ['ts', { template: '[...§].sort()', params: ['ego'] }],
                    ['py', { template: 'sorted(§)', params: ['ego'] }],
                    ['rs', { template: 'faber::lista_ordinata(&§)', params: ['ego'] }],
                    ['cpp', { template: 'faber::lista_ordinata(§)', params: ['ego'] }],
                    ['zig', { template: '§.ordinata(§)', params: ['ego', 'alloc'] }],
                ]),
                radixForms: ['ordin', 'imperativus', 'perfectum'],
            }],
            ['sectio', {
                name: 'sectio',
                translations: new Map([
                    ['ts', { method: 'slice' }],
                    ['py', { template: '§[§:§]', params: ['ego', 'start', 'end'] }],
                    ['rs', { template: '§[§..§].to_vec()', params: ['ego', 'start', 'end'] }],
                    ['cpp', { template: 'std::vector(§.begin() + §, §.begin() + §)', params: ['ego', 'start', 'end'] }],
                    ['zig', { template: '§.sectio(§, §, §)', params: ['ego', 'start', 'end', 'alloc'] }],
                ]),
            }],
            ['prima', {
                name: 'prima',
                translations: new Map([
                    ['ts', { template: '§.slice(0, §)', params: ['ego', 'n'] }],
                    ['py', { template: '§[:§]', params: ['ego', 'n'] }],
                    ['rs', { template: '§.iter().take(§).cloned().collect::<Vec<_>>()', params: ['ego', 'n'] }],
                    ['cpp', { template: '(§ | std::views::take(§) | std::ranges::to<std::vector>())', params: ['ego', 'n'] }],
                    ['zig', { template: '§0.prima(§2, §1)', params: ['ego', 'n', 'alloc'] }],
                ]),
            }],
            ['ultima', {
                name: 'ultima',
                translations: new Map([
                    ['ts', { template: '§.slice(-§)', params: ['ego', 'n'] }],
                    ['py', { template: '§[-§:]', params: ['ego', 'n'] }],
                    ['rs', { template: 'faber::lista_ultima(&§0, §1)', params: ['ego', 'n'] }],
                    ['cpp', { template: 'faber::lista_ultima(§0, §1)', params: ['ego', 'n'] }],
                    ['zig', { template: '§0.ultima(§2, §1)', params: ['ego', 'n', 'alloc'] }],
                ]),
            }],
            ['omissa', {
                name: 'omissa',
                translations: new Map([
                    ['ts', { template: '§.slice(§)', params: ['ego', 'n'] }],
                    ['py', { template: '§[§:]', params: ['ego', 'n'] }],
                    ['rs', { template: '§.iter().skip(§).cloned().collect::<Vec<_>>()', params: ['ego', 'n'] }],
                    ['cpp', { template: '(§ | std::views::drop(§) | std::ranges::to<std::vector>())', params: ['ego', 'n'] }],
                    ['zig', { template: '§0.omissa(§2, §1)', params: ['ego', 'n', 'alloc'] }],
                ]),
                radixForms: ['omis', 'perfectum'],
            }],
            ['reducta', {
                name: 'reducta',
                translations: new Map([
                    ['ts', { method: 'reduce' }],
                    ['py', { template: 'functools.reduce(§, §, §)', params: ['ego', 'fn', 'init'] }],
                    ['rs', { template: '§.iter().fold(§, §)', params: ['ego', 'fn', 'init'] }],
                    ['cpp', { template: 'std::ranges::fold_left(§, §, §)', params: ['ego', 'fn', 'init'] }],
                    ['zig', { template: '§.reducta(§, §)', params: ['ego', 'fn', 'init'] }],
                ]),
                radixForms: ['reduc', 'perfectum'],
            }],
            ['filtra', {
                name: 'filtra',
                translations: new Map([
                    ['ts', { template: '(() => { for (let i = §.length - 1; i >= 0; i--) { if (!(§)(§[i])) §.splice(i, 1); } })()', params: ['ego', 'pred'] }],
                    ['py', { template: '§[:] = [x for x in § if (§)(x)]', params: ['ego', 'pred'] }],
                    ['cpp', { template: '§.erase(std::remove_if(§.begin(), §.end(), [&](auto& x) { return !(§)(x); }), §.end())', params: ['ego', 'pred'] }],
                ]),
                radixForms: ['filtr', 'imperativus', 'perfectum'],
            }],
            ['ordina', {
                name: 'ordina',
                translations: new Map([
                    ['ts', { template: '§.sort()', params: ['ego'] }],
                    ['py', { template: '§.sort()', params: ['ego'] }],
                    ['rs', { template: '§.sort()', params: ['ego'] }],
                    ['cpp', { template: 'std::ranges::sort(§)', params: ['ego'] }],
                    ['zig', { template: '§.ordina()', params: ['ego'] }],
                ]),
                radixForms: ['ordin', 'imperativus', 'perfectum'],
            }],
            ['inverte', {
                name: 'inverte',
                translations: new Map([
                    ['ts', { method: 'reverse' }],
                    ['py', { template: '§.reverse()', params: ['ego'] }],
                    ['rs', { template: '§.reverse()', params: ['ego'] }],
                    ['cpp', { template: 'std::ranges::reverse(§)', params: ['ego'] }],
                    ['zig', { template: '§.inverte()', params: ['ego'] }],
                ]),
                radixForms: ['invert', 'imperativus'],
            }],
            ['perambula', {
                name: 'perambula',
                translations: new Map([
                    ['ts', { method: 'forEach' }],
                    ['py', { template: '[(§)(x) for x in §]', params: ['ego', 'fn'] }],
                    ['rs', { template: '§.iter().for_each(§)', params: ['ego', 'fn'] }],
                    ['cpp', { template: 'std::ranges::for_each(§, §)', params: ['ego', 'fn'] }],
                    ['zig', { template: '§.perambula(§)', params: ['ego', 'fn'] }],
                ]),
            }],
            ['coniunge', {
                name: 'coniunge',
                translations: new Map([
                    ['ts', { method: 'join' }],
                    ['py', { template: '§.join(§)', params: ['ego', 'sep'] }],
                    ['rs', { template: '§.join(§)', params: ['ego', 'sep'] }],
                    ['cpp', { template: 'faber::lista_coniunge(§0, §1)', params: ['ego', 'sep'] }],
                ]),
            }],
            ['summa', {
                name: 'summa',
                translations: new Map([
                    ['ts', { template: '§.reduce((a, b) => a + b, 0)', params: ['ego'] }],
                    ['py', { template: 'sum(§)', params: ['ego'] }],
                    ['rs', { template: '§.iter().sum::<i64>()', params: ['ego'] }],
                    ['cpp', { template: 'std::accumulate(§0.begin(), §0.end(), 0)', params: ['ego'] }],
                    ['zig', { template: '§.summa()', params: ['ego'] }],
                ]),
            }],
            ['medium', {
                name: 'medium',
                translations: new Map([
                    ['ts', { template: '(§0.reduce((a, b) => a + b, 0) / §0.length)', params: ['ego'] }],
                    ['py', { template: '(sum(§0) / len(§0))', params: ['ego'] }],
                    ['rs', { template: '(§0.iter().sum::<i64>() as f64 / §0.len() as f64)', params: ['ego'] }],
                    ['cpp', { template: '(std::accumulate(§0.begin(), §0.end(), 0.0) / §0.size())', params: ['ego'] }],
                    ['zig', { template: '§.medium()', params: ['ego'] }],
                ]),
            }],
            ['minimus', {
                name: 'minimus',
                translations: new Map([
                    ['ts', { template: 'Math.min(...§)', params: ['ego'] }],
                    ['py', { template: 'min(§)', params: ['ego'] }],
                    ['rs', { template: '§.iter().min()', params: ['ego'] }],
                    ['cpp', { template: '*std::ranges::min_element(§)', params: ['ego'] }],
                    ['zig', { template: '§.minimus()', params: ['ego'] }],
                ]),
            }],
            ['maximus', {
                name: 'maximus',
                translations: new Map([
                    ['ts', { template: 'Math.max(...§)', params: ['ego'] }],
                    ['py', { template: 'max(§)', params: ['ego'] }],
                    ['rs', { template: '§.iter().max()', params: ['ego'] }],
                    ['cpp', { template: '*std::ranges::max_element(§)', params: ['ego'] }],
                    ['zig', { template: '§.maximus()', params: ['ego'] }],
                ]),
            }],
            ['minimusPer', {
                name: 'minimusPer',
                translations: new Map([
                    ['ts', { template: '§.reduce((min, x) => (§)(x) < (§)(min) ? x : min)', params: ['ego', 'fn'] }],
                    ['rs', { template: '§.iter().min_by_key(§)', params: ['ego', 'fn'] }],
                    ['cpp', { template: '*std::ranges::min_element(§, [&](auto& a, auto& b) { return (§)(a) < (§)(b); })', params: ['ego', 'fn'] }],
                ]),
            }],
            ['maximusPer', {
                name: 'maximusPer',
                translations: new Map([
                    ['ts', { template: '§.reduce((max, x) => (§)(x) > (§)(max) ? x : max)', params: ['ego', 'fn'] }],
                    ['rs', { template: '§.iter().max_by_key(§)', params: ['ego', 'fn'] }],
                    ['cpp', { template: '*std::ranges::max_element(§, [&](auto& a, auto& b) { return (§)(a) < (§)(b); })', params: ['ego', 'fn'] }],
                ]),
            }],
            ['numera', {
                name: 'numera',
                translations: new Map([
                    ['ts', { template: '§.filter(§).length', params: ['ego', 'pred'] }],
                    ['py', { template: 'sum(1 for x in § if (§)(x))', params: ['ego', 'pred'] }],
                    ['rs', { template: '§.iter().filter(§).count()', params: ['ego', 'pred'] }],
                    ['cpp', { template: 'std::ranges::count_if(§, §)', params: ['ego', 'pred'] }],
                    ['zig', { template: '§.numera(§)', params: ['ego', 'pred'] }],
                ]),
            }],
            ['congrega', {
                name: 'congrega',
                translations: new Map([
                    ['ts', { template: 'Object.groupBy(§, §)', params: ['ego', 'fn'] }],
                    ['py', { template: '{k: list(g) for k, g in itertools.groupby(sorted(§, key=§), key=§)}', params: ['ego', 'fn'] }],
                    ['rs', { template: 'faber::lista_congrega(&§0, §1)', params: ['ego', 'fn'] }],
                    ['cpp', { template: 'faber::lista_congrega(§0, §1)', params: ['ego', 'fn'] }],
                ]),
            }],
            ['unica', {
                name: 'unica',
                translations: new Map([
                    ['ts', { template: '[...new Set(§)]', params: ['ego'] }],
                    ['py', { template: 'list(dict.fromkeys(§))', params: ['ego'] }],
                    ['rs', { template: 'faber::lista_unica(&§)', params: ['ego'] }],
                    ['cpp', { template: 'faber::lista_unica(§)', params: ['ego'] }],
                ]),
            }],
            ['planaOmnia', {
                name: 'planaOmnia',
                translations: new Map([
                    ['ts', { template: '§.flat(Infinity)', params: ['ego'] }],
                    ['cpp', { template: '(§ | std::views::join | std::ranges::to<std::vector>())', params: ['ego'] }],
                ]),
            }],
            ['fragmenta', {
                name: 'fragmenta',
                translations: new Map([
                    ['ts', { template: 'Array.from({ length: Math.ceil(§.length / §) }, (_, i) => §.slice(i * §, i * § + §))', params: ['ego', 'n'] }],
                    ['py', { template: '[§[i:i+§] for i in range(0, len(§), §)]', params: ['ego', 'n'] }],
                    ['rs', { template: '§.chunks(§).map(|c| c.to_vec()).collect::<Vec<_>>()', params: ['ego', 'n'] }],
                    ['cpp', { template: 'faber::lista_fragmenta(§0, §1)', params: ['ego', 'n'] }],
                ]),
            }],
            ['densa', {
                name: 'densa',
                translations: new Map([
                    ['ts', { template: '§.filter(Boolean)', params: ['ego'] }],
                    ['py', { template: '[x for x in § if x]', params: ['ego'] }],
                    ['cpp', { template: '(§ | std::views::filter([](auto& x) { return static_cast<bool>(x); }) | std::ranges::to<std::vector>())', params: ['ego'] }],
                ]),
            }],
            ['partire', {
                name: 'partire',
                translations: new Map([
                    ['ts', { template: '§.reduce(([t, f], x) => (§)(x) ? [[...t, x], f] : [t, [...f, x]], [[], []])', params: ['ego', 'pred'] }],
                    ['py', { template: '[[x for x in § if (§)(x)], [x for x in § if not (§)(x)]]', params: ['ego', 'pred'] }],
                    ['rs', { template: 'faber::lista_partire(&§0, §1)', params: ['ego', 'pred'] }],
                    ['cpp', { template: 'faber::lista_partire(§0, §1)', params: ['ego', 'pred'] }],
                ]),
            }],
            ['miscita', {
                name: 'miscita',
                translations: new Map([
                    ['ts', { template: '(() => { const a = [...§]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; })()', params: ['ego'] }],
                    ['py', { template: 'random.shuffle(§)', params: ['ego'] }],
                    ['cpp', { template: 'faber::lista_miscita(§)', params: ['ego'] }],
                ]),
                radixForms: ['misc', 'perfectum'],
            }],
            ['specimen', {
                name: 'specimen',
                translations: new Map([
                    ['ts', { template: '§0[Math.floor(Math.random() * §0.length)]', params: ['ego'] }],
                    ['py', { template: 'random.choice(§)', params: ['ego'] }],
                    ['cpp', { template: 'faber::lista_specimen(§0)', params: ['ego'] }],
                ]),
            }],
            ['specimina', {
                name: 'specimina',
                translations: new Map([
                    ['ts', { template: '(() => { const a = [...§]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a.slice(0, §); })()', params: ['ego', 'n'] }],
                    ['py', { template: 'random.sample(§, §)', params: ['ego', 'n'] }],
                    ['cpp', { template: 'faber::lista_specimina(§0, §1)', params: ['ego', 'n'] }],
                ]),
            }],
        ]),
    }],
]);
