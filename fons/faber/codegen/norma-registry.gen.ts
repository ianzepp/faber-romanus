/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by: bun run build:norma
 * Source: fons/norma/*.fab
 * Generated: 2026-01-07T01:51:37.198Z
 */

import type { NormaCollection } from './norma-registry';

export const registry: Map<string, NormaCollection> = new Map([
    ['mathesis', {
        name: 'mathesis',
        innatum: new Map([
            ['ts', 'Math'],
            ['py', 'math'],
            ['rs', 'f64'],
            ['cpp', 'std::cmath'],
            ['zig', 'std.math'],
        ]),
        methods: new Map([
            ['pavimentum', {
                name: 'pavimentum',
                translations: new Map([
                    ['ts', { template: 'Math.floor(§)', params: ['x'] }],
                    ['py', { template: 'math.floor(§)', params: ['x'] }],
                    ['rs', { template: '§.floor()', params: ['x'] }],
                    ['cpp', { template: 'std::floor(§)', params: ['x'] }],
                    ['zig', { template: '@floor(§)', params: ['x'] }],
                ]),
            }],
            ['tectum', {
                name: 'tectum',
                translations: new Map([
                    ['ts', { template: 'Math.ceil(§)', params: ['x'] }],
                    ['py', { template: 'math.ceil(§)', params: ['x'] }],
                    ['rs', { template: '§.ceil()', params: ['x'] }],
                    ['cpp', { template: 'std::ceil(§)', params: ['x'] }],
                    ['zig', { template: '@ceil(§)', params: ['x'] }],
                ]),
            }],
            ['rotundum', {
                name: 'rotundum',
                translations: new Map([
                    ['ts', { template: 'Math.round(§)', params: ['x'] }],
                    ['py', { template: 'round(§)', params: ['x'] }],
                    ['rs', { template: '§.round()', params: ['x'] }],
                    ['cpp', { template: 'std::round(§)', params: ['x'] }],
                    ['zig', { template: '@round(§)', params: ['x'] }],
                ]),
            }],
            ['truncatum', {
                name: 'truncatum',
                translations: new Map([
                    ['ts', { template: 'Math.trunc(§)', params: ['x'] }],
                    ['py', { template: 'math.trunc(§)', params: ['x'] }],
                    ['rs', { template: '§.trunc()', params: ['x'] }],
                    ['cpp', { template: 'std::trunc(§)', params: ['x'] }],
                    ['zig', { template: '@trunc(§)', params: ['x'] }],
                ]),
            }],
            ['radix', {
                name: 'radix',
                translations: new Map([
                    ['ts', { template: 'Math.sqrt(§)', params: ['x'] }],
                    ['py', { template: 'math.sqrt(§)', params: ['x'] }],
                    ['rs', { template: '§.sqrt()', params: ['x'] }],
                    ['cpp', { template: 'std::sqrt(§)', params: ['x'] }],
                    ['zig', { template: '@sqrt(§)', params: ['x'] }],
                ]),
            }],
            ['potentia', {
                name: 'potentia',
                translations: new Map([
                    ['ts', { template: 'Math.pow(§, §)', params: ['base', 'exp'] }],
                    ['py', { template: 'math.pow(§, §)', params: ['base', 'exp'] }],
                    ['rs', { template: '§.powf(§)', params: ['base', 'exp'] }],
                    ['cpp', { template: 'std::pow(§, §)', params: ['base', 'exp'] }],
                    ['zig', { template: 'std.math.pow(§, §)', params: ['base', 'exp'] }],
                ]),
            }],
            ['logarithmus', {
                name: 'logarithmus',
                translations: new Map([
                    ['ts', { template: 'Math.log(§)', params: ['x'] }],
                    ['py', { template: 'math.log(§)', params: ['x'] }],
                    ['rs', { template: '§.ln()', params: ['x'] }],
                    ['cpp', { template: 'std::log(§)', params: ['x'] }],
                    ['zig', { template: '@log(§)', params: ['x'] }],
                ]),
            }],
            ['logarithmus10', {
                name: 'logarithmus10',
                translations: new Map([
                    ['ts', { template: 'Math.log10(§)', params: ['x'] }],
                    ['py', { template: 'math.log10(§)', params: ['x'] }],
                    ['rs', { template: '§.log10()', params: ['x'] }],
                    ['cpp', { template: 'std::log10(§)', params: ['x'] }],
                    ['zig', { template: 'std.math.log10(§)', params: ['x'] }],
                ]),
            }],
            ['exponens', {
                name: 'exponens',
                translations: new Map([
                    ['ts', { template: 'Math.exp(§)', params: ['x'] }],
                    ['py', { template: 'math.exp(§)', params: ['x'] }],
                    ['rs', { template: '§.exp()', params: ['x'] }],
                    ['cpp', { template: 'std::exp(§)', params: ['x'] }],
                    ['zig', { template: '@exp(§)', params: ['x'] }],
                ]),
            }],
            ['sinus', {
                name: 'sinus',
                translations: new Map([
                    ['ts', { template: 'Math.sin(§)', params: ['x'] }],
                    ['py', { template: 'math.sin(§)', params: ['x'] }],
                    ['rs', { template: '§.sin()', params: ['x'] }],
                    ['cpp', { template: 'std::sin(§)', params: ['x'] }],
                    ['zig', { template: '@sin(§)', params: ['x'] }],
                ]),
            }],
            ['cosinus', {
                name: 'cosinus',
                translations: new Map([
                    ['ts', { template: 'Math.cos(§)', params: ['x'] }],
                    ['py', { template: 'math.cos(§)', params: ['x'] }],
                    ['rs', { template: '§.cos()', params: ['x'] }],
                    ['cpp', { template: 'std::cos(§)', params: ['x'] }],
                    ['zig', { template: '@cos(§)', params: ['x'] }],
                ]),
            }],
            ['tangens', {
                name: 'tangens',
                translations: new Map([
                    ['ts', { template: 'Math.tan(§)', params: ['x'] }],
                    ['py', { template: 'math.tan(§)', params: ['x'] }],
                    ['rs', { template: '§.tan()', params: ['x'] }],
                    ['cpp', { template: 'std::tan(§)', params: ['x'] }],
                    ['zig', { template: '@tan(§)', params: ['x'] }],
                ]),
            }],
            ['absolutum', {
                name: 'absolutum',
                translations: new Map([
                    ['ts', { template: 'Math.abs(§)', params: ['x'] }],
                    ['py', { template: 'abs(§)', params: ['x'] }],
                    ['rs', { template: '§.abs()', params: ['x'] }],
                    ['cpp', { template: 'std::abs(§)', params: ['x'] }],
                    ['zig', { template: '@abs(§)', params: ['x'] }],
                ]),
            }],
            ['signum', {
                name: 'signum',
                translations: new Map([
                    ['ts', { template: 'Math.sign(§)', params: ['x'] }],
                    ['py', { template: '(1 if § > 0 else (-1 if § < 0 else 0))', params: ['x'] }],
                    ['rs', { template: '§.signum()', params: ['x'] }],
                    ['cpp', { template: '((§ > 0) - (§ < 0))', params: ['x'] }],
                    ['zig', { template: 'std.math.sign(§)', params: ['x'] }],
                ]),
            }],
            ['minimus', {
                name: 'minimus',
                translations: new Map([
                    ['ts', { template: 'Math.min(§, §)', params: ['a', 'b'] }],
                    ['py', { template: 'min(§, §)', params: ['a', 'b'] }],
                    ['rs', { template: '§.min(§)', params: ['a', 'b'] }],
                    ['cpp', { template: 'std::min(§, §)', params: ['a', 'b'] }],
                    ['zig', { template: '@min(§, §)', params: ['a', 'b'] }],
                ]),
            }],
            ['maximus', {
                name: 'maximus',
                translations: new Map([
                    ['ts', { template: 'Math.max(§, §)', params: ['a', 'b'] }],
                    ['py', { template: 'max(§, §)', params: ['a', 'b'] }],
                    ['rs', { template: '§.max(§)', params: ['a', 'b'] }],
                    ['cpp', { template: 'std::max(§, §)', params: ['a', 'b'] }],
                    ['zig', { template: '@max(§, §)', params: ['a', 'b'] }],
                ]),
            }],
            ['constringens', {
                name: 'constringens',
                translations: new Map([
                    ['ts', { template: 'Math.min(Math.max(§, §), §)', params: ['x', 'lo', 'hi'] }],
                    ['py', { template: 'max(§1, min(§0, §2))', params: ['x', 'lo', 'hi'] }],
                    ['rs', { template: '§.clamp(§, §)', params: ['x', 'lo', 'hi'] }],
                    ['cpp', { template: 'std::clamp(§, §, §)', params: ['x', 'lo', 'hi'] }],
                    ['zig', { template: 'std.math.clamp(§, §, §)', params: ['x', 'lo', 'hi'] }],
                ]),
            }],
            ['PI', {
                name: 'PI',
                translations: new Map([
                    ['ts', { template: 'Math.PI', params: [] }],
                    ['py', { template: 'math.pi', params: [] }],
                    ['rs', { template: 'std::f64::consts::PI', params: [] }],
                    ['cpp', { template: 'M_PI', params: [] }],
                    ['zig', { template: 'std.math.pi', params: [] }],
                ]),
            }],
            ['E', {
                name: 'E',
                translations: new Map([
                    ['ts', { template: 'Math.E', params: [] }],
                    ['py', { template: 'math.e', params: [] }],
                    ['rs', { template: 'std::f64::consts::E', params: [] }],
                    ['cpp', { template: 'M_E', params: [] }],
                    ['zig', { template: 'std.math.e', params: [] }],
                ]),
            }],
            ['TAU', {
                name: 'TAU',
                translations: new Map([
                    ['ts', { template: '(Math.PI * 2)', params: [] }],
                    ['py', { template: '(math.pi * 2)', params: [] }],
                    ['rs', { template: 'std::f64::consts::TAU', params: [] }],
                    ['cpp', { template: '(M_PI * 2)', params: [] }],
                    ['zig', { template: '(std.math.pi * 2)', params: [] }],
                ]),
            }],
        ]),
    }],
    ['solum', {
        name: 'solum',
        innatum: new Map([
            ['ts', 'fs'],
            ['py', 'os'],
            ['rs', 'std::fs'],
            ['cpp', 'std::filesystem'],
            ['zig', 'solum'],
        ]),
        methods: new Map([
            ['legens', {
                name: 'legens',
                translations: new Map([
                    ['ts', { template: 'fs.createReadStream(§)', params: ['path'] }],
                    ['py', { template: 'open(§, \'rb\')', params: ['path'] }],
                    ['zig', { template: 'solum.legens(§)', params: ['path'] }],
                ]),
                radixForms: ['leg', 'participium_praesens'],
            }],
            ['leget', {
                name: 'leget',
                translations: new Map([
                    ['ts', { template: 'fs.promises.readFile(§, \'utf-8\')', params: ['path'] }],
                    ['py', { template: 'aiofiles.open(§).read()', params: ['path'] }],
                    ['zig', { template: 'solum.leget(§1, §0)', params: ['path', 'alloc'] }],
                ]),
                radixForms: ['leg', 'futurum_indicativum'],
            }],
            ['lege', {
                name: 'lege',
                translations: new Map([
                    ['ts', { template: 'fs.readFileSync(§, \'utf-8\')', params: ['path'] }],
                    ['py', { template: 'open(§).read()', params: ['path'] }],
                    ['zig', { template: 'solum.lege(§1, §0)', params: ['path', 'alloc'] }],
                ]),
                radixForms: ['leg', 'imperativus'],
            }],
            ['ausculta', {
                name: 'ausculta',
                translations: new Map([
                    ['ts', { template: 'readline.createInterface({ input: process.stdin })', params: [] }],
                    ['py', { template: 'sys.stdin', params: [] }],
                    ['zig', { template: 'solum.ausculta()', params: [] }],
                ]),
            }],
            ['hauri', {
                name: 'hauri',
                translations: new Map([
                    ['ts', { template: 'fs.readFileSync(0, \'utf-8\')', params: [] }],
                    ['py', { template: 'sys.stdin.read()', params: [] }],
                    ['zig', { template: 'solum.hauri(§)', params: ['alloc'] }],
                ]),
            }],
            ['scribens', {
                name: 'scribens',
                translations: new Map([
                    ['ts', { template: 'fs.createWriteStream(§)', params: ['path'] }],
                    ['py', { template: 'open(§, \'wb\')', params: ['path'] }],
                    ['zig', { template: 'solum.scribens(§)', params: ['path'] }],
                ]),
                radixForms: ['scrib', 'participium_praesens'],
            }],
            ['scribet', {
                name: 'scribet',
                translations: new Map([
                    ['ts', { template: 'fs.promises.writeFile(§, §)', params: ['path', 'data'] }],
                    ['py', { template: 'aiofiles.open(§, \'w\').write(§)', params: ['path', 'data'] }],
                    ['zig', { template: 'solum.scribet(§, §)', params: ['path', 'data'] }],
                ]),
                radixForms: ['scrib', 'futurum_indicativum'],
            }],
            ['inscribe', {
                name: 'inscribe',
                translations: new Map([
                    ['ts', { template: 'fs.writeFileSync(§, §)', params: ['path', 'data'] }],
                    ['py', { template: 'open(§, \'w\').write(§)', params: ['path', 'data'] }],
                    ['zig', { template: 'solum.inscribe(§, §)', params: ['path', 'data'] }],
                ]),
                radixForms: ['scrib', 'imperativus'],
            }],
            ['apponet', {
                name: 'apponet',
                translations: new Map([
                    ['ts', { template: 'fs.promises.appendFile(§, §)', params: ['path', 'data'] }],
                    ['py', { template: 'aiofiles.open(§, \'a\').write(§)', params: ['path', 'data'] }],
                    ['zig', { template: 'solum.apponet(§, §)', params: ['path', 'data'] }],
                ]),
                radixForms: ['appon', 'futurum_indicativum'],
            }],
            ['appone', {
                name: 'appone',
                translations: new Map([
                    ['ts', { template: 'fs.appendFileSync(§, §)', params: ['path', 'data'] }],
                    ['py', { template: 'open(§, \'a\').write(§)', params: ['path', 'data'] }],
                    ['zig', { template: 'solum.appone(§, §)', params: ['path', 'data'] }],
                ]),
                radixForms: ['appon', 'imperativus'],
            }],
            ['exstat', {
                name: 'exstat',
                translations: new Map([
                    ['ts', { template: 'fs.existsSync(§)', params: ['path'] }],
                    ['py', { template: 'os.path.exists(§)', params: ['path'] }],
                    ['zig', { template: 'solum.exstat(§)', params: ['path'] }],
                ]),
            }],
            ['inspice', {
                name: 'inspice',
                translations: new Map([
                    ['ts', { template: 'fs.promises.stat(§)', params: ['path'] }],
                    ['py', { template: 'os.stat(§)', params: ['path'] }],
                    ['zig', { template: 'solum.inspice(§)', params: ['path'] }],
                ]),
            }],
            ['dele', {
                name: 'dele',
                translations: new Map([
                    ['ts', { template: 'fs.promises.unlink(§)', params: ['path'] }],
                    ['py', { template: 'os.remove(§)', params: ['path'] }],
                    ['zig', { template: 'solum.dele(§)', params: ['path'] }],
                ]),
                radixForms: ['del', 'futurum_indicativum', 'imperativus'],
            }],
            ['duplica', {
                name: 'duplica',
                translations: new Map([
                    ['ts', { template: 'fs.promises.copyFile(§, §)', params: ['src', 'dest'] }],
                    ['py', { template: 'shutil.copy2(§, §)', params: ['src', 'dest'] }],
                    ['zig', { template: 'solum.duplica(§, §)', params: ['src', 'dest'] }],
                ]),
                radixForms: ['duplic', 'futurum_indicativum', 'imperativus'],
            }],
            ['move', {
                name: 'move',
                translations: new Map([
                    ['ts', { template: 'fs.promises.rename(§, §)', params: ['src', 'dest'] }],
                    ['py', { template: 'shutil.move(§, §)', params: ['src', 'dest'] }],
                    ['zig', { template: 'solum.move(§, §)', params: ['src', 'dest'] }],
                ]),
                radixForms: ['mov', 'futurum_indicativum', 'imperativus'],
            }],
            ['trunca', {
                name: 'trunca',
                translations: new Map([
                    ['ts', { template: 'fs.promises.truncate(§, §)', params: ['path', 'size'] }],
                    ['py', { template: 'os.truncate(§, §)', params: ['path', 'size'] }],
                    ['zig', { template: 'solum.trunca(§, §)', params: ['path', 'size'] }],
                ]),
            }],
            ['tange', {
                name: 'tange',
                translations: new Map([
                    ['ts', { template: 'fs.promises.utimes(§, Date.now(), Date.now())', params: ['path'] }],
                    ['py', { template: 'pathlib.Path(§).touch()', params: ['path'] }],
                    ['zig', { template: 'solum.tange(§)', params: ['path'] }],
                ]),
            }],
            ['crea', {
                name: 'crea',
                translations: new Map([
                    ['ts', { template: 'fs.promises.mkdir(§, { recursive: true })', params: ['path'] }],
                    ['py', { template: 'os.makedirs(§, exist_ok=True)', params: ['path'] }],
                    ['zig', { template: 'solum.crea(§)', params: ['path'] }],
                ]),
                radixForms: ['cre', 'futurum_indicativum', 'imperativus'],
            }],
            ['elenca', {
                name: 'elenca',
                translations: new Map([
                    ['ts', { template: 'fs.promises.readdir(§)', params: ['path'] }],
                    ['py', { template: 'os.listdir(§)', params: ['path'] }],
                    ['zig', { template: 'solum.elenca(§1, §0)', params: ['path', 'alloc'] }],
                ]),
                radixForms: ['elenc', 'participium_praesens', 'futurum_indicativum', 'imperativus'],
            }],
            ['ambula', {
                name: 'ambula',
                translations: new Map([
                    ['ts', { template: 'glob.stream(§ + \'/**/*\')', params: ['path'] }],
                    ['py', { template: 'os.walk(§)', params: ['path'] }],
                    ['zig', { template: 'solum.ambula(§)', params: ['path'] }],
                ]),
                radixForms: ['ambul', 'participium_praesens'],
            }],
            ['vacua', {
                name: 'vacua',
                translations: new Map([
                    ['ts', { template: 'fs.promises.rmdir(§)', params: ['path'] }],
                    ['py', { template: 'os.rmdir(§)', params: ['path'] }],
                    ['zig', { template: 'solum.vacua(§)', params: ['path'] }],
                ]),
                radixForms: ['vacu', 'futurum_indicativum', 'imperativus'],
            }],
            ['deleArborem', {
                name: 'deleArborem',
                translations: new Map([
                    ['ts', { template: 'fs.promises.rm(§, { recursive: true })', params: ['path'] }],
                    ['py', { template: 'shutil.rmtree(§)', params: ['path'] }],
                    ['zig', { template: 'solum.deleArborem(§)', params: ['path'] }],
                ]),
            }],
            ['iunge', {
                name: 'iunge',
                translations: new Map([
                    ['ts', { template: 'path.join(...§)', params: ['parts'] }],
                    ['py', { template: 'os.path.join(*§)', params: ['parts'] }],
                    ['zig', { template: 'solum.iunge(§)', params: ['parts'] }],
                ]),
            }],
            ['dir', {
                name: 'dir',
                translations: new Map([
                    ['ts', { template: 'path.dirname(§)', params: ['path'] }],
                    ['py', { template: 'os.path.dirname(§)', params: ['path'] }],
                    ['zig', { template: 'solum.dir(§)', params: ['path'] }],
                ]),
            }],
            ['basis', {
                name: 'basis',
                translations: new Map([
                    ['ts', { template: 'path.basename(§)', params: ['path'] }],
                    ['py', { template: 'os.path.basename(§)', params: ['path'] }],
                    ['zig', { template: 'solum.basis(§)', params: ['path'] }],
                ]),
            }],
            ['extensio', {
                name: 'extensio',
                translations: new Map([
                    ['ts', { template: 'path.extname(§)', params: ['path'] }],
                    ['py', { template: 'os.path.splitext(§)[1]', params: ['path'] }],
                    ['zig', { template: 'solum.extensio(§)', params: ['path'] }],
                ]),
            }],
            ['resolve', {
                name: 'resolve',
                translations: new Map([
                    ['ts', { template: 'path.resolve(§)', params: ['path'] }],
                    ['py', { template: 'os.path.abspath(§)', params: ['path'] }],
                    ['zig', { template: 'solum.resolve(§1, §0)', params: ['path', 'alloc'] }],
                ]),
            }],
            ['domus', {
                name: 'domus',
                translations: new Map([
                    ['ts', { template: 'os.homedir()', params: [] }],
                    ['py', { template: 'os.path.expanduser(\'~\')', params: [] }],
                    ['zig', { template: 'solum.domus()', params: [] }],
                ]),
            }],
        ]),
    }],
    ['lista', {
        name: 'lista',
        innatum: new Map([
            ['ts', 'Array'],
            ['py', 'list'],
            ['rs', 'Vec'],
            ['cpp', 'std::vector'],
            ['zig', 'Lista'],
        ]),
        methods: new Map([
            ['adde', {
                name: 'adde',
                translations: new Map([
                    ['ts', { method: 'push' }],
                    ['py', { method: 'append' }],
                    ['rs', { method: 'push' }],
                    ['cpp', { method: 'push_back' }],
                    ['zig', { template: '§0.adde(§2, §1)', params: ['ego', 'elem', 'alloc'] }],
                ]),
                radixForms: ['add', 'imperativus', 'perfectum'],
            }],
            ['addita', {
                name: 'addita',
                translations: new Map([
                    ['ts', { template: '[...§, §]', params: ['ego', 'elem'] }],
                    ['py', { template: '[*§, §]', params: ['ego', 'elem'] }],
                    ['rs', { template: '{ let mut v = §.clone(); v.push(§); v }', params: ['ego', 'elem'] }],
                    ['cpp', { template: '[&]{ auto v = §; v.push_back(§); return v; }()', params: ['ego', 'elem'] }],
                    ['zig', { template: '§0.addita(§2, §1)', params: ['ego', 'elem', 'alloc'] }],
                ]),
            }],
            ['praepone', {
                name: 'praepone',
                translations: new Map([
                    ['ts', { method: 'unshift' }],
                    ['py', { template: '§.insert(0, §)', params: ['ego', 'elem'] }],
                    ['rs', { template: '§.insert(0, §)', params: ['ego', 'elem'] }],
                    ['cpp', { template: '§.insert(§.begin(), §)', params: ['ego', 'elem'] }],
                    ['zig', { template: '§0.praepone(§2, §1)', params: ['ego', 'elem', 'alloc'] }],
                ]),
                radixForms: ['praepon', 'imperativus', 'perfectum'],
            }],
            ['praeposita', {
                name: 'praeposita',
                translations: new Map([
                    ['ts', { template: '[§1, ...§0]', params: ['ego', 'elem'] }],
                    ['py', { template: '[§1, *§0]', params: ['ego', 'elem'] }],
                    ['rs', { template: '{ let mut v = vec![§1]; v.extend(§0.iter().cloned()); v }', params: ['ego', 'elem'] }],
                    ['cpp', { template: '[&]{ auto v = §0; v.insert(v.begin(), §1); return v; }()', params: ['ego', 'elem'] }],
                    ['zig', { template: '§0.praeposita(§2, §1)', params: ['ego', 'elem', 'alloc'] }],
                ]),
            }],
            ['remove', {
                name: 'remove',
                translations: new Map([
                    ['ts', { method: 'pop' }],
                    ['py', { method: 'pop' }],
                    ['rs', { template: '§.pop()', params: ['ego'] }],
                    ['cpp', { template: '[&]{ auto v = §.back(); §.pop_back(); return v; }()', params: ['ego'] }],
                    ['zig', { template: '§.remove()', params: ['ego'] }],
                ]),
                radixForms: ['remov', 'imperativus', 'perfectum'],
            }],
            ['remota', {
                name: 'remota',
                translations: new Map([
                    ['ts', { template: '§.slice(0, -1)', params: ['ego'] }],
                    ['py', { template: '§[:-1]', params: ['ego'] }],
                    ['rs', { template: '§[..§.len().saturating_sub(1)].to_vec()', params: ['ego'] }],
                    ['cpp', { template: 'std::vector(§.begin(), §.end() - 1)', params: ['ego'] }],
                    ['zig', { template: '§.remota(§)', params: ['ego', 'alloc'] }],
                ]),
            }],
            ['decapita', {
                name: 'decapita',
                translations: new Map([
                    ['ts', { method: 'shift' }],
                    ['py', { template: '§.pop(0)', params: ['ego'] }],
                    ['rs', { template: '§.remove(0)', params: ['ego'] }],
                    ['cpp', { template: '[&]{ auto v = §.front(); §.erase(§.begin()); return v; }()', params: ['ego'] }],
                    ['zig', { template: '§.decapita()', params: ['ego'] }],
                ]),
                radixForms: ['decapit', 'imperativus', 'perfectum'],
            }],
            ['decapitata', {
                name: 'decapitata',
                translations: new Map([
                    ['ts', { template: '§.slice(1)', params: ['ego'] }],
                    ['py', { template: '§[1:]', params: ['ego'] }],
                    ['rs', { template: '§[1..].to_vec()', params: ['ego'] }],
                    ['cpp', { template: 'std::vector(§.begin() + 1, §.end())', params: ['ego'] }],
                    ['zig', { template: '§.decapitata(§)', params: ['ego', 'alloc'] }],
                ]),
            }],
            ['purga', {
                name: 'purga',
                translations: new Map([
                    ['ts', { template: '§.length = 0', params: ['ego'] }],
                    ['py', { method: 'clear' }],
                    ['rs', { method: 'clear' }],
                    ['cpp', { method: 'clear' }],
                    ['zig', { template: '§.purga()', params: ['ego'] }],
                ]),
            }],
            ['primus', {
                name: 'primus',
                translations: new Map([
                    ['ts', { template: '§[0]', params: ['ego'] }],
                    ['py', { template: '§[0]', params: ['ego'] }],
                    ['rs', { template: '§.first()', params: ['ego'] }],
                    ['cpp', { template: '§.front()', params: ['ego'] }],
                    ['zig', { template: '§.primus()', params: ['ego'] }],
                ]),
            }],
            ['ultimus', {
                name: 'ultimus',
                translations: new Map([
                    ['ts', { template: '§.at(-1)', params: ['ego'] }],
                    ['py', { template: '§[-1]', params: ['ego'] }],
                    ['rs', { template: '§.last()', params: ['ego'] }],
                    ['cpp', { template: '§.back()', params: ['ego'] }],
                    ['zig', { template: '§.ultimus()', params: ['ego'] }],
                ]),
            }],
            ['accipe', {
                name: 'accipe',
                translations: new Map([
                    ['ts', { template: '§[§]', params: ['ego', 'idx'] }],
                    ['py', { template: '§[§]', params: ['ego', 'idx'] }],
                    ['rs', { template: '§.get(§)', params: ['ego', 'idx'] }],
                    ['cpp', { template: '§.at(§)', params: ['ego', 'idx'] }],
                    ['zig', { template: '§.accipe(§)', params: ['ego', 'idx'] }],
                ]),
            }],
            ['longitudo', {
                name: 'longitudo',
                translations: new Map([
                    ['ts', { template: '§.length', params: ['ego'] }],
                    ['py', { template: 'len(§)', params: ['ego'] }],
                    ['rs', { template: '§.len()', params: ['ego'] }],
                    ['cpp', { template: '§.size()', params: ['ego'] }],
                    ['zig', { template: '§.longitudo()', params: ['ego'] }],
                ]),
            }],
            ['vacua', {
                name: 'vacua',
                translations: new Map([
                    ['ts', { template: '§.length === 0', params: ['ego'] }],
                    ['py', { template: 'len(§) == 0', params: ['ego'] }],
                    ['rs', { template: '§.is_empty()', params: ['ego'] }],
                    ['cpp', { template: '§.empty()', params: ['ego'] }],
                    ['zig', { template: '§.vacua()', params: ['ego'] }],
                ]),
            }],
            ['continet', {
                name: 'continet',
                translations: new Map([
                    ['ts', { method: 'includes' }],
                    ['py', { template: '(§1 in §0)', params: ['ego', 'elem'] }],
                    ['rs', { template: '§0.contains(&§1)', params: ['ego', 'elem'] }],
                    ['cpp', { template: '(std::find(§0.begin(), §0.end(), §1) != §0.end())', params: ['ego', 'elem'] }],
                    ['zig', { template: '§.continet(§)', params: ['ego', 'elem'] }],
                ]),
            }],
            ['indiceDe', {
                name: 'indiceDe',
                translations: new Map([
                    ['ts', { method: 'indexOf' }],
                    ['py', { template: '§0.index(§1)', params: ['ego', 'elem'] }],
                    ['rs', { template: '§0.iter().position(|e| e == &§1)', params: ['ego', 'elem'] }],
                    ['cpp', { template: '[&]{ auto it = std::find(§0.begin(), §0.end(), §1); return it != §0.end() ? std::distance(§0.begin(), it) : -1; }()', params: ['ego', 'elem'] }],
                    ['zig', { template: '§.indiceDe(§)', params: ['ego', 'elem'] }],
                ]),
            }],
            ['inveni', {
                name: 'inveni',
                translations: new Map([
                    ['ts', { method: 'find' }],
                    ['py', { template: 'next(filter(§1, §0), None)', params: ['ego', 'pred'] }],
                    ['rs', { template: '§0.iter().find(§1)', params: ['ego', 'pred'] }],
                    ['cpp', { template: '*std::find_if(§0.begin(), §0.end(), §1)', params: ['ego', 'pred'] }],
                    ['zig', { template: '§.inveni(§)', params: ['ego', 'pred'] }],
                ]),
            }],
            ['inveniIndicem', {
                name: 'inveniIndicem',
                translations: new Map([
                    ['ts', { method: 'findIndex' }],
                    ['py', { template: 'next((i for i, x in enumerate(§0) if (§1)(x)), -1)', params: ['ego', 'pred'] }],
                    ['rs', { template: '§0.iter().position(§1)', params: ['ego', 'pred'] }],
                    ['cpp', { template: '[&]{ auto it = std::find_if(§0.begin(), §0.end(), §1); return it != §0.end() ? std::distance(§0.begin(), it) : -1; }()', params: ['ego', 'pred'] }],
                    ['zig', { template: '§.inveniIndicem(§)', params: ['ego', 'pred'] }],
                ]),
            }],
            ['omnes', {
                name: 'omnes',
                translations: new Map([
                    ['ts', { method: 'every' }],
                    ['py', { template: 'all(map(§, §))', params: ['ego', 'pred'] }],
                    ['rs', { template: '§.iter().all(§)', params: ['ego', 'pred'] }],
                    ['cpp', { template: 'std::ranges::all_of(§, §)', params: ['ego', 'pred'] }],
                    ['zig', { template: '§.omnes(§)', params: ['ego', 'pred'] }],
                ]),
            }],
            ['aliquis', {
                name: 'aliquis',
                translations: new Map([
                    ['ts', { method: 'some' }],
                    ['py', { template: 'any(map(§, §))', params: ['ego', 'pred'] }],
                    ['rs', { template: '§.iter().any(§)', params: ['ego', 'pred'] }],
                    ['cpp', { template: 'std::ranges::any_of(§, §)', params: ['ego', 'pred'] }],
                    ['zig', { template: '§.aliquis(§)', params: ['ego', 'pred'] }],
                ]),
            }],
            ['filtrata', {
                name: 'filtrata',
                translations: new Map([
                    ['ts', { method: 'filter' }],
                    ['py', { template: 'list(filter(§, §))', params: ['ego', 'pred'] }],
                    ['rs', { template: '§.iter().filter(§).cloned().collect::<Vec<_>>()', params: ['ego', 'pred'] }],
                    ['cpp', { template: '(§ | std::views::filter(§) | std::ranges::to<std::vector>())', params: ['ego', 'pred'] }],
                    ['zig', { template: '§0.filtrata(§2, §1)', params: ['ego', 'pred', 'alloc'] }],
                ]),
                radixForms: ['filtr', 'imperativus', 'perfectum'],
            }],
            ['mappata', {
                name: 'mappata',
                translations: new Map([
                    ['ts', { method: 'map' }],
                    ['py', { template: 'list(map(§, §))', params: ['ego', 'fn'] }],
                    ['rs', { template: '§.iter().map(§).collect::<Vec<_>>()', params: ['ego', 'fn'] }],
                    ['cpp', { template: '(§ | std::views::transform(§) | std::ranges::to<std::vector>())', params: ['ego', 'fn'] }],
                    ['zig', { template: '§0.mappata(§2, §1)', params: ['ego', 'fn', 'alloc'] }],
                ]),
            }],
            ['explanata', {
                name: 'explanata',
                translations: new Map([
                    ['ts', { method: 'flatMap' }],
                    ['py', { template: '[y for x in § for y in (§)(x)]', params: ['ego', 'fn'] }],
                    ['rs', { template: '§.iter().flat_map(§).collect::<Vec<_>>()', params: ['ego', 'fn'] }],
                    ['cpp', { template: '(§ | std::views::transform(§) | std::views::join | std::ranges::to<std::vector>())', params: ['ego', 'fn'] }],
                ]),
            }],
            ['plana', {
                name: 'plana',
                translations: new Map([
                    ['ts', { method: 'flat' }],
                    ['py', { template: '[y for x in § for y in x]', params: ['ego'] }],
                    ['rs', { template: '§.iter().flatten().cloned().collect::<Vec<_>>()', params: ['ego'] }],
                    ['cpp', { template: '(§ | std::views::join | std::ranges::to<std::vector>())', params: ['ego'] }],
                ]),
            }],
            ['inversa', {
                name: 'inversa',
                translations: new Map([
                    ['ts', { template: '[...§].reverse()', params: ['ego'] }],
                    ['py', { template: '§[::-1]', params: ['ego'] }],
                    ['rs', { template: '§.iter().rev().cloned().collect::<Vec<_>>()', params: ['ego'] }],
                    ['cpp', { template: '(§ | std::views::reverse | std::ranges::to<std::vector>())', params: ['ego'] }],
                    ['zig', { template: '§.inversa(§)', params: ['ego', 'alloc'] }],
                ]),
                radixForms: ['invert', 'imperativus', 'perfectum'],
            }],
            ['ordinata', {
                name: 'ordinata',
                translations: new Map([
                    ['ts', { template: '[...§].sort()', params: ['ego'] }],
                    ['py', { template: 'sorted(§)', params: ['ego'] }],
                    ['rs', { template: '{ let mut v = §.clone(); v.sort(); v }', params: ['ego'] }],
                    ['cpp', { template: '[&]{ auto v = §; std::ranges::sort(v); return v; }()', params: ['ego'] }],
                    ['zig', { template: '§.ordinata(§)', params: ['ego', 'alloc'] }],
                ]),
                radixForms: ['ordin', 'imperativus', 'perfectum'],
            }],
            ['sectio', {
                name: 'sectio',
                translations: new Map([
                    ['ts', { method: 'slice' }],
                    ['py', { template: '§[§:§]', params: ['ego', 'start', 'end'] }],
                    ['rs', { template: '§[§..§].to_vec()', params: ['ego', 'start', 'end'] }],
                    ['cpp', { template: 'std::vector(§.begin() + §, §.begin() + §)', params: ['ego', 'start', 'end'] }],
                    ['zig', { template: '§.sectio(§, §, §)', params: ['ego', 'start', 'end', 'alloc'] }],
                ]),
            }],
            ['reducta', {
                name: 'reducta',
                translations: new Map([
                    ['ts', { method: 'reduce' }],
                    ['py', { template: 'functools.reduce(§, §, §)', params: ['ego', 'fn', 'init'] }],
                    ['rs', { template: '§.iter().fold(§, §)', params: ['ego', 'fn', 'init'] }],
                    ['cpp', { template: 'std::ranges::fold_left(§, §, §)', params: ['ego', 'fn', 'init'] }],
                    ['zig', { template: '§.reducta(§, §)', params: ['ego', 'fn', 'init'] }],
                ]),
            }],
            ['filtra', {
                name: 'filtra',
                translations: new Map([
                    ['ts', { template: '(() => { for (let i = §.length - 1; i >= 0; i--) { if (!(§)(§[i])) §.splice(i, 1); } })()', params: ['ego', 'pred'] }],
                    ['py', { template: '§[:] = [x for x in § if (§)(x)]', params: ['ego', 'pred'] }],
                    ['cpp', { template: '§.erase(std::remove_if(§.begin(), §.end(), [&](auto& x) { return !(§)(x); }), §.end())', params: ['ego', 'pred'] }],
                ]),
            }],
            ['inverte', {
                name: 'inverte',
                translations: new Map([
                    ['ts', { method: 'reverse' }],
                    ['py', { template: '§.reverse()', params: ['ego'] }],
                    ['rs', { template: '§.reverse()', params: ['ego'] }],
                    ['cpp', { template: 'std::ranges::reverse(§)', params: ['ego'] }],
                    ['zig', { template: '§.inverte()', params: ['ego'] }],
                ]),
            }],
            ['perambula', {
                name: 'perambula',
                translations: new Map([
                    ['ts', { method: 'forEach' }],
                    ['py', { template: '[(§)(x) for x in §]', params: ['ego', 'fn'] }],
                    ['rs', { template: '§.iter().for_each(§)', params: ['ego', 'fn'] }],
                    ['cpp', { template: 'std::ranges::for_each(§, §)', params: ['ego', 'fn'] }],
                    ['zig', { template: '§.perambula(§)', params: ['ego', 'fn'] }],
                ]),
            }],
            ['coniunge', {
                name: 'coniunge',
                translations: new Map([
                    ['ts', { method: 'join' }],
                    ['py', { template: '§.join(§)', params: ['ego', 'sep'] }],
                    ['rs', { template: '§.join(§)', params: ['ego', 'sep'] }],
                    ['cpp', { template: '[&]{ std::string r; for (size_t i = 0; i < §.size(); ++i) { if (i > 0) r += §; r += §[i]; } return r; }()', params: ['ego', 'sep'] }],
                ]),
            }],
            ['medium', {
                name: 'medium',
                translations: new Map([
                    ['ts', { template: '(§.reduce((a, b) => a + b, 0) / §.length)', params: ['ego'] }],
                    ['py', { template: '(sum(§) / len(§))', params: ['ego'] }],
                    ['rs', { template: '(§.iter().sum::<i64>() as f64 / §.len() as f64)', params: ['ego'] }],
                    ['cpp', { template: '(std::accumulate(§.begin(), §.end(), 0.0) / §.size())', params: ['ego'] }],
                    ['zig', { template: '§.medium()', params: ['ego'] }],
                ]),
            }],
            ['minimus', {
                name: 'minimus',
                translations: new Map([
                    ['ts', { template: 'Math.min(...§)', params: ['ego'] }],
                    ['py', { template: 'min(§)', params: ['ego'] }],
                    ['rs', { template: '§.iter().min()', params: ['ego'] }],
                    ['cpp', { template: '*std::ranges::min_element(§)', params: ['ego'] }],
                    ['zig', { template: '§.minimus()', params: ['ego'] }],
                ]),
            }],
            ['maximus', {
                name: 'maximus',
                translations: new Map([
                    ['ts', { template: 'Math.max(...§)', params: ['ego'] }],
                    ['py', { template: 'max(§)', params: ['ego'] }],
                    ['rs', { template: '§.iter().max()', params: ['ego'] }],
                    ['cpp', { template: '*std::ranges::max_element(§)', params: ['ego'] }],
                    ['zig', { template: '§.maximus()', params: ['ego'] }],
                ]),
            }],
            ['minimusPer', {
                name: 'minimusPer',
                translations: new Map([
                    ['ts', { template: '§.reduce((min, x) => (§)(x) < (§)(min) ? x : min)', params: ['ego', 'fn'] }],
                    ['rs', { template: '§.iter().min_by_key(§)', params: ['ego', 'fn'] }],
                    ['cpp', { template: '*std::ranges::min_element(§, [&](auto& a, auto& b) { return (§)(a) < (§)(b); })', params: ['ego', 'fn'] }],
                ]),
            }],
            ['maximusPer', {
                name: 'maximusPer',
                translations: new Map([
                    ['ts', { template: '§.reduce((max, x) => (§)(x) > (§)(max) ? x : max)', params: ['ego', 'fn'] }],
                    ['rs', { template: '§.iter().max_by_key(§)', params: ['ego', 'fn'] }],
                    ['cpp', { template: '*std::ranges::max_element(§, [&](auto& a, auto& b) { return (§)(a) < (§)(b); })', params: ['ego', 'fn'] }],
                ]),
            }],
            ['numera', {
                name: 'numera',
                translations: new Map([
                    ['ts', { template: '§.filter(§).length', params: ['ego', 'pred'] }],
                    ['py', { template: 'sum(1 for x in § if (§)(x))', params: ['ego', 'pred'] }],
                    ['rs', { template: '§.iter().filter(§).count()', params: ['ego', 'pred'] }],
                    ['cpp', { template: 'std::ranges::count_if(§, §)', params: ['ego', 'pred'] }],
                    ['zig', { template: '§.numera(§)', params: ['ego', 'pred'] }],
                ]),
            }],
            ['congrega', {
                name: 'congrega',
                translations: new Map([
                    ['ts', { template: 'Object.groupBy(§, §)', params: ['ego', 'fn'] }],
                    ['py', { template: '{k: list(g) for k, g in itertools.groupby(sorted(§, key=§), key=§)}', params: ['ego', 'fn'] }],
                    ['cpp', { template: '[&]{ std::unordered_map<decltype((§)(§[0])), std::vector<decltype(§[0])>> m; for (auto& x : §) m[(§)(x)].push_back(x); return m; }()', params: ['ego', 'fn'] }],
                ]),
            }],
            ['unica', {
                name: 'unica',
                translations: new Map([
                    ['ts', { template: '[...new Set(§)]', params: ['ego'] }],
                    ['py', { template: 'list(dict.fromkeys(§))', params: ['ego'] }],
                    ['rs', { template: '{ let mut seen = std::collections::HashSet::new(); §.iter().filter(|x| seen.insert((*x).clone())).cloned().collect::<Vec<_>>() }', params: ['ego'] }],
                    ['cpp', { template: '[&]{ std::unordered_set<decltype(§[0])> s(§.begin(), §.end()); return std::vector(s.begin(), s.end()); }()', params: ['ego'] }],
                ]),
            }],
            ['planaOmnia', {
                name: 'planaOmnia',
                translations: new Map([
                    ['ts', { template: '§.flat(Infinity)', params: ['ego'] }],
                    ['cpp', { template: '(§ | std::views::join | std::ranges::to<std::vector>())', params: ['ego'] }],
                ]),
            }],
            ['fragmenta', {
                name: 'fragmenta',
                translations: new Map([
                    ['ts', { template: 'Array.from({ length: Math.ceil(§.length / §) }, (_, i) => §.slice(i * §, i * § + §))', params: ['ego', 'n'] }],
                    ['py', { template: '[§[i:i+§] for i in range(0, len(§), §)]', params: ['ego', 'n'] }],
                    ['rs', { template: '§.chunks(§).map(|c| c.to_vec()).collect::<Vec<_>>()', params: ['ego', 'n'] }],
                    ['cpp', { template: '(§ | std::views::chunk(§) | std::ranges::to<std::vector>())', params: ['ego', 'n'] }],
                ]),
            }],
            ['densa', {
                name: 'densa',
                translations: new Map([
                    ['ts', { template: '§.filter(Boolean)', params: ['ego'] }],
                    ['py', { template: '[x for x in § if x]', params: ['ego'] }],
                    ['cpp', { template: '(§ | std::views::filter([](auto& x) { return static_cast<bool>(x); }) | std::ranges::to<std::vector>())', params: ['ego'] }],
                ]),
            }],
            ['partire', {
                name: 'partire',
                translations: new Map([
                    ['ts', { template: '§.reduce(([t, f], x) => (§)(x) ? [[...t, x], f] : [t, [...f, x]], [[], []])', params: ['ego', 'pred'] }],
                    ['py', { template: '[[x for x in § if (§)(x)], [x for x in § if not (§)(x)]]', params: ['ego', 'pred'] }],
                    ['rs', { template: '§.iter().cloned().partition::<Vec<_>, _>(§)', params: ['ego', 'pred'] }],
                    ['cpp', { template: '[&]{ std::vector<decltype(§[0])> t, f; for (auto& x : §) ((§)(x) ? t : f).push_back(x); return std::make_pair(t, f); }()', params: ['ego', 'pred'] }],
                ]),
            }],
            ['misce', {
                name: 'misce',
                translations: new Map([
                    ['ts', { template: '(() => { const a = [...§]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; })()', params: ['ego'] }],
                    ['py', { template: 'random.shuffle(§)', params: ['ego'] }],
                    ['cpp', { template: '[&]{ auto v = §; std::random_device rd; std::mt19937 g(rd()); std::ranges::shuffle(v, g); return v; }()', params: ['ego'] }],
                ]),
            }],
            ['specimen', {
                name: 'specimen',
                translations: new Map([
                    ['ts', { template: '§[Math.floor(Math.random() * §.length)]', params: ['ego'] }],
                    ['py', { template: 'random.choice(§)', params: ['ego'] }],
                    ['cpp', { template: '§[std::random_device{}() % §.size()]', params: ['ego'] }],
                ]),
            }],
            ['specimina', {
                name: 'specimina',
                translations: new Map([
                    ['ts', { template: '(() => { const a = [...§]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a.slice(0, §); })()', params: ['ego', 'n'] }],
                    ['py', { template: 'random.sample(§, §)', params: ['ego', 'n'] }],
                    ['cpp', { template: '[&]{ auto v = §; std::random_device rd; std::mt19937 g(rd()); std::ranges::shuffle(v, g); v.resize(std::min(§, v.size())); return v; }()', params: ['ego', 'n'] }],
                ]),
            }],
        ]),
    }],
]);
