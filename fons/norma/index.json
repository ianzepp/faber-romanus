{
  "aleator:fractus:cpp": { "template": "[&]{ std::random_device rd; std::mt19937 gen(rd()); std::uniform_real_distribution<> dis(0.0, 1.0); return dis(gen); }()" },
  "aleator:fractus:py": { "template": "random.random()" },
  "aleator:fractus:rs": { "template": "rand::random::<f64>()" },
  "aleator:fractus:ts": { "template": "Math.random()" },
  "aleator:fractus:zig": { "template": "blk: { var seed: u64 = undefined; std.crypto.random.bytes(std.mem.asBytes(&seed)); var prng = std.rand.DefaultPrng.init(seed); break :blk prng.random().float(f64); }" },
  "aleator:inter:cpp": { "template": "[&]{ std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution<> dis(§0, §1); return dis(gen); }()", "params": ["min","max"] },
  "aleator:inter:py": { "template": "random.randint(§0, §1)", "params": ["min","max"] },
  "aleator:inter:rs": { "template": "rand::thread_rng().gen_range(§0..=§1)", "params": ["min","max"] },
  "aleator:inter:ts": { "template": "Math.floor(Math.random() * (§1 - §0 + 1)) + §0", "params": ["min","max"] },
  "aleator:inter:zig": { "template": "blk: { var seed: u64 = undefined; std.crypto.random.bytes(std.mem.asBytes(&seed)); var prng = std.rand.DefaultPrng.init(seed); break :blk prng.random().intRangeAtMost(i64, §0, §1); }", "params": ["min","max"] },
  "aleator:miscita:cpp": { "template": "[&]{ auto v = §0; std::random_device rd; std::mt19937 gen(rd()); std::ranges::shuffle(v, gen); return v; }()", "params": ["lista"] },
  "aleator:miscita:py": { "template": "random.sample(§0, len(§0))", "params": ["lista"] },
  "aleator:miscita:rs": { "template": "{ let mut v = §0.clone(); v.shuffle(&mut rand::thread_rng()); v }", "params": ["lista"] },
  "aleator:miscita:ts": { "template": "(() => { const a = [...§0]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; })()", "params": ["lista"] },
  "aleator:miscita:zig": { "template": "blk: { var seed: u64 = undefined; std.crypto.random.bytes(std.mem.asBytes(&seed)); var prng = std.rand.DefaultPrng.init(seed); var copy = §1.dupe(@TypeOf(§0[0]), §0) catch unreachable; prng.random().shuffle(@TypeOf(copy[0]), copy); break :blk copy; }", "params": ["lista","alloc"] },
  "aleator:octeti:cpp": { "template": "[&]{ std::vector<uint8_t> bytes(§); std::random_device rd; for (auto& b : bytes) b = static_cast<uint8_t>(rd()); return bytes; }()", "params": ["n"] },
  "aleator:octeti:py": { "template": "secrets.token_bytes(§)", "params": ["n"] },
  "aleator:octeti:rs": { "template": "{ let mut bytes = vec![0u8; §]; rand::thread_rng().fill(&mut bytes[..]); bytes }", "params": ["n"] },
  "aleator:octeti:ts": { "template": "crypto.getRandomValues(new Uint8Array(§))", "params": ["n"] },
  "aleator:octeti:zig": { "template": "blk: { var buf = §1.alloc(u8, §0) catch unreachable; std.crypto.random.bytes(buf); break :blk buf; }", "params": ["n","alloc"] },
  "aleator:selige:cpp": { "template": "[&]{ std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution<size_t> dis(0, §0.size() - 1); return §0[dis(gen)]; }()", "params": ["lista"] },
  "aleator:selige:py": { "template": "random.choice(§0)", "params": ["lista"] },
  "aleator:selige:rs": { "template": "§0.choose(&mut rand::thread_rng()).unwrap().clone()", "params": ["lista"] },
  "aleator:selige:ts": { "template": "§0[Math.floor(Math.random() * §0.length)]", "params": ["lista"] },
  "aleator:selige:zig": { "template": "blk: { var seed: u64 = undefined; std.crypto.random.bytes(std.mem.asBytes(&seed)); var prng = std.rand.DefaultPrng.init(seed); break :blk §0[prng.random().uintLessThan(usize, §0.len)]; }", "params": ["lista"] },
  "aleator:semen:cpp": { "template": "/* seed(§) - C++ requires explicit generator management */", "params": ["n"] },
  "aleator:semen:py": { "template": "random.seed(§)", "params": ["n"] },
  "aleator:semen:rs": { "template": "/* seed(§) - use rand::SeedableRng for reproducible results */", "params": ["n"] },
  "aleator:semen:ts": { "template": "undefined /* JS Math.random is not seedable */", "params": ["n"] },
  "aleator:semen:zig": { "template": "@compileLog(\\\"seed(§) - Zig requires explicit PRNG state management\\\")", "params": ["n"] },
  "aleator:uuid:cpp": { "template": "[&]{ std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution<> dis(0, 15); auto hex = [](int n) { return \\\"0123456789abcdef\\\"[n]; }; std::string uuid; for (int i = 0; i < 36; ++i) { if (i == 8 || i == 13 || i == 18 || i == 23) uuid += '-'; else if (i == 14) uuid += '4'; else if (i == 19) uuid += hex((dis(gen) & 0x3) | 0x8); else uuid += hex(dis(gen)); } return uuid; }()" },
  "aleator:uuid:py": { "template": "str(uuid.uuid4())" },
  "aleator:uuid:rs": { "template": "uuid::Uuid::new_v4().to_string()" },
  "aleator:uuid:ts": { "template": "crypto.randomUUID()" },
  "aleator:uuid:zig": { "template": "blk: { var buf: [36]u8 = undefined; var bytes: [16]u8 = undefined; std.crypto.random.bytes(&bytes); bytes[6] = (bytes[6] & 0x0f) | 0x40; bytes[8] = (bytes[8] & 0x3f) | 0x80; const hex = \\\"0123456789abcdef\\\"; var i: usize = 0; for (bytes, 0..) |b, j| { if (j == 4 or j == 6 or j == 8 or j == 10) { buf[i] = '-'; i += 1; } buf[i] = hex[b >> 4]; buf[i + 1] = hex[b & 0x0f]; i += 2; } break :blk buf; }" },
  "caelum:dele:cpp": { "template": "caelum::dele(§)", "params": ["url"] },
  "caelum:dele:py": { "template": "caelum.dele(§)", "params": ["url"] },
  "caelum:dele:rs": { "template": "caelum::dele(§)", "params": ["url"] },
  "caelum:dele:ts": { "template": "caelum.dele(§)", "params": ["url"] },
  "caelum:dele:zig": { "template": "caelum.dele(§)", "params": ["url"] },
  "caelum:exspecta:cpp": { "template": "caelum::exspecta(§, §)", "params": ["handler","portus"] },
  "caelum:exspecta:py": { "template": "caelum.exspecta(§, §)", "params": ["handler","portus"] },
  "caelum:exspecta:rs": { "template": "caelum::exspecta(§, §)", "params": ["handler","portus"] },
  "caelum:exspecta:ts": { "template": "caelum.exspecta(§, §)", "params": ["handler","portus"] },
  "caelum:exspecta:zig": { "template": "caelum.exspecta(§, §)", "params": ["handler","portus"] },
  "caelum:mitte:cpp": { "template": "caelum::mitte(§, §)", "params": ["url","corpus"] },
  "caelum:mitte:py": { "template": "caelum.mitte(§, §)", "params": ["url","corpus"] },
  "caelum:mitte:rs": { "template": "caelum::mitte(§, §)", "params": ["url","corpus"] },
  "caelum:mitte:ts": { "template": "caelum.mitte(§, §)", "params": ["url","corpus"] },
  "caelum:mitte:zig": { "template": "caelum.mitte(§, §)", "params": ["url","corpus"] },
  "caelum:muta:cpp": { "template": "caelum::muta(§, §)", "params": ["url","corpus"] },
  "caelum:muta:py": { "template": "caelum.muta(§, §)", "params": ["url","corpus"] },
  "caelum:muta:rs": { "template": "caelum::muta(§, §)", "params": ["url","corpus"] },
  "caelum:muta:ts": { "template": "caelum.muta(§, §)", "params": ["url","corpus"] },
  "caelum:muta:zig": { "template": "caelum.muta(§, §)", "params": ["url","corpus"] },
  "caelum:pete:cpp": { "template": "caelum::pete(§)", "params": ["url"] },
  "caelum:pete:py": { "template": "caelum.pete(§)", "params": ["url"] },
  "caelum:pete:rs": { "template": "caelum::pete(§)", "params": ["url"] },
  "caelum:pete:ts": { "template": "caelum.pete(§)", "params": ["url"] },
  "caelum:pete:zig": { "template": "caelum.pete(§)", "params": ["url"] },
  "caelum:pone:cpp": { "template": "caelum::pone(§, §)", "params": ["url","corpus"] },
  "caelum:pone:py": { "template": "caelum.pone(§, §)", "params": ["url","corpus"] },
  "caelum:pone:rs": { "template": "caelum::pone(§, §)", "params": ["url","corpus"] },
  "caelum:pone:ts": { "template": "caelum.pone(§, §)", "params": ["url","corpus"] },
  "caelum:pone:zig": { "template": "caelum.pone(§, §)", "params": ["url","corpus"] },
  "caelum:replicatio:cpp": { "template": "caelum::replicatio(§, §, §)", "params": ["status","capita","corpus"] },
  "caelum:replicatio:py": { "template": "caelum.replicatio(§, §, §)", "params": ["status","capita","corpus"] },
  "caelum:replicatio:rs": { "template": "caelum::replicatio(§, §, §)", "params": ["status","capita","corpus"] },
  "caelum:replicatio:ts": { "template": "caelum.replicatio(§, §, §)", "params": ["status","capita","corpus"] },
  "caelum:replicatio:zig": { "template": "caelum.replicatio(§, §, §)", "params": ["status","capita","corpus"] },
  "caelum:roga:cpp": { "template": "caelum::roga(§, §, §, §)", "params": ["modus","url","capita","corpus"] },
  "caelum:roga:py": { "template": "caelum.roga(§, §, §, §)", "params": ["modus","url","capita","corpus"] },
  "caelum:roga:rs": { "template": "caelum::roga(§, §, §, §)", "params": ["modus","url","capita","corpus"] },
  "caelum:roga:ts": { "template": "caelum.roga(§, §, §, §)", "params": ["modus","url","capita","corpus"] },
  "caelum:roga:zig": { "template": "caelum.roga(§, §, §, §)", "params": ["modus","url","capita","corpus"] },
  "caelum:siste:cpp": { "template": "§.siste()", "params": ["s"] },
  "caelum:siste:py": { "template": "§.siste()", "params": ["s"] },
  "caelum:siste:rs": { "template": "§.siste()", "params": ["s"] },
  "caelum:siste:ts": { "template": "§.siste()", "params": ["s"] },
  "caelum:siste:zig": { "template": "§.siste()", "params": ["s"] },
  "copia:adde:cpp": { "method": "insert" },
  "copia:adde:py": { "method": "add" },
  "copia:adde:rs": { "method": "insert" },
  "copia:adde:ts": { "method": "add" },
  "copia:adde:zig": { "template": "§0.adde(§2, §1)", "params": ["ego","elem","alloc"] },
  "copia:dele:cpp": { "template": "§0.erase(§1)", "params": ["ego","elem"] },
  "copia:dele:py": { "method": "discard" },
  "copia:dele:rs": { "template": "§0.remove(&§1)", "params": ["ego","elem"] },
  "copia:dele:ts": { "method": "delete" },
  "copia:dele:zig": { "template": "_ = §0.dele(§1)", "params": ["ego","elem"] },
  "copia:differentia:cpp": { "template": "faber::copia_differentia(§0, §1)", "params": ["ego","alia"] },
  "copia:differentia:py": { "template": "§0 - §1", "params": ["ego","alia"] },
  "copia:differentia:rs": { "template": "faber::copia_differentia(&§0, &§1)", "params": ["ego","alia"] },
  "copia:differentia:ts": { "template": "new Set([...§0].filter(x => !§1.has(x)))", "params": ["ego","alia"] },
  "copia:differentia:zig": { "template": "@compileError(\\\"differentia not implemented for Zig - use explicit loop\\\")", "params": ["ego","alia"] },
  "copia:habet:cpp": { "template": "§0.contains(§1)", "params": ["ego","elem"] },
  "copia:habet:py": { "template": "(§1 in §0)", "params": ["ego","elem"] },
  "copia:habet:rs": { "template": "§0.contains(&§1)", "params": ["ego","elem"] },
  "copia:habet:ts": { "method": "has" },
  "copia:habet:zig": { "template": "§0.habet(§1)", "params": ["ego","elem"] },
  "copia:inLista:cpp": { "template": "faber::copia_in_lista(§)", "params": ["ego"] },
  "copia:inLista:py": { "template": "list(§)", "params": ["ego"] },
  "copia:inLista:rs": { "template": "faber::copia_in_lista(&§)", "params": ["ego"] },
  "copia:inLista:ts": { "template": "[...§]", "params": ["ego"] },
  "copia:inLista:zig": { "template": "@compileError(\\\"inLista not implemented for Zig - iterate with ex...pro into ArrayList\\\")", "params": ["ego"] },
  "copia:intersectio:cpp": { "template": "faber::copia_intersectio(§0, §1)", "params": ["ego","alia"] },
  "copia:intersectio:py": { "template": "§0 & §1", "params": ["ego","alia"] },
  "copia:intersectio:rs": { "template": "faber::copia_intersectio(&§0, &§1)", "params": ["ego","alia"] },
  "copia:intersectio:ts": { "template": "new Set([...§0].filter(x => §1.has(x)))", "params": ["ego","alia"] },
  "copia:intersectio:zig": { "template": "@compileError(\\\"intersectio not implemented for Zig - use explicit loop\\\")", "params": ["ego","alia"] },
  "copia:longitudo:cpp": { "template": "§.size()", "params": ["ego"] },
  "copia:longitudo:py": { "template": "len(§)", "params": ["ego"] },
  "copia:longitudo:rs": { "template": "§.len()", "params": ["ego"] },
  "copia:longitudo:ts": { "template": "§.size", "params": ["ego"] },
  "copia:longitudo:zig": { "template": "§.longitudo()", "params": ["ego"] },
  "copia:perambula:cpp": { "template": "std::ranges::for_each(§0, §1)", "params": ["ego","fn"] },
  "copia:perambula:py": { "template": "[(§1)(x) for x in §0]", "params": ["ego","fn"] },
  "copia:perambula:rs": { "template": "§0.iter().for_each(§1)", "params": ["ego","fn"] },
  "copia:perambula:ts": { "method": "forEach" },
  "copia:perambula:zig": { "template": "@compileError(\\\"perambula not implemented for Zig - use 'ex set.valores() pro item { ... }' loop\\\")", "params": ["ego","fn"] },
  "copia:purga:cpp": { "method": "clear" },
  "copia:purga:py": { "method": "clear" },
  "copia:purga:rs": { "method": "clear" },
  "copia:purga:ts": { "method": "clear" },
  "copia:purga:zig": { "template": "§.purga()", "params": ["ego"] },
  "copia:subcopia:cpp": { "template": "faber::copia_subcopia(§0, §1)", "params": ["ego","alia"] },
  "copia:subcopia:py": { "template": "§0 <= §1", "params": ["ego","alia"] },
  "copia:subcopia:rs": { "template": "§0.is_subset(&§1)", "params": ["ego","alia"] },
  "copia:subcopia:ts": { "template": "[...§0].every(x => §1.has(x))", "params": ["ego","alia"] },
  "copia:subcopia:zig": { "template": "@compileError(\\\"subcopia not implemented for Zig - use explicit loop\\\")", "params": ["ego","alia"] },
  "copia:supercopia:cpp": { "template": "faber::copia_supercopia(§0, §1)", "params": ["ego","alia"] },
  "copia:supercopia:py": { "template": "§0 >= §1", "params": ["ego","alia"] },
  "copia:supercopia:rs": { "template": "§0.is_superset(&§1)", "params": ["ego","alia"] },
  "copia:supercopia:ts": { "template": "[...§1].every(x => §0.has(x))", "params": ["ego","alia"] },
  "copia:supercopia:zig": { "template": "@compileError(\\\"supercopia not implemented for Zig - use explicit loop\\\")", "params": ["ego","alia"] },
  "copia:symmetrica:cpp": { "template": "faber::copia_symmetrica(§0, §1)", "params": ["ego","alia"] },
  "copia:symmetrica:py": { "template": "§0 ^ §1", "params": ["ego","alia"] },
  "copia:symmetrica:rs": { "template": "faber::copia_symmetrica(&§0, &§1)", "params": ["ego","alia"] },
  "copia:symmetrica:ts": { "template": "new Set([...[...§0].filter(x => !§1.has(x)), ...[...§1].filter(x => !§0.has(x))])", "params": ["ego","alia"] },
  "copia:symmetrica:zig": { "template": "@compileError(\\\"symmetrica not implemented for Zig - use explicit loop\\\")", "params": ["ego","alia"] },
  "copia:unio:cpp": { "template": "faber::copia_unio(§0, §1)", "params": ["ego","alia"] },
  "copia:unio:py": { "template": "§0 | §1", "params": ["ego","alia"] },
  "copia:unio:rs": { "template": "faber::copia_unio(&§0, &§1)", "params": ["ego","alia"] },
  "copia:unio:ts": { "template": "new Set([...§0, ...§1])", "params": ["ego","alia"] },
  "copia:unio:zig": { "template": "@compileError(\\\"unio not implemented for Zig - use explicit loop to merge sets\\\")", "params": ["ego","alia"] },
  "copia:vacua:cpp": { "template": "§.empty()", "params": ["ego"] },
  "copia:vacua:py": { "template": "len(§) == 0", "params": ["ego"] },
  "copia:vacua:rs": { "template": "§.is_empty()", "params": ["ego"] },
  "copia:vacua:ts": { "template": "§.size === 0", "params": ["ego"] },
  "copia:vacua:zig": { "template": "§.vacua()", "params": ["ego"] },
  "copia:valores:cpp": { "template": "§", "params": ["ego"] },
  "copia:valores:py": { "template": "iter(§)", "params": ["ego"] },
  "copia:valores:rs": { "template": "§.iter()", "params": ["ego"] },
  "copia:valores:ts": { "method": "values" },
  "copia:valores:zig": { "template": "§.valores()", "params": ["ego"] },
  "fractus:absolutum:cpp": { "template": "std::abs(§)", "params": ["ego"] },
  "fractus:absolutum:py": { "template": "abs(§)", "params": ["ego"] },
  "fractus:absolutum:rs": { "template": "§.abs()", "params": ["ego"] },
  "fractus:absolutum:ts": { "template": "Math.abs(§)", "params": ["ego"] },
  "fractus:absolutum:zig": { "template": "@abs(§)", "params": ["ego"] },
  "fractus:maximus:cpp": { "template": "std::max(§, §)", "params": ["ego","other"] },
  "fractus:maximus:py": { "template": "max(§, §)", "params": ["ego","other"] },
  "fractus:maximus:rs": { "template": "§.max(§)", "params": ["ego","other"] },
  "fractus:maximus:ts": { "template": "Math.max(§, §)", "params": ["ego","other"] },
  "fractus:maximus:zig": { "template": "@max(§, §)", "params": ["ego","other"] },
  "fractus:minimus:cpp": { "template": "std::min(§, §)", "params": ["ego","other"] },
  "fractus:minimus:py": { "template": "min(§, §)", "params": ["ego","other"] },
  "fractus:minimus:rs": { "template": "§.min(§)", "params": ["ego","other"] },
  "fractus:minimus:ts": { "template": "Math.min(§, §)", "params": ["ego","other"] },
  "fractus:minimus:zig": { "template": "@min(§, §)", "params": ["ego","other"] },
  "fractus:pavimentum:cpp": { "template": "static_cast<int64_t>(std::floor(§))", "params": ["ego"] },
  "fractus:pavimentum:py": { "template": "math.floor(§)", "params": ["ego"] },
  "fractus:pavimentum:rs": { "template": "§.floor() as i64", "params": ["ego"] },
  "fractus:pavimentum:ts": { "template": "Math.floor(§)", "params": ["ego"] },
  "fractus:pavimentum:zig": { "template": "@intFromFloat(@floor(§))", "params": ["ego"] },
  "fractus:rotunda:cpp": { "template": "static_cast<int64_t>(std::round(§))", "params": ["ego"] },
  "fractus:rotunda:py": { "template": "round(§)", "params": ["ego"] },
  "fractus:rotunda:rs": { "template": "§.round() as i64", "params": ["ego"] },
  "fractus:rotunda:ts": { "template": "Math.round(§)", "params": ["ego"] },
  "fractus:rotunda:zig": { "template": "@intFromFloat(@round(§))", "params": ["ego"] },
  "fractus:signum:cpp": { "template": "std::copysign(1.0, §)", "params": ["ego"] },
  "fractus:signum:py": { "template": "math.copysign(1, §)", "params": ["ego"] },
  "fractus:signum:rs": { "template": "§.signum()", "params": ["ego"] },
  "fractus:signum:ts": { "template": "Math.sign(§)", "params": ["ego"] },
  "fractus:signum:zig": { "template": "std.math.sign(§)", "params": ["ego"] },
  "fractus:tectum:cpp": { "template": "static_cast<int64_t>(std::ceil(§))", "params": ["ego"] },
  "fractus:tectum:py": { "template": "math.ceil(§)", "params": ["ego"] },
  "fractus:tectum:rs": { "template": "§.ceil() as i64", "params": ["ego"] },
  "fractus:tectum:ts": { "template": "Math.ceil(§)", "params": ["ego"] },
  "fractus:tectum:zig": { "template": "@intFromFloat(@ceil(§))", "params": ["ego"] },
  "fractus:trunca:cpp": { "template": "static_cast<int64_t>(std::trunc(§))", "params": ["ego"] },
  "fractus:trunca:py": { "template": "math.trunc(§)", "params": ["ego"] },
  "fractus:trunca:rs": { "template": "§.trunc() as i64", "params": ["ego"] },
  "fractus:trunca:ts": { "template": "Math.trunc(§)", "params": ["ego"] },
  "fractus:trunca:zig": { "template": "@intFromFloat(@trunc(§))", "params": ["ego"] },
  "lista:accipe:cpp": { "template": "§.at(§)", "params": ["ego","idx"] },
  "lista:accipe:py": { "template": "§[§]", "params": ["ego","idx"] },
  "lista:accipe:rs": { "template": "§.get(§)", "params": ["ego","idx"] },
  "lista:accipe:ts": { "template": "§[§]", "params": ["ego","idx"] },
  "lista:accipe:zig": { "template": "§.accipe(§)", "params": ["ego","idx"] },
  "lista:adde:cpp": { "method": "push_back" },
  "lista:adde:py": { "method": "append" },
  "lista:adde:rs": { "method": "push" },
  "lista:adde:ts": { "method": "push" },
  "lista:adde:zig": { "template": "§0.adde(§2, §1)", "params": ["ego","elem","alloc"] },
  "lista:addita:cpp": { "template": "faber::lista_addita(§0, §1)", "params": ["ego","elem"] },
  "lista:addita:py": { "template": "[*§, §]", "params": ["ego","elem"] },
  "lista:addita:rs": { "template": "faber::lista_addita(&§0, §1)", "params": ["ego","elem"] },
  "lista:addita:ts": { "template": "[...§, §]", "params": ["ego","elem"] },
  "lista:addita:zig": { "template": "§0.addita(§2, §1)", "params": ["ego","elem","alloc"] },
  "lista:aliquis:cpp": { "template": "std::ranges::any_of(§, §)", "params": ["ego","pred"] },
  "lista:aliquis:py": { "template": "any(map(§, §))", "params": ["ego","pred"] },
  "lista:aliquis:rs": { "template": "§.iter().any(§)", "params": ["ego","pred"] },
  "lista:aliquis:ts": { "method": "some" },
  "lista:aliquis:zig": { "template": "§.aliquis(§)", "params": ["ego","pred"] },
  "lista:congrega:cpp": { "template": "faber::lista_congrega(§0, §1)", "params": ["ego","fn"] },
  "lista:congrega:py": { "template": "{k: list(g) for k, g in itertools.groupby(sorted(§, key=§), key=§)}", "params": ["ego","fn"] },
  "lista:congrega:rs": { "template": "faber::lista_congrega(&§0, §1)", "params": ["ego","fn"] },
  "lista:congrega:ts": { "template": "Object.groupBy(§, §)", "params": ["ego","fn"] },
  "lista:coniunge:cpp": { "template": "faber::lista_coniunge(§0, §1)", "params": ["ego","sep"] },
  "lista:coniunge:py": { "template": "§.join(§)", "params": ["ego","sep"] },
  "lista:coniunge:rs": { "template": "§.join(§)", "params": ["ego","sep"] },
  "lista:coniunge:ts": { "method": "join" },
  "lista:continet:cpp": { "template": "(std::find(§0.begin(), §0.end(), §1) != §0.end())", "params": ["ego","elem"] },
  "lista:continet:py": { "template": "(§1 in §0)", "params": ["ego","elem"] },
  "lista:continet:rs": { "template": "§0.contains(&§1)", "params": ["ego","elem"] },
  "lista:continet:ts": { "method": "includes" },
  "lista:continet:zig": { "template": "§.continet(§)", "params": ["ego","elem"] },
  "lista:decapita:cpp": { "template": "faber::lista_decapita(§0)", "params": ["ego"] },
  "lista:decapita:py": { "template": "§.pop(0)", "params": ["ego"] },
  "lista:decapita:rs": { "template": "§.remove(0)", "params": ["ego"] },
  "lista:decapita:ts": { "method": "shift" },
  "lista:decapita:zig": { "template": "§.decapita()", "params": ["ego"] },
  "lista:decapitata:cpp": { "template": "std::vector(§0.begin() + 1, §0.end())", "params": ["ego"] },
  "lista:decapitata:py": { "template": "§[1:]", "params": ["ego"] },
  "lista:decapitata:rs": { "template": "§[1..].to_vec()", "params": ["ego"] },
  "lista:decapitata:ts": { "template": "§.slice(1)", "params": ["ego"] },
  "lista:decapitata:zig": { "template": "§.decapitata(§)", "params": ["ego","alloc"] },
  "lista:densa:cpp": { "template": "(§ | std::views::filter([](auto& x) { return static_cast<bool>(x); }) | std::ranges::to<std::vector>())", "params": ["ego"] },
  "lista:densa:py": { "template": "[x for x in § if x]", "params": ["ego"] },
  "lista:densa:ts": { "template": "§.filter(Boolean)", "params": ["ego"] },
  "lista:explanata:cpp": { "template": "(§ | std::views::transform(§) | std::views::join | std::ranges::to<std::vector>())", "params": ["ego","fn"] },
  "lista:explanata:py": { "template": "[y for x in § for y in (§)(x)]", "params": ["ego","fn"] },
  "lista:explanata:rs": { "template": "§.iter().flat_map(§).collect::<Vec<_>>()", "params": ["ego","fn"] },
  "lista:explanata:ts": { "method": "flatMap" },
  "lista:filtra:cpp": { "template": "§0.erase(std::remove_if(§0.begin(), §0.end(), [&](auto& x) { return !(§1)(x); }), §0.end())", "params": ["ego","pred"] },
  "lista:filtra:py": { "template": "§[:] = [x for x in § if (§)(x)]", "params": ["ego","pred"] },
  "lista:filtra:ts": { "template": "(() => { for (let i = §.length - 1; i >= 0; i--) { if (!(§)(§[i])) §.splice(i, 1); } })()", "params": ["ego","pred"] },
  "lista:filtrata:cpp": { "template": "(§ | std::views::filter(§) | std::ranges::to<std::vector>())", "params": ["ego","pred"] },
  "lista:filtrata:py": { "template": "list(filter(§, §))", "params": ["ego","pred"] },
  "lista:filtrata:rs": { "template": "§.iter().filter(§).cloned().collect::<Vec<_>>()", "params": ["ego","pred"] },
  "lista:filtrata:ts": { "method": "filter" },
  "lista:filtrata:zig": { "template": "§0.filtrata(§2, §1)", "params": ["ego","pred","alloc"] },
  "lista:fragmenta:cpp": { "template": "faber::lista_fragmenta(§0, §1)", "params": ["ego","n"] },
  "lista:fragmenta:py": { "template": "[§[i:i+§] for i in range(0, len(§), §)]", "params": ["ego","n"] },
  "lista:fragmenta:rs": { "template": "§.chunks(§).map(|c| c.to_vec()).collect::<Vec<_>>()", "params": ["ego","n"] },
  "lista:fragmenta:ts": { "template": "Array.from({ length: Math.ceil(§.length / §) }, (_, i) => §.slice(i * §, i * § + §))", "params": ["ego","n"] },
  "lista:indiceDe:cpp": { "template": "faber::lista_indice_de(§0, §1)", "params": ["ego","elem"] },
  "lista:indiceDe:py": { "template": "§0.index(§1)", "params": ["ego","elem"] },
  "lista:indiceDe:rs": { "template": "§0.iter().position(|e| e == &§1)", "params": ["ego","elem"] },
  "lista:indiceDe:ts": { "method": "indexOf" },
  "lista:indiceDe:zig": { "template": "§.indiceDe(§)", "params": ["ego","elem"] },
  "lista:inveni:cpp": { "template": "*std::find_if(§0.begin(), §0.end(), §1)", "params": ["ego","pred"] },
  "lista:inveni:py": { "template": "next(filter(§1, §0), None)", "params": ["ego","pred"] },
  "lista:inveni:rs": { "template": "§0.iter().find(§1)", "params": ["ego","pred"] },
  "lista:inveni:ts": { "method": "find" },
  "lista:inveni:zig": { "template": "§.inveni(§)", "params": ["ego","pred"] },
  "lista:inveniIndicem:cpp": { "template": "faber::lista_inveni_indicem(§0, §1)", "params": ["ego","pred"] },
  "lista:inveniIndicem:py": { "template": "next((i for i, x in enumerate(§0) if (§1)(x)), -1)", "params": ["ego","pred"] },
  "lista:inveniIndicem:rs": { "template": "§0.iter().position(§1)", "params": ["ego","pred"] },
  "lista:inveniIndicem:ts": { "method": "findIndex" },
  "lista:inveniIndicem:zig": { "template": "§.inveniIndicem(§)", "params": ["ego","pred"] },
  "lista:inversa:cpp": { "template": "faber::lista_inversa(§)", "params": ["ego"] },
  "lista:inversa:py": { "template": "§[::-1]", "params": ["ego"] },
  "lista:inversa:rs": { "template": "§.iter().rev().cloned().collect::<Vec<_>>()", "params": ["ego"] },
  "lista:inversa:ts": { "template": "[...§].reverse()", "params": ["ego"] },
  "lista:inversa:zig": { "template": "§.inversa(§)", "params": ["ego","alloc"] },
  "lista:inverte:cpp": { "template": "std::ranges::reverse(§)", "params": ["ego"] },
  "lista:inverte:py": { "template": "§.reverse()", "params": ["ego"] },
  "lista:inverte:rs": { "template": "§.reverse()", "params": ["ego"] },
  "lista:inverte:ts": { "method": "reverse" },
  "lista:inverte:zig": { "template": "§.inverte()", "params": ["ego"] },
  "lista:longitudo:cpp": { "template": "§.size()", "params": ["ego"] },
  "lista:longitudo:py": { "template": "len(§)", "params": ["ego"] },
  "lista:longitudo:rs": { "template": "§.len()", "params": ["ego"] },
  "lista:longitudo:ts": { "template": "§.length", "params": ["ego"] },
  "lista:longitudo:zig": { "template": "§.longitudo()", "params": ["ego"] },
  "lista:mappata:cpp": { "template": "(§ | std::views::transform(§) | std::ranges::to<std::vector>())", "params": ["ego","fn"] },
  "lista:mappata:py": { "template": "list(map(§, §))", "params": ["ego","fn"] },
  "lista:mappata:rs": { "template": "§.iter().map(§).collect::<Vec<_>>()", "params": ["ego","fn"] },
  "lista:mappata:ts": { "method": "map" },
  "lista:mappata:zig": { "template": "§0.mappata(§2, §1)", "params": ["ego","fn","alloc"] },
  "lista:maximus:cpp": { "template": "*std::ranges::max_element(§)", "params": ["ego"] },
  "lista:maximus:py": { "template": "max(§)", "params": ["ego"] },
  "lista:maximus:rs": { "template": "§.iter().max()", "params": ["ego"] },
  "lista:maximus:ts": { "template": "Math.max(...§)", "params": ["ego"] },
  "lista:maximus:zig": { "template": "§.maximus()", "params": ["ego"] },
  "lista:maximusPer:cpp": { "template": "*std::ranges::max_element(§, [&](auto& a, auto& b) { return (§)(a) < (§)(b); })", "params": ["ego","fn"] },
  "lista:maximusPer:rs": { "template": "§.iter().max_by_key(§)", "params": ["ego","fn"] },
  "lista:maximusPer:ts": { "template": "§.reduce((max, x) => (§)(x) > (§)(max) ? x : max)", "params": ["ego","fn"] },
  "lista:medium:cpp": { "template": "(std::accumulate(§0.begin(), §0.end(), 0.0) / §0.size())", "params": ["ego"] },
  "lista:medium:py": { "template": "(sum(§0) / len(§0))", "params": ["ego"] },
  "lista:medium:rs": { "template": "(§0.iter().sum::<i64>() as f64 / §0.len() as f64)", "params": ["ego"] },
  "lista:medium:ts": { "template": "(§0.reduce((a, b) => a + b, 0) / §0.length)", "params": ["ego"] },
  "lista:medium:zig": { "template": "§.medium()", "params": ["ego"] },
  "lista:minimus:cpp": { "template": "*std::ranges::min_element(§)", "params": ["ego"] },
  "lista:minimus:py": { "template": "min(§)", "params": ["ego"] },
  "lista:minimus:rs": { "template": "§.iter().min()", "params": ["ego"] },
  "lista:minimus:ts": { "template": "Math.min(...§)", "params": ["ego"] },
  "lista:minimus:zig": { "template": "§.minimus()", "params": ["ego"] },
  "lista:minimusPer:cpp": { "template": "*std::ranges::min_element(§, [&](auto& a, auto& b) { return (§)(a) < (§)(b); })", "params": ["ego","fn"] },
  "lista:minimusPer:rs": { "template": "§.iter().min_by_key(§)", "params": ["ego","fn"] },
  "lista:minimusPer:ts": { "template": "§.reduce((min, x) => (§)(x) < (§)(min) ? x : min)", "params": ["ego","fn"] },
  "lista:miscita:cpp": { "template": "faber::lista_miscita(§)", "params": ["ego"] },
  "lista:miscita:py": { "template": "random.shuffle(§)", "params": ["ego"] },
  "lista:miscita:ts": { "template": "(() => { const a = [...§]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; })()", "params": ["ego"] },
  "lista:numera:cpp": { "template": "std::ranges::count_if(§, §)", "params": ["ego","pred"] },
  "lista:numera:py": { "template": "sum(1 for x in § if (§)(x))", "params": ["ego","pred"] },
  "lista:numera:rs": { "template": "§.iter().filter(§).count()", "params": ["ego","pred"] },
  "lista:numera:ts": { "template": "§.filter(§).length", "params": ["ego","pred"] },
  "lista:numera:zig": { "template": "§.numera(§)", "params": ["ego","pred"] },
  "lista:omissa:cpp": { "template": "(§ | std::views::drop(§) | std::ranges::to<std::vector>())", "params": ["ego","n"] },
  "lista:omissa:py": { "template": "§[§:]", "params": ["ego","n"] },
  "lista:omissa:rs": { "template": "§.iter().skip(§).cloned().collect::<Vec<_>>()", "params": ["ego","n"] },
  "lista:omissa:ts": { "template": "§.slice(§)", "params": ["ego","n"] },
  "lista:omissa:zig": { "template": "§0.omissa(§2, §1)", "params": ["ego","n","alloc"] },
  "lista:omnes:cpp": { "template": "std::ranges::all_of(§, §)", "params": ["ego","pred"] },
  "lista:omnes:py": { "template": "all(map(§, §))", "params": ["ego","pred"] },
  "lista:omnes:rs": { "template": "§.iter().all(§)", "params": ["ego","pred"] },
  "lista:omnes:ts": { "method": "every" },
  "lista:omnes:zig": { "template": "§.omnes(§)", "params": ["ego","pred"] },
  "lista:ordina:cpp": { "template": "std::ranges::sort(§)", "params": ["ego"] },
  "lista:ordina:py": { "template": "§.sort()", "params": ["ego"] },
  "lista:ordina:rs": { "template": "§.sort()", "params": ["ego"] },
  "lista:ordina:ts": { "template": "§.sort()", "params": ["ego"] },
  "lista:ordina:zig": { "template": "§.ordina()", "params": ["ego"] },
  "lista:ordinata:cpp": { "template": "faber::lista_ordinata(§)", "params": ["ego"] },
  "lista:ordinata:py": { "template": "sorted(§)", "params": ["ego"] },
  "lista:ordinata:rs": { "template": "faber::lista_ordinata(&§)", "params": ["ego"] },
  "lista:ordinata:ts": { "template": "[...§].sort()", "params": ["ego"] },
  "lista:ordinata:zig": { "template": "§.ordinata(§)", "params": ["ego","alloc"] },
  "lista:partire:cpp": { "template": "faber::lista_partire(§0, §1)", "params": ["ego","pred"] },
  "lista:partire:py": { "template": "[[x for x in § if (§)(x)], [x for x in § if not (§)(x)]]", "params": ["ego","pred"] },
  "lista:partire:rs": { "template": "faber::lista_partire(&§0, §1)", "params": ["ego","pred"] },
  "lista:partire:ts": { "template": "§.reduce(([t, f], x) => (§)(x) ? [[...t, x], f] : [t, [...f, x]], [[], []])", "params": ["ego","pred"] },
  "lista:perambula:cpp": { "template": "std::ranges::for_each(§, §)", "params": ["ego","fn"] },
  "lista:perambula:py": { "template": "[(§)(x) for x in §]", "params": ["ego","fn"] },
  "lista:perambula:rs": { "template": "§.iter().for_each(§)", "params": ["ego","fn"] },
  "lista:perambula:ts": { "method": "forEach" },
  "lista:perambula:zig": { "template": "§.perambula(§)", "params": ["ego","fn"] },
  "lista:plana:cpp": { "template": "(§ | std::views::join | std::ranges::to<std::vector>())", "params": ["ego"] },
  "lista:plana:py": { "template": "[y for x in § for y in x]", "params": ["ego"] },
  "lista:plana:rs": { "template": "§.iter().flatten().cloned().collect::<Vec<_>>()", "params": ["ego"] },
  "lista:plana:ts": { "method": "flat" },
  "lista:planaOmnia:cpp": { "template": "(§ | std::views::join | std::ranges::to<std::vector>())", "params": ["ego"] },
  "lista:planaOmnia:ts": { "template": "§.flat(Infinity)", "params": ["ego"] },
  "lista:praepone:cpp": { "template": "§.insert(§.begin(), §)", "params": ["ego","elem"] },
  "lista:praepone:py": { "template": "§.insert(0, §)", "params": ["ego","elem"] },
  "lista:praepone:rs": { "template": "§.insert(0, §)", "params": ["ego","elem"] },
  "lista:praepone:ts": { "method": "unshift" },
  "lista:praepone:zig": { "template": "§0.praepone(§2, §1)", "params": ["ego","elem","alloc"] },
  "lista:praeposita:cpp": { "template": "faber::lista_praeposita(§0, §1)", "params": ["ego","elem"] },
  "lista:praeposita:py": { "template": "[§1, *§0]", "params": ["ego","elem"] },
  "lista:praeposita:rs": { "template": "faber::lista_praeposita(&§0, §1)", "params": ["ego","elem"] },
  "lista:praeposita:ts": { "template": "[§1, ...§0]", "params": ["ego","elem"] },
  "lista:praeposita:zig": { "template": "§0.praeposita(§2, §1)", "params": ["ego","elem","alloc"] },
  "lista:prima:cpp": { "template": "(§ | std::views::take(§) | std::ranges::to<std::vector>())", "params": ["ego","n"] },
  "lista:prima:py": { "template": "§[:§]", "params": ["ego","n"] },
  "lista:prima:rs": { "template": "§.iter().take(§).cloned().collect::<Vec<_>>()", "params": ["ego","n"] },
  "lista:prima:ts": { "template": "§.slice(0, §)", "params": ["ego","n"] },
  "lista:prima:zig": { "template": "§0.prima(§2, §1)", "params": ["ego","n","alloc"] },
  "lista:primus:cpp": { "template": "§.front()", "params": ["ego"] },
  "lista:primus:py": { "template": "§[0]", "params": ["ego"] },
  "lista:primus:rs": { "template": "§.first()", "params": ["ego"] },
  "lista:primus:ts": { "template": "§[0]", "params": ["ego"] },
  "lista:primus:zig": { "template": "§.primus()", "params": ["ego"] },
  "lista:purga:cpp": { "method": "clear" },
  "lista:purga:py": { "method": "clear" },
  "lista:purga:rs": { "method": "clear" },
  "lista:purga:ts": { "template": "§.length = 0", "params": ["ego"] },
  "lista:purga:zig": { "template": "§.purga()", "params": ["ego"] },
  "lista:reducta:cpp": { "template": "std::ranges::fold_left(§, §, §)", "params": ["ego","fn","init"] },
  "lista:reducta:py": { "template": "functools.reduce(§, §, §)", "params": ["ego","fn","init"] },
  "lista:reducta:rs": { "template": "§.iter().fold(§, §)", "params": ["ego","fn","init"] },
  "lista:reducta:ts": { "method": "reduce" },
  "lista:reducta:zig": { "template": "§.reducta(§, §)", "params": ["ego","fn","init"] },
  "lista:remota:cpp": { "template": "std::vector(§0.begin(), §0.end() - 1)", "params": ["ego"] },
  "lista:remota:py": { "template": "§[:-1]", "params": ["ego"] },
  "lista:remota:rs": { "template": "§0[..§0.len().saturating_sub(1)].to_vec()", "params": ["ego"] },
  "lista:remota:ts": { "template": "§.slice(0, -1)", "params": ["ego"] },
  "lista:remota:zig": { "template": "§.remota(§)", "params": ["ego","alloc"] },
  "lista:remove:cpp": { "template": "faber::lista_remove(§0)", "params": ["ego"] },
  "lista:remove:py": { "method": "pop" },
  "lista:remove:rs": { "template": "§.pop()", "params": ["ego"] },
  "lista:remove:ts": { "method": "pop" },
  "lista:remove:zig": { "template": "§.remove()", "params": ["ego"] },
  "lista:sectio:cpp": { "template": "std::vector(§0.begin() + §1, §0.begin() + §2)", "params": ["ego","start","end"] },
  "lista:sectio:py": { "template": "§[§:§]", "params": ["ego","start","end"] },
  "lista:sectio:rs": { "template": "§[§..§].to_vec()", "params": ["ego","start","end"] },
  "lista:sectio:ts": { "method": "slice" },
  "lista:sectio:zig": { "template": "§0.sectio(§3, §1, §2)", "params": ["ego","start","end","alloc"] },
  "lista:specimen:cpp": { "template": "faber::lista_specimen(§0)", "params": ["ego"] },
  "lista:specimen:py": { "template": "random.choice(§)", "params": ["ego"] },
  "lista:specimen:ts": { "template": "§0[Math.floor(Math.random() * §0.length)]", "params": ["ego"] },
  "lista:specimina:cpp": { "template": "faber::lista_specimina(§0, §1)", "params": ["ego","n"] },
  "lista:specimina:py": { "template": "random.sample(§, §)", "params": ["ego","n"] },
  "lista:specimina:ts": { "template": "(() => { const a = [...§]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a.slice(0, §); })()", "params": ["ego","n"] },
  "lista:summa:cpp": { "template": "std::accumulate(§0.begin(), §0.end(), 0)", "params": ["ego"] },
  "lista:summa:py": { "template": "sum(§)", "params": ["ego"] },
  "lista:summa:rs": { "template": "§.iter().sum::<i64>()", "params": ["ego"] },
  "lista:summa:ts": { "template": "§.reduce((a, b) => a + b, 0)", "params": ["ego"] },
  "lista:summa:zig": { "template": "§.summa()", "params": ["ego"] },
  "lista:ultima:cpp": { "template": "faber::lista_ultima(§0, §1)", "params": ["ego","n"] },
  "lista:ultima:py": { "template": "§[-§:]", "params": ["ego","n"] },
  "lista:ultima:rs": { "template": "faber::lista_ultima(&§0, §1)", "params": ["ego","n"] },
  "lista:ultima:ts": { "template": "§.slice(-§)", "params": ["ego","n"] },
  "lista:ultima:zig": { "template": "§0.ultima(§2, §1)", "params": ["ego","n","alloc"] },
  "lista:ultimus:cpp": { "template": "§.back()", "params": ["ego"] },
  "lista:ultimus:py": { "template": "§[-1]", "params": ["ego"] },
  "lista:ultimus:rs": { "template": "§.last()", "params": ["ego"] },
  "lista:ultimus:ts": { "template": "§.at(-1)", "params": ["ego"] },
  "lista:ultimus:zig": { "template": "§.ultimus()", "params": ["ego"] },
  "lista:unica:cpp": { "template": "faber::lista_unica(§)", "params": ["ego"] },
  "lista:unica:py": { "template": "list(dict.fromkeys(§))", "params": ["ego"] },
  "lista:unica:rs": { "template": "faber::lista_unica(&§)", "params": ["ego"] },
  "lista:unica:ts": { "template": "[...new Set(§)]", "params": ["ego"] },
  "lista:vacua:cpp": { "template": "§.empty()", "params": ["ego"] },
  "lista:vacua:py": { "template": "len(§) == 0", "params": ["ego"] },
  "lista:vacua:rs": { "template": "§.is_empty()", "params": ["ego"] },
  "lista:vacua:ts": { "template": "§.length === 0", "params": ["ego"] },
  "lista:vacua:zig": { "template": "§.vacua()", "params": ["ego"] },
  "mathesis:E:cpp": { "template": "M_E" },
  "mathesis:E:py": { "template": "math.e" },
  "mathesis:E:rs": { "template": "std::f64::consts::E" },
  "mathesis:E:ts": { "template": "Math.E" },
  "mathesis:E:zig": { "template": "std.math.e" },
  "mathesis:PI:cpp": { "template": "M_PI" },
  "mathesis:PI:py": { "template": "math.pi" },
  "mathesis:PI:rs": { "template": "std::f64::consts::PI" },
  "mathesis:PI:ts": { "template": "Math.PI" },
  "mathesis:PI:zig": { "template": "std.math.pi" },
  "mathesis:TAU:cpp": { "template": "(M_PI * 2)" },
  "mathesis:TAU:py": { "template": "(math.pi * 2)" },
  "mathesis:TAU:rs": { "template": "std::f64::consts::TAU" },
  "mathesis:TAU:ts": { "template": "(Math.PI * 2)" },
  "mathesis:TAU:zig": { "template": "(std.math.pi * 2)" },
  "mathesis:absolutum:cpp": { "template": "std::abs(§)", "params": ["x"] },
  "mathesis:absolutum:py": { "template": "abs(§)", "params": ["x"] },
  "mathesis:absolutum:rs": { "template": "§.abs()", "params": ["x"] },
  "mathesis:absolutum:ts": { "template": "Math.abs(§)", "params": ["x"] },
  "mathesis:absolutum:zig": { "template": "@abs(§)", "params": ["x"] },
  "mathesis:constringens:cpp": { "template": "std::clamp(§, §, §)", "params": ["x","lo","hi"] },
  "mathesis:constringens:py": { "template": "max(§1, min(§0, §2))", "params": ["x","lo","hi"] },
  "mathesis:constringens:rs": { "template": "§.clamp(§, §)", "params": ["x","lo","hi"] },
  "mathesis:constringens:ts": { "template": "Math.min(Math.max(§, §), §)", "params": ["x","lo","hi"] },
  "mathesis:constringens:zig": { "template": "std.math.clamp(§, §, §)", "params": ["x","lo","hi"] },
  "mathesis:cosinus:cpp": { "template": "std::cos(§)", "params": ["x"] },
  "mathesis:cosinus:py": { "template": "math.cos(§)", "params": ["x"] },
  "mathesis:cosinus:rs": { "template": "§.cos()", "params": ["x"] },
  "mathesis:cosinus:ts": { "template": "Math.cos(§)", "params": ["x"] },
  "mathesis:cosinus:zig": { "template": "@cos(§)", "params": ["x"] },
  "mathesis:exponens:cpp": { "template": "std::exp(§)", "params": ["x"] },
  "mathesis:exponens:py": { "template": "math.exp(§)", "params": ["x"] },
  "mathesis:exponens:rs": { "template": "§.exp()", "params": ["x"] },
  "mathesis:exponens:ts": { "template": "Math.exp(§)", "params": ["x"] },
  "mathesis:exponens:zig": { "template": "@exp(§)", "params": ["x"] },
  "mathesis:logarithmus10:cpp": { "template": "std::log10(§)", "params": ["x"] },
  "mathesis:logarithmus10:py": { "template": "math.log10(§)", "params": ["x"] },
  "mathesis:logarithmus10:rs": { "template": "§.log10()", "params": ["x"] },
  "mathesis:logarithmus10:ts": { "template": "Math.log10(§)", "params": ["x"] },
  "mathesis:logarithmus10:zig": { "template": "std.math.log10(§)", "params": ["x"] },
  "mathesis:logarithmus:cpp": { "template": "std::log(§)", "params": ["x"] },
  "mathesis:logarithmus:py": { "template": "math.log(§)", "params": ["x"] },
  "mathesis:logarithmus:rs": { "template": "§.ln()", "params": ["x"] },
  "mathesis:logarithmus:ts": { "template": "Math.log(§)", "params": ["x"] },
  "mathesis:logarithmus:zig": { "template": "@log(§)", "params": ["x"] },
  "mathesis:maximus:cpp": { "template": "std::max(§, §)", "params": ["a","b"] },
  "mathesis:maximus:py": { "template": "max(§, §)", "params": ["a","b"] },
  "mathesis:maximus:rs": { "template": "§.max(§)", "params": ["a","b"] },
  "mathesis:maximus:ts": { "template": "Math.max(§, §)", "params": ["a","b"] },
  "mathesis:maximus:zig": { "template": "@max(§, §)", "params": ["a","b"] },
  "mathesis:minimus:cpp": { "template": "std::min(§, §)", "params": ["a","b"] },
  "mathesis:minimus:py": { "template": "min(§, §)", "params": ["a","b"] },
  "mathesis:minimus:rs": { "template": "§.min(§)", "params": ["a","b"] },
  "mathesis:minimus:ts": { "template": "Math.min(§, §)", "params": ["a","b"] },
  "mathesis:minimus:zig": { "template": "@min(§, §)", "params": ["a","b"] },
  "mathesis:pavimentum:cpp": { "template": "std::floor(§)", "params": ["x"] },
  "mathesis:pavimentum:py": { "template": "math.floor(§)", "params": ["x"] },
  "mathesis:pavimentum:rs": { "template": "§.floor()", "params": ["x"] },
  "mathesis:pavimentum:ts": { "template": "Math.floor(§)", "params": ["x"] },
  "mathesis:pavimentum:zig": { "template": "@floor(§)", "params": ["x"] },
  "mathesis:potentia:cpp": { "template": "std::pow(§, §)", "params": ["base","exp"] },
  "mathesis:potentia:py": { "template": "math.pow(§, §)", "params": ["base","exp"] },
  "mathesis:potentia:rs": { "template": "§.powf(§)", "params": ["base","exp"] },
  "mathesis:potentia:ts": { "template": "Math.pow(§, §)", "params": ["base","exp"] },
  "mathesis:potentia:zig": { "template": "std.math.pow(§, §)", "params": ["base","exp"] },
  "mathesis:radix:cpp": { "template": "std::sqrt(§)", "params": ["x"] },
  "mathesis:radix:py": { "template": "math.sqrt(§)", "params": ["x"] },
  "mathesis:radix:rs": { "template": "§.sqrt()", "params": ["x"] },
  "mathesis:radix:ts": { "template": "Math.sqrt(§)", "params": ["x"] },
  "mathesis:radix:zig": { "template": "@sqrt(§)", "params": ["x"] },
  "mathesis:rotundum:cpp": { "template": "std::round(§)", "params": ["x"] },
  "mathesis:rotundum:py": { "template": "round(§)", "params": ["x"] },
  "mathesis:rotundum:rs": { "template": "§.round()", "params": ["x"] },
  "mathesis:rotundum:ts": { "template": "Math.round(§)", "params": ["x"] },
  "mathesis:rotundum:zig": { "template": "@round(§)", "params": ["x"] },
  "mathesis:signum:cpp": { "template": "((§0 > 0) - (§0 < 0))", "params": ["x"] },
  "mathesis:signum:py": { "template": "(1 if §0 > 0 else (-1 if §0 < 0 else 0))", "params": ["x"] },
  "mathesis:signum:rs": { "template": "§.signum()", "params": ["x"] },
  "mathesis:signum:ts": { "template": "Math.sign(§)", "params": ["x"] },
  "mathesis:signum:zig": { "template": "std.math.sign(§)", "params": ["x"] },
  "mathesis:sinus:cpp": { "template": "std::sin(§)", "params": ["x"] },
  "mathesis:sinus:py": { "template": "math.sin(§)", "params": ["x"] },
  "mathesis:sinus:rs": { "template": "§.sin()", "params": ["x"] },
  "mathesis:sinus:ts": { "template": "Math.sin(§)", "params": ["x"] },
  "mathesis:sinus:zig": { "template": "@sin(§)", "params": ["x"] },
  "mathesis:tangens:cpp": { "template": "std::tan(§)", "params": ["x"] },
  "mathesis:tangens:py": { "template": "math.tan(§)", "params": ["x"] },
  "mathesis:tangens:rs": { "template": "§.tan()", "params": ["x"] },
  "mathesis:tangens:ts": { "template": "Math.tan(§)", "params": ["x"] },
  "mathesis:tangens:zig": { "template": "@tan(§)", "params": ["x"] },
  "mathesis:tectum:cpp": { "template": "std::ceil(§)", "params": ["x"] },
  "mathesis:tectum:py": { "template": "math.ceil(§)", "params": ["x"] },
  "mathesis:tectum:rs": { "template": "§.ceil()", "params": ["x"] },
  "mathesis:tectum:ts": { "template": "Math.ceil(§)", "params": ["x"] },
  "mathesis:tectum:zig": { "template": "@ceil(§)", "params": ["x"] },
  "mathesis:truncatum:cpp": { "template": "std::trunc(§)", "params": ["x"] },
  "mathesis:truncatum:py": { "template": "math.trunc(§)", "params": ["x"] },
  "mathesis:truncatum:rs": { "template": "§.trunc()", "params": ["x"] },
  "mathesis:truncatum:ts": { "template": "Math.trunc(§)", "params": ["x"] },
  "mathesis:truncatum:zig": { "template": "@trunc(§)", "params": ["x"] },
  "numerus:absolutum:cpp": { "template": "std::abs(§)", "params": ["ego"] },
  "numerus:absolutum:py": { "template": "abs(§)", "params": ["ego"] },
  "numerus:absolutum:rs": { "template": "§.abs()", "params": ["ego"] },
  "numerus:absolutum:ts": { "template": "Math.abs(§)", "params": ["ego"] },
  "numerus:absolutum:zig": { "template": "@intCast(@abs(§))", "params": ["ego"] },
  "numerus:maximus:cpp": { "template": "std::max(§, §)", "params": ["ego","other"] },
  "numerus:maximus:py": { "template": "max(§, §)", "params": ["ego","other"] },
  "numerus:maximus:rs": { "template": "std::cmp::max(§, §)", "params": ["ego","other"] },
  "numerus:maximus:ts": { "template": "Math.max(§, §)", "params": ["ego","other"] },
  "numerus:maximus:zig": { "template": "@max(§, §)", "params": ["ego","other"] },
  "numerus:minimus:cpp": { "template": "std::min(§, §)", "params": ["ego","other"] },
  "numerus:minimus:py": { "template": "min(§, §)", "params": ["ego","other"] },
  "numerus:minimus:rs": { "template": "std::cmp::min(§, §)", "params": ["ego","other"] },
  "numerus:minimus:ts": { "template": "Math.min(§, §)", "params": ["ego","other"] },
  "numerus:minimus:zig": { "template": "@min(§, §)", "params": ["ego","other"] },
  "numerus:signum:cpp": { "template": "((§0 > 0) - (§0 < 0))", "params": ["ego"] },
  "numerus:signum:py": { "template": "((§0>0)-(§0<0))", "params": ["ego"] },
  "numerus:signum:rs": { "template": "§.signum()", "params": ["ego"] },
  "numerus:signum:ts": { "template": "Math.sign(§)", "params": ["ego"] },
  "numerus:signum:zig": { "template": "std.math.sign(§)", "params": ["ego"] },
  "solum:ambula:py": { "template": "os.walk(§)", "params": ["path"] },
  "solum:ambula:ts": { "template": "glob.stream(§ + '/**/*')", "params": ["path"] },
  "solum:ambula:zig": { "template": "solum.ambula(§)", "params": ["path"] },
  "solum:appone:py": { "template": "open(§, 'a').write(§)", "params": ["path","data"] },
  "solum:appone:ts": { "template": "fs.appendFileSync(§, §)", "params": ["path","data"] },
  "solum:appone:zig": { "template": "solum.appone(§, §)", "params": ["path","data"] },
  "solum:apponet:py": { "template": "aiofiles.open(§, 'a').write(§)", "params": ["path","data"] },
  "solum:apponet:ts": { "template": "fs.promises.appendFile(§, §)", "params": ["path","data"] },
  "solum:apponet:zig": { "template": "solum.apponet(§, §)", "params": ["path","data"] },
  "solum:ausculta:py": { "template": "sys.stdin" },
  "solum:ausculta:ts": { "template": "readline.createInterface({ input: process.stdin })" },
  "solum:ausculta:zig": { "template": "solum.ausculta()" },
  "solum:basis:py": { "template": "os.path.basename(§)", "params": ["path"] },
  "solum:basis:ts": { "template": "path.basename(§)", "params": ["path"] },
  "solum:basis:zig": { "template": "solum.basis(§)", "params": ["path"] },
  "solum:crea:py": { "template": "os.makedirs(§, exist_ok=True)", "params": ["path"] },
  "solum:crea:ts": { "template": "fs.promises.mkdir(§, { recursive: true })", "params": ["path"] },
  "solum:crea:zig": { "template": "solum.crea(§)", "params": ["path"] },
  "solum:dele:py": { "template": "os.remove(§)", "params": ["path"] },
  "solum:dele:ts": { "template": "fs.promises.unlink(§)", "params": ["path"] },
  "solum:dele:zig": { "template": "solum.dele(§)", "params": ["path"] },
  "solum:deleArborem:py": { "template": "shutil.rmtree(§)", "params": ["path"] },
  "solum:deleArborem:ts": { "template": "fs.promises.rm(§, { recursive: true })", "params": ["path"] },
  "solum:deleArborem:zig": { "template": "solum.deleArborem(§)", "params": ["path"] },
  "solum:dir:py": { "template": "os.path.dirname(§)", "params": ["path"] },
  "solum:dir:ts": { "template": "path.dirname(§)", "params": ["path"] },
  "solum:dir:zig": { "template": "solum.dir(§)", "params": ["path"] },
  "solum:domus:py": { "template": "os.path.expanduser('~')" },
  "solum:domus:ts": { "template": "os.homedir()" },
  "solum:domus:zig": { "template": "solum.domus()" },
  "solum:duplica:py": { "template": "shutil.copy2(§, §)", "params": ["src","dest"] },
  "solum:duplica:ts": { "template": "fs.promises.copyFile(§, §)", "params": ["src","dest"] },
  "solum:duplica:zig": { "template": "solum.duplica(§, §)", "params": ["src","dest"] },
  "solum:elenca:py": { "template": "os.listdir(§)", "params": ["path"] },
  "solum:elenca:ts": { "template": "fs.promises.readdir(§)", "params": ["path"] },
  "solum:elenca:zig": { "template": "solum.elenca(§1, §0)", "params": ["path","alloc"] },
  "solum:exstat:py": { "template": "os.path.exists(§)", "params": ["path"] },
  "solum:exstat:ts": { "template": "fs.existsSync(§)", "params": ["path"] },
  "solum:exstat:zig": { "template": "solum.exstat(§)", "params": ["path"] },
  "solum:extensio:py": { "template": "os.path.splitext(§)[1]", "params": ["path"] },
  "solum:extensio:ts": { "template": "path.extname(§)", "params": ["path"] },
  "solum:extensio:zig": { "template": "solum.extensio(§)", "params": ["path"] },
  "solum:hauri:py": { "template": "sys.stdin.read()" },
  "solum:hauri:ts": { "template": "fs.readFileSync(0, 'utf-8')" },
  "solum:hauri:zig": { "template": "solum.hauri(§)", "params": ["alloc"] },
  "solum:inscribe:py": { "template": "open(§, 'w').write(§)", "params": ["path","data"] },
  "solum:inscribe:ts": { "template": "fs.writeFileSync(§, §)", "params": ["path","data"] },
  "solum:inscribe:zig": { "template": "solum.inscribe(§, §)", "params": ["path","data"] },
  "solum:inspice:py": { "template": "os.stat(§)", "params": ["path"] },
  "solum:inspice:ts": { "template": "fs.promises.stat(§)", "params": ["path"] },
  "solum:inspice:zig": { "template": "solum.inspice(§)", "params": ["path"] },
  "solum:iunge:py": { "template": "os.path.join(*§)", "params": ["parts"] },
  "solum:iunge:ts": { "template": "path.join(...§)", "params": ["parts"] },
  "solum:iunge:zig": { "template": "solum.iunge(§)", "params": ["parts"] },
  "solum:lege:py": { "template": "open(§).read()", "params": ["path"] },
  "solum:lege:ts": { "template": "fs.readFileSync(§, 'utf-8')", "params": ["path"] },
  "solum:lege:zig": { "template": "solum.lege(§1, §0)", "params": ["path","alloc"] },
  "solum:legens:py": { "template": "open(§, 'rb')", "params": ["path"] },
  "solum:legens:ts": { "template": "fs.createReadStream(§)", "params": ["path"] },
  "solum:legens:zig": { "template": "solum.legens(§)", "params": ["path"] },
  "solum:leget:py": { "template": "aiofiles.open(§).read()", "params": ["path"] },
  "solum:leget:ts": { "template": "fs.promises.readFile(§, 'utf-8')", "params": ["path"] },
  "solum:leget:zig": { "template": "solum.leget(§1, §0)", "params": ["path","alloc"] },
  "solum:move:py": { "template": "shutil.move(§, §)", "params": ["src","dest"] },
  "solum:move:ts": { "template": "fs.promises.rename(§, §)", "params": ["src","dest"] },
  "solum:move:zig": { "template": "solum.move(§, §)", "params": ["src","dest"] },
  "solum:resolve:py": { "template": "os.path.abspath(§)", "params": ["path"] },
  "solum:resolve:ts": { "template": "path.resolve(§)", "params": ["path"] },
  "solum:resolve:zig": { "template": "solum.resolve(§1, §0)", "params": ["path","alloc"] },
  "solum:scribens:py": { "template": "open(§, 'wb')", "params": ["path"] },
  "solum:scribens:ts": { "template": "fs.createWriteStream(§)", "params": ["path"] },
  "solum:scribens:zig": { "template": "solum.scribens(§)", "params": ["path"] },
  "solum:scribet:py": { "template": "aiofiles.open(§, 'w').write(§)", "params": ["path","data"] },
  "solum:scribet:ts": { "template": "fs.promises.writeFile(§, §)", "params": ["path","data"] },
  "solum:scribet:zig": { "template": "solum.scribet(§, §)", "params": ["path","data"] },
  "solum:tange:py": { "template": "pathlib.Path(§).touch()", "params": ["path"] },
  "solum:tange:ts": { "template": "fs.promises.utimes(§, Date.now(), Date.now())", "params": ["path"] },
  "solum:tange:zig": { "template": "solum.tange(§)", "params": ["path"] },
  "solum:trunca:py": { "template": "os.truncate(§, §)", "params": ["path","size"] },
  "solum:trunca:ts": { "template": "fs.promises.truncate(§, §)", "params": ["path","size"] },
  "solum:trunca:zig": { "template": "solum.trunca(§, §)", "params": ["path","size"] },
  "solum:vacua:py": { "template": "os.rmdir(§)", "params": ["path"] },
  "solum:vacua:ts": { "template": "fs.promises.rmdir(§)", "params": ["path"] },
  "solum:vacua:zig": { "template": "solum.vacua(§)", "params": ["path"] },
  "tabula:accipe:cpp": { "template": "§0.at(§1)", "params": ["ego","k"] },
  "tabula:accipe:py": { "template": "§0.get(§1)", "params": ["ego","k"] },
  "tabula:accipe:rs": { "template": "§0.get(&§1)", "params": ["ego","k"] },
  "tabula:accipe:ts": { "method": "get" },
  "tabula:accipe:zig": { "template": "§0.accipe(§1)", "params": ["ego","k"] },
  "tabula:accipeAut:cpp": { "template": "(§0.contains(§1) ? §0.at(§1) : §2)", "params": ["ego","k","def"] },
  "tabula:accipeAut:py": { "template": "§0.get(§1, §2)", "params": ["ego","k","def"] },
  "tabula:accipeAut:rs": { "template": "§0.get(&§1).cloned().unwrap_or(§2)", "params": ["ego","k","def"] },
  "tabula:accipeAut:ts": { "template": "(§0.get(§1) ?? §2)", "params": ["ego","k","def"] },
  "tabula:accipeAut:zig": { "template": "§0.accipeAut(§1, §2)", "params": ["ego","k","def"] },
  "tabula:claves:cpp": { "template": "§ | std::views::keys", "params": ["ego"] },
  "tabula:claves:py": { "method": "keys" },
  "tabula:claves:rs": { "template": "§.keys()", "params": ["ego"] },
  "tabula:claves:ts": { "method": "keys" },
  "tabula:claves:zig": { "template": "§.claves()", "params": ["ego"] },
  "tabula:conflata:cpp": { "template": "faber::tabula_conflata(§0, §1)", "params": ["ego","alia"] },
  "tabula:conflata:py": { "template": "{**§0, **§1}", "params": ["ego","alia"] },
  "tabula:conflata:rs": { "template": "faber::tabula_conflata(&§0, &§1)", "params": ["ego","alia"] },
  "tabula:conflata:ts": { "template": "new Map([...§0, ...§1])", "params": ["ego","alia"] },
  "tabula:conflata:zig": { "template": "§0.conflata(&§1)", "params": ["ego","alia"] },
  "tabula:dele:cpp": { "template": "§0.erase(§1)", "params": ["ego","k"] },
  "tabula:dele:py": { "template": "del §0[§1]", "params": ["ego","k"] },
  "tabula:dele:rs": { "template": "§0.remove(&§1)", "params": ["ego","k"] },
  "tabula:dele:ts": { "method": "delete" },
  "tabula:dele:zig": { "template": "_ = §0.dele(§1)", "params": ["ego","k"] },
  "tabula:habet:cpp": { "template": "§0.contains(§1)", "params": ["ego","k"] },
  "tabula:habet:py": { "template": "(§1 in §0)", "params": ["ego","k"] },
  "tabula:habet:rs": { "template": "§0.contains_key(&§1)", "params": ["ego","k"] },
  "tabula:habet:ts": { "method": "has" },
  "tabula:habet:zig": { "template": "§0.habet(§1)", "params": ["ego","k"] },
  "tabula:inLista:cpp": { "template": "faber::tabula_in_lista(§)", "params": ["ego"] },
  "tabula:inLista:py": { "template": "list(§.items())", "params": ["ego"] },
  "tabula:inLista:rs": { "template": "faber::tabula_in_lista(&§)", "params": ["ego"] },
  "tabula:inLista:ts": { "template": "[...§]", "params": ["ego"] },
  "tabula:inLista:zig": { "template": "§.inLista(§)", "params": ["ego","alloc"] },
  "tabula:inObjectum:py": { "template": "dict(§)", "params": ["ego"] },
  "tabula:inObjectum:ts": { "template": "Object.fromEntries(§)", "params": ["ego"] },
  "tabula:inObjectum:zig": { "template": "@compileError(\\\"inObjectum not implemented for Zig - Zig has no object type\\\")", "params": ["ego"] },
  "tabula:inversa:cpp": { "template": "faber::tabula_inversa(§)", "params": ["ego"] },
  "tabula:inversa:py": { "template": "{v: k for k, v in §.items()}", "params": ["ego"] },
  "tabula:inversa:rs": { "template": "faber::tabula_inversa(&§)", "params": ["ego"] },
  "tabula:inversa:ts": { "template": "new Map([...§].map(([k, v]) => [v, k]))", "params": ["ego"] },
  "tabula:inversa:zig": { "template": "@compileError(\\\"inversa not implemented for Zig - use explicit loop\\\")", "params": ["ego"] },
  "tabula:longitudo:cpp": { "template": "§.size()", "params": ["ego"] },
  "tabula:longitudo:py": { "template": "len(§)", "params": ["ego"] },
  "tabula:longitudo:rs": { "template": "§.len()", "params": ["ego"] },
  "tabula:longitudo:ts": { "template": "§.size", "params": ["ego"] },
  "tabula:longitudo:zig": { "template": "§.longitudo()", "params": ["ego"] },
  "tabula:mappaClaves:py": { "template": "{(§1)(k): v for k, v in §0.items()}", "params": ["ego","fn"] },
  "tabula:mappaClaves:ts": { "template": "new Map([...§0].map(([k, v]) => [(§1)(k), v]))", "params": ["ego","fn"] },
  "tabula:mappaClaves:zig": { "template": "@compileError(\\\"mappaClaves not implemented for Zig - use explicit loop\\\")", "params": ["ego","fn"] },
  "tabula:mappaValores:py": { "template": "{k: (§1)(v) for k, v in §0.items()}", "params": ["ego","fn"] },
  "tabula:mappaValores:ts": { "template": "new Map([...§0].map(([k, v]) => [k, (§1)(v)]))", "params": ["ego","fn"] },
  "tabula:mappaValores:zig": { "template": "@compileError(\\\"mappaValores not implemented for Zig - use explicit loop\\\")", "params": ["ego","fn"] },
  "tabula:omissa:cpp": { "template": "faber::tabula_omissa(§0, §1)", "params": ["ego","claves"] },
  "tabula:omissa:py": { "template": "{k: v for k, v in §0.items() if k not in [§1]}", "params": ["ego","claves"] },
  "tabula:omissa:rs": { "template": "faber::tabula_omissa(&§0, &§1)", "params": ["ego","claves"] },
  "tabula:omissa:ts": { "template": "new Map([...§0].filter(([k]) => ![§1].flat().includes(k)))", "params": ["ego","claves"] },
  "tabula:omissa:zig": { "template": "@compileError(\\\"omissa not implemented for Zig - use explicit loop\\\")", "params": ["ego","claves"] },
  "tabula:paria:cpp": { "template": "§", "params": ["ego"] },
  "tabula:paria:py": { "method": "items" },
  "tabula:paria:rs": { "template": "§.iter()", "params": ["ego"] },
  "tabula:paria:ts": { "method": "entries" },
  "tabula:paria:zig": { "template": "§.paria()", "params": ["ego"] },
  "tabula:pone:cpp": { "template": "§0.insert_or_assign(§1, §2)", "params": ["ego","k","v"] },
  "tabula:pone:py": { "template": "§0[§1] = §2", "params": ["ego","k","v"] },
  "tabula:pone:rs": { "template": "§0.insert(§1, §2)", "params": ["ego","k","v"] },
  "tabula:pone:ts": { "method": "set" },
  "tabula:pone:zig": { "template": "§0.pone(§3, §1, §2)", "params": ["ego","k","v","alloc"] },
  "tabula:purga:cpp": { "method": "clear" },
  "tabula:purga:py": { "method": "clear" },
  "tabula:purga:rs": { "method": "clear" },
  "tabula:purga:ts": { "method": "clear" },
  "tabula:purga:zig": { "template": "§.purga()", "params": ["ego"] },
  "tabula:selecta:cpp": { "template": "faber::tabula_selecta(§0, §1)", "params": ["ego","claves"] },
  "tabula:selecta:py": { "template": "{k: v for k, v in §0.items() if k in [§1]}", "params": ["ego","claves"] },
  "tabula:selecta:rs": { "template": "faber::tabula_selecta(&§0, &§1)", "params": ["ego","claves"] },
  "tabula:selecta:ts": { "template": "new Map([...§0].filter(([k]) => [§1].flat().includes(k)))", "params": ["ego","claves"] },
  "tabula:selecta:zig": { "template": "@compileError(\\\"selecta not implemented for Zig - use explicit loop\\\")", "params": ["ego","claves"] },
  "tabula:vacua:cpp": { "template": "§.empty()", "params": ["ego"] },
  "tabula:vacua:py": { "template": "len(§) == 0", "params": ["ego"] },
  "tabula:vacua:rs": { "template": "§.is_empty()", "params": ["ego"] },
  "tabula:vacua:ts": { "template": "§.size === 0", "params": ["ego"] },
  "tabula:vacua:zig": { "template": "§.vacua()", "params": ["ego"] },
  "tabula:valores:cpp": { "template": "§ | std::views::values", "params": ["ego"] },
  "tabula:valores:py": { "method": "values" },
  "tabula:valores:rs": { "template": "§.values()", "params": ["ego"] },
  "tabula:valores:ts": { "method": "values" },
  "tabula:valores:zig": { "template": "§.valores()", "params": ["ego"] },
  "tempus:DIES:cpp": { "template": "86400000" },
  "tempus:DIES:py": { "template": "86400000" },
  "tempus:DIES:rs": { "template": "86400000_i64" },
  "tempus:DIES:ts": { "template": "86400000" },
  "tempus:DIES:zig": { "template": "86400000" },
  "tempus:HORA:cpp": { "template": "3600000" },
  "tempus:HORA:py": { "template": "3600000" },
  "tempus:HORA:rs": { "template": "3600000_i64" },
  "tempus:HORA:ts": { "template": "3600000" },
  "tempus:HORA:zig": { "template": "3600000" },
  "tempus:MILLISECUNDUM:cpp": { "template": "1" },
  "tempus:MILLISECUNDUM:py": { "template": "1" },
  "tempus:MILLISECUNDUM:rs": { "template": "1_i64" },
  "tempus:MILLISECUNDUM:ts": { "template": "1" },
  "tempus:MILLISECUNDUM:zig": { "template": "1" },
  "tempus:MINUTUM:cpp": { "template": "60000" },
  "tempus:MINUTUM:py": { "template": "60000" },
  "tempus:MINUTUM:rs": { "template": "60000_i64" },
  "tempus:MINUTUM:ts": { "template": "60000" },
  "tempus:MINUTUM:zig": { "template": "60000" },
  "tempus:SECUNDUM:cpp": { "template": "1000" },
  "tempus:SECUNDUM:py": { "template": "1000" },
  "tempus:SECUNDUM:rs": { "template": "1000_i64" },
  "tempus:SECUNDUM:ts": { "template": "1000" },
  "tempus:SECUNDUM:zig": { "template": "1000" },
  "tempus:dormi:cpp": { "template": "std::this_thread::sleep_for(std::chrono::milliseconds(§))", "params": ["ms"] },
  "tempus:dormi:py": { "template": "time.sleep(§ / 1000)", "params": ["ms"] },
  "tempus:dormi:rs": { "template": "std::thread::sleep(std::time::Duration::from_millis(§ as u64))", "params": ["ms"] },
  "tempus:dormi:ts": { "template": "new Promise(r => setTimeout(r, §))", "params": ["ms"] },
  "tempus:dormi:zig": { "template": "std.time.sleep(§ * 1_000_000)", "params": ["ms"] },
  "tempus:nunc:cpp": { "template": "std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count()" },
  "tempus:nunc:py": { "template": "int(time.time() * 1000)" },
  "tempus:nunc:rs": { "template": "std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_millis() as i64" },
  "tempus:nunc:ts": { "template": "Date.now()" },
  "tempus:nunc:zig": { "template": "std.time.milliTimestamp()" },
  "tempus:nunc_nano:cpp": { "template": "std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now().time_since_epoch()).count()" },
  "tempus:nunc_nano:py": { "template": "time.time_ns()" },
  "tempus:nunc_nano:rs": { "template": "std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_nanos() as i64" },
  "tempus:nunc_nano:ts": { "template": "BigInt(Date.now()) * 1000000n" },
  "tempus:nunc_nano:zig": { "template": "std.time.nanoTimestamp()" },
  "tempus:nunc_secunda:cpp": { "template": "std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch()).count()" },
  "tempus:nunc_secunda:py": { "template": "int(time.time())" },
  "tempus:nunc_secunda:rs": { "template": "std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs() as i64" },
  "tempus:nunc_secunda:ts": { "template": "Math.floor(Date.now() / 1000)" },
  "tempus:nunc_secunda:zig": { "template": "std.time.timestamp()" },
  "textus:continet:cpp": { "template": "(§.find(§) != std::string::npos)", "params": ["ego","sub"] },
  "textus:continet:py": { "template": "§ in §", "params": ["ego","sub"] },
  "textus:continet:rs": { "method": "contains" },
  "textus:continet:ts": { "method": "includes" },
  "textus:continet:zig": { "template": "(std.mem.indexOf(u8, §, §) != null)", "params": ["ego","sub"] },
  "textus:divide:cpp": { "template": "@compileError(\\\"No single-expression split in C++ - use manual loop\\\")", "params": ["ego","sep"] },
  "textus:divide:py": { "method": "split" },
  "textus:divide:rs": { "template": "§.split(§).collect::<Vec<_>>()", "params": ["ego","sep"] },
  "textus:divide:ts": { "method": "split" },
  "textus:divide:zig": { "template": "@compileError(\\\"Use std.mem.splitSequence for Zig\\\")", "params": ["ego","sep"] },
  "textus:finis:cpp": { "template": "(§.size() >= §.size() && §.compare(§.size() - §.size(), §.size(), §) == 0)", "params": ["ego","suffix"] },
  "textus:finis:py": { "method": "endswith" },
  "textus:finis:rs": { "method": "ends_with" },
  "textus:finis:ts": { "method": "endsWith" },
  "textus:finis:zig": { "template": "std.mem.endsWith(u8, §, §)", "params": ["ego","suffix"] },
  "textus:initium:cpp": { "template": "(§.rfind(§, 0) == 0)", "params": ["ego","prefix"] },
  "textus:initium:py": { "method": "startswith" },
  "textus:initium:rs": { "method": "starts_with" },
  "textus:initium:ts": { "method": "startsWith" },
  "textus:initium:zig": { "template": "std.mem.startsWith(u8, §, §)", "params": ["ego","prefix"] },
  "textus:longitudo:cpp": { "template": "§.length()", "params": ["ego"] },
  "textus:longitudo:py": { "template": "len(§)", "params": ["ego"] },
  "textus:longitudo:rs": { "template": "§.len()", "params": ["ego"] },
  "textus:longitudo:ts": { "template": "§.length", "params": ["ego"] },
  "textus:longitudo:zig": { "template": "§.len", "params": ["ego"] },
  "textus:maiuscula:cpp": { "template": "[&]{ auto s = §; std::transform(s.begin(), s.end(), s.begin(), ::toupper); return s; }()", "params": ["ego"] },
  "textus:maiuscula:py": { "method": "upper" },
  "textus:maiuscula:rs": { "method": "to_uppercase" },
  "textus:maiuscula:ts": { "method": "toUpperCase" },
  "textus:maiuscula:zig": { "template": "std.ascii.upperString(§)", "params": ["ego"] },
  "textus:minuscula:cpp": { "template": "[&]{ auto s = §; std::transform(s.begin(), s.end(), s.begin(), ::tolower); return s; }()", "params": ["ego"] },
  "textus:minuscula:py": { "method": "lower" },
  "textus:minuscula:rs": { "method": "to_lowercase" },
  "textus:minuscula:ts": { "method": "toLowerCase" },
  "textus:minuscula:zig": { "template": "std.ascii.lowerString(§)", "params": ["ego"] },
  "textus:muta:cpp": { "template": "std::regex_replace(§, std::regex(§), §)", "params": ["ego","old","new"] },
  "textus:muta:py": { "method": "replace" },
  "textus:muta:rs": { "method": "replace" },
  "textus:muta:ts": { "method": "replaceAll" },
  "textus:muta:zig": { "template": "@compileError(\\\"Use std.mem.replace for Zig\\\")", "params": ["ego","old","new"] },
  "textus:recide:cpp": { "template": "[&]{ auto s = §; s.erase(0, s.find_first_not_of(\\\" \\\\t\\\\n\\\\r\\\")); s.erase(s.find_last_not_of(\\\" \\\\t\\\\n\\\\r\\\") + 1); return s; }()", "params": ["ego"] },
  "textus:recide:py": { "method": "strip" },
  "textus:recide:rs": { "method": "trim" },
  "textus:recide:ts": { "method": "trim" },
  "textus:recide:zig": { "template": "std.mem.trim(u8, §, \\\" \\\\t\\\\n\\\\r\\\")", "params": ["ego"] },
  "textus:sectio:cpp": { "template": "§.substr(§, § - §)", "params": ["ego","start","end"] },
  "textus:sectio:py": { "template": "§[§:§]", "params": ["ego","start","end"] },
  "textus:sectio:rs": { "template": "&§[§..§]", "params": ["ego","start","end"] },
  "textus:sectio:ts": { "method": "slice" },
  "textus:sectio:zig": { "template": "§[§..§]", "params": ["ego","start","end"] }
}
