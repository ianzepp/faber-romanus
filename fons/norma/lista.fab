# lista.fab - Standard Library lista<T> Definition
#
# Vertical slice: just `adde` for now to prove the annotation-driven codegen.
# See consilia/futura/norma-faber.md for the full design.

# =============================================================================
# TYPE MAPPING
# =============================================================================

@ innatum ts "Array", py "list", rs "Vec", cpp "std::vector", zig "Lista"
genus lista { }

# =============================================================================
# ADDING ELEMENTS
# =============================================================================

# Add element to end (mutates in place)
@ radix add, imperativus, perfectum
@ verte ts "push"
@ verte py "append"
@ verte rs "push"
@ verte cpp "push_back"
@ verte zig (ego, elem, alloc) -> "§0.adde(§2, §1)"
@ externa
functio adde(T elem) -> vacuum

# Add element to end (returns new list)
@ verte ts (ego, elem) -> "[...§, §]"
@ verte py (ego, elem) -> "[*§, §]"
@ verte rs (ego, elem) -> "faber::lista_addita(&§0, §1)"
@ verte cpp (ego, elem) -> "faber::lista_addita(§0, §1)"
@ verte zig (ego, elem, alloc) -> "§0.addita(§2, §1)"
@ externa
functio addita(T elem) -> lista<T>

# Add element to start (mutates)
@ radix praepon, imperativus, perfectum
@ verte ts "unshift"
@ verte py (ego, elem) -> "§.insert(0, §)"
@ verte rs (ego, elem) -> "§.insert(0, §)"
@ verte cpp (ego, elem) -> "§.insert(§.begin(), §)"
@ verte zig (ego, elem, alloc) -> "§0.praepone(§2, §1)"
@ externa
functio praepone(T elem) -> vacuum

# Add element to start (returns new list)
@ verte ts (ego, elem) -> "[§1, ...§0]"
@ verte py (ego, elem) -> "[§1, *§0]"
@ verte rs (ego, elem) -> "faber::lista_praeposita(&§0, §1)"
@ verte cpp (ego, elem) -> "faber::lista_praeposita(§0, §1)"
@ verte zig (ego, elem, alloc) -> "§0.praeposita(§2, §1)"
@ externa
functio praeposita(T elem) -> lista<T>

# =============================================================================
# REMOVING ELEMENTS
# =============================================================================

# Remove and return last element (mutates)
@ radix remov, imperativus, perfectum
@ verte ts "pop"
@ verte py "pop"
@ verte rs (ego) -> "§.pop()"
@ verte cpp (ego) -> "faber::lista_remove(§0)"
@ verte zig (ego) -> "§.remove()"
@ externa
functio remove() -> T?

# Remove last element (returns new list)
@ verte ts (ego) -> "§.slice(0, -1)"
@ verte py (ego) -> "§[:-1]"
@ verte rs (ego) -> "§0[..§0.len().saturating_sub(1)].to_vec()"
@ verte cpp (ego) -> "std::vector(§0.begin(), §0.end() - 1)"
@ verte zig (ego, alloc) -> "§.remota(§)"
@ externa
functio remota() -> lista<T>

# Remove and return first element (mutates)
@ radix decapit, imperativus, perfectum
@ verte ts "shift"
@ verte py (ego) -> "§.pop(0)"
@ verte rs (ego) -> "§.remove(0)"
@ verte cpp (ego) -> "faber::lista_decapita(§0)"
@ verte zig (ego) -> "§.decapita()"
@ externa
functio decapita() -> T?

# Remove first element (returns new list)
@ verte ts (ego) -> "§.slice(1)"
@ verte py (ego) -> "§[1:]"
@ verte rs (ego) -> "§[1..].to_vec()"
@ verte cpp (ego) -> "std::vector(§0.begin() + 1, §0.end())"
@ verte zig (ego, alloc) -> "§.decapitata(§)"
@ externa
functio decapitata() -> lista<T>

# Clear all elements (mutates)
@ radix purg, imperativus
@ verte ts (ego) -> "§.length = 0"
@ verte py "clear"
@ verte rs "clear"
@ verte cpp "clear"
@ verte zig (ego) -> "§.purga()"
@ externa
functio purga() -> vacuum

# =============================================================================
# ACCESSING ELEMENTS
# =============================================================================

# Get first element
@ verte ts (ego) -> "§[0]"
@ verte py (ego) -> "§[0]"
@ verte rs (ego) -> "§.first()"
@ verte cpp (ego) -> "§.front()"
@ verte zig (ego) -> "§.primus()"
@ externa
functio primus() -> T?

# Get last element
@ verte ts (ego) -> "§.at(-1)"
@ verte py (ego) -> "§[-1]"
@ verte rs (ego) -> "§.last()"
@ verte cpp (ego) -> "§.back()"
@ verte zig (ego) -> "§.ultimus()"
@ externa
functio ultimus() -> T?

# Get element at index
@ verte ts (ego, idx) -> "§[§]"
@ verte py (ego, idx) -> "§[§]"
@ verte rs (ego, idx) -> "§.get(§)"
@ verte cpp (ego, idx) -> "§.at(§)"
@ verte zig (ego, idx) -> "§.accipe(§)"
@ externa
functio accipe(numerus idx) -> T?

# =============================================================================
# PROPERTIES
# =============================================================================

# Get length
@ verte ts (ego) -> "§.length"
@ verte py (ego) -> "len(§)"
@ verte rs (ego) -> "§.len()"
@ verte cpp (ego) -> "§.size()"
@ verte zig (ego) -> "§.longitudo()"
@ externa
functio longitudo() -> numerus

# Check if empty
@ verte ts (ego) -> "§.length === 0"
@ verte py (ego) -> "len(§) == 0"
@ verte rs (ego) -> "§.is_empty()"
@ verte cpp (ego) -> "§.empty()"
@ verte zig (ego) -> "§.vacua()"
@ externa
functio vacua() -> bivalens

# =============================================================================
# SEARCHING
# =============================================================================

# Check if contains element
@ verte ts "includes"
@ verte py (ego, elem) -> "(§1 in §0)"
@ verte rs (ego, elem) -> "§0.contains(&§1)"
@ verte cpp (ego, elem) -> "(std::find(§0.begin(), §0.end(), §1) != §0.end())"
@ verte zig (ego, elem) -> "§.continet(§)"
@ externa
functio continet(T elem) -> bivalens

# Find index of element
@ verte ts "indexOf"
@ verte py (ego, elem) -> "§0.index(§1)"
@ verte rs (ego, elem) -> "§0.iter().position(|e| e == &§1)"
@ verte cpp (ego, elem) -> "faber::lista_indice_de(§0, §1)"
@ verte zig (ego, elem) -> "§.indiceDe(§)"
@ externa
functio indiceDe(T elem) -> numerus

# Find first element matching predicate
@ verte ts "find"
@ verte py (ego, pred) -> "next(filter(§1, §0), None)"
@ verte rs (ego, pred) -> "§0.iter().find(§1)"
@ verte cpp (ego, pred) -> "*std::find_if(§0.begin(), §0.end(), §1)"
@ verte zig (ego, pred) -> "§.inveni(§)"
@ externa
functio inveni((T) -> bivalens pred) -> T?

# Find index of first element matching predicate
@ verte ts "findIndex"
@ verte py (ego, pred) -> "next((i for i, x in enumerate(§0) if (§1)(x)), -1)"
@ verte rs (ego, pred) -> "§0.iter().position(§1)"
@ verte cpp (ego, pred) -> "faber::lista_inveni_indicem(§0, §1)"
@ verte zig (ego, pred) -> "§.inveniIndicem(§)"
@ externa
functio inveniIndicem((T) -> bivalens pred) -> numerus

# =============================================================================
# PREDICATES
# =============================================================================

# Check if all elements match predicate
@ verte ts "every"
@ verte py (ego, pred) -> "all(map(§, §))"
@ verte rs (ego, pred) -> "§.iter().all(§)"
@ verte cpp (ego, pred) -> "std::ranges::all_of(§, §)"
@ verte zig (ego, pred) -> "§.omnes(§)"
@ externa
functio omnes((T) -> bivalens pred) -> bivalens

# Check if any element matches predicate
@ verte ts "some"
@ verte py (ego, pred) -> "any(map(§, §))"
@ verte rs (ego, pred) -> "§.iter().any(§)"
@ verte cpp (ego, pred) -> "std::ranges::any_of(§, §)"
@ verte zig (ego, pred) -> "§.aliquis(§)"
@ externa
functio aliquis((T) -> bivalens pred) -> bivalens

# =============================================================================
# FUNCTIONAL METHODS (return new list)
# =============================================================================

# Filter elements (returns new list)
@ radix filtr, imperativus, perfectum
@ verte ts "filter"
@ verte py (ego, pred) -> "list(filter(§, §))"
@ verte rs (ego, pred) -> "§.iter().filter(§).cloned().collect::<Vec<_>>()"
@ verte cpp (ego, pred) -> "(§ | std::views::filter(§) | std::ranges::to<std::vector>())"
@ verte zig (ego, pred, alloc) -> "§0.filtrata(§2, §1)"
@ externa
functio filtrata((T) -> bivalens pred) -> lista<T>

# Map elements (returns new list)
@ radix mapp, perfectum
@ verte ts "map"
@ verte py (ego, fn) -> "list(map(§, §))"
@ verte rs (ego, fn) -> "§.iter().map(§).collect::<Vec<_>>()"
@ verte cpp (ego, fn) -> "(§ | std::views::transform(§) | std::ranges::to<std::vector>())"
@ verte zig (ego, fn, alloc) -> "§0.mappata(§2, §1)"
@ externa
functio mappata((T) -> U fn) -> lista<U>

# Flat map (map + flatten one level)
@ radix explan, perfectum
@ verte ts "flatMap"
@ verte py (ego, fn) -> "[y for x in § for y in (§)(x)]"
@ verte rs (ego, fn) -> "§.iter().flat_map(§).collect::<Vec<_>>()"
@ verte cpp (ego, fn) -> "(§ | std::views::transform(§) | std::views::join | std::ranges::to<std::vector>())"
@ externa
functio explanata((T) -> lista<U> fn) -> lista<U>

# Flatten one level
@ verte ts "flat"
@ verte py (ego) -> "[y for x in § for y in x]"
@ verte rs (ego) -> "§.iter().flatten().cloned().collect::<Vec<_>>()"
@ verte cpp (ego) -> "(§ | std::views::join | std::ranges::to<std::vector>())"
@ externa
functio plana() -> lista<T>

# Reverse (returns new list)
# WHY: Latin "invertere" has irregular participle "inversus" with stem "inver-"
@ radix inver, perfectum
@ verte ts (ego) -> "[...§].reverse()"
@ verte py (ego) -> "§[::-1]"
@ verte rs (ego) -> "§.iter().rev().cloned().collect::<Vec<_>>()"
@ verte cpp (ego) -> "faber::lista_inversa(§)"
@ verte zig (ego, alloc) -> "§.inversa(§)"
@ externa
functio inversa() -> lista<T>

# Sort (returns new list)
@ radix ordin, imperativus, perfectum
@ verte ts (ego) -> "[...§].sort()"
@ verte py (ego) -> "sorted(§)"
@ verte rs (ego) -> "faber::lista_ordinata(&§)"
@ verte cpp (ego) -> "faber::lista_ordinata(§)"
@ verte zig (ego, alloc) -> "§.ordinata(§)"
@ externa
functio ordinata() -> lista<T>

# Slice - take elements from start to end
@ verte ts "slice"
@ verte py (ego, start, end) -> "§[§:§]"
@ verte rs (ego, start, end) -> "§[§..§].to_vec()"
@ verte cpp (ego, start, end) -> "std::vector(§0.begin() + §1, §0.begin() + §2)"
@ verte zig (ego, start, end, alloc) -> "§0.sectio(§3, §1, §2)"
@ externa
functio sectio(numerus start, numerus end) -> lista<T>

# Take first n elements (returns new list)
@ verte ts (ego, n) -> "§.slice(0, §)"
@ verte py (ego, n) -> "§[:§]"
@ verte rs (ego, n) -> "§.iter().take(§).cloned().collect::<Vec<_>>()"
@ verte cpp (ego, n) -> "(§ | std::views::take(§) | std::ranges::to<std::vector>())"
@ verte zig (ego, n, alloc) -> "§0.prima(§2, §1)"
@ externa
functio prima(numerus n) -> lista<T>

# Take last n elements (returns new list)
@ verte ts (ego, n) -> "§.slice(-§)"
@ verte py (ego, n) -> "§[-§:]"
@ verte rs (ego, n) -> "faber::lista_ultima(&§0, §1)"
@ verte cpp (ego, n) -> "faber::lista_ultima(§0, §1)"
@ verte zig (ego, n, alloc) -> "§0.ultima(§2, §1)"
@ externa
functio ultima(numerus n) -> lista<T>

# Drop first n elements (returns new list)
# WHY: Latin omittere → omissus. Stem is 'omis', participle ending is '-sa'
@ radix omis, perfectum
@ verte ts (ego, n) -> "§.slice(§)"
@ verte py (ego, n) -> "§[§:]"
@ verte rs (ego, n) -> "§.iter().skip(§).cloned().collect::<Vec<_>>()"
@ verte cpp (ego, n) -> "(§ | std::views::drop(§) | std::ranges::to<std::vector>())"
@ verte zig (ego, n, alloc) -> "§0.omissa(§2, §1)"
@ externa
functio omissa(numerus n) -> lista<T>

# Reduce to single value
@ radix reduc, perfectum
@ verte ts "reduce"
@ verte py (ego, fn, init) -> "functools.reduce(§, §, §)"
@ verte rs (ego, fn, init) -> "§.iter().fold(§, §)"
@ verte cpp (ego, fn, init) -> "std::ranges::fold_left(§, §, §)"
@ verte zig (ego, fn, init) -> "§.reducta(§, §)"
@ externa
functio reducta((U, T) -> U fn, U init) -> U

# =============================================================================
# MUTATING OPERATIONS
# =============================================================================

# Filter in place (mutates)
@ radix filtr, imperativus, perfectum
@ verte ts (ego, pred) -> "(() => { for (let i = §.length - 1; i >= 0; i--) { if (!(§)(§[i])) §.splice(i, 1); } })()"
@ verte py (ego, pred) -> "§[:] = [x for x in § if (§)(x)]"
@ verte cpp (ego, pred) -> "§0.erase(std::remove_if(§0.begin(), §0.end(), [&](auto& x) { return !(§1)(x); }), §0.end())"
@ externa
functio filtra((T) -> bivalens pred) -> vacuum

# Sort in place (mutates)
@ radix ordin, imperativus, perfectum
@ verte ts (ego) -> "§.sort()"
@ verte py (ego) -> "§.sort()"
@ verte rs (ego) -> "§.sort()"
@ verte cpp (ego) -> "std::ranges::sort(§)"
@ verte zig (ego) -> "§.ordina()"
@ externa
functio ordina() -> vacuum

# Reverse in place (mutates)
# WHY: Different stem from 'inversa' due to Latin irregular participle
@ radix invert, imperativus
@ verte ts "reverse"
@ verte py (ego) -> "§.reverse()"
@ verte rs (ego) -> "§.reverse()"
@ verte cpp (ego) -> "std::ranges::reverse(§)"
@ verte zig (ego) -> "§.inverte()"
@ externa
functio inverte() -> vacuum

# =============================================================================
# ITERATION
# =============================================================================

# Iterate with callback
@ verte ts "forEach"
@ verte py (ego, fn) -> "[(§)(x) for x in §]"
@ verte rs (ego, fn) -> "§.iter().for_each(§)"
@ verte cpp (ego, fn) -> "std::ranges::for_each(§, §)"
@ verte zig (ego, fn) -> "§.perambula(§)"
@ externa
functio perambula((T) -> vacuum fn) -> vacuum

# Join elements to string
@ verte ts "join"
@ verte py (ego, sep) -> "§.join(§)"
@ verte rs (ego, sep) -> "§.join(§)"
@ verte cpp (ego, sep) -> "faber::lista_coniunge(§0, §1)"
@ externa
functio coniunge(textus sep) -> textus

# =============================================================================
# AGGREGATION
# =============================================================================

# Sum of all elements
@ verte ts (ego) -> "§.reduce((a, b) => a + b, 0)"
@ verte py (ego) -> "sum(§)"
@ verte rs (ego) -> "§.iter().sum::<i64>()"
@ verte cpp (ego) -> "std::accumulate(§0.begin(), §0.end(), 0)"
@ verte zig (ego) -> "§.summa()"
@ externa
functio summa() -> T

# Average of numeric elements
@ verte ts (ego) -> "(§0.reduce((a, b) => a + b, 0) / §0.length)"
@ verte py (ego) -> "(sum(§0) / len(§0))"
@ verte rs (ego) -> "(§0.iter().sum::<i64>() as f64 / §0.len() as f64)"
@ verte cpp (ego) -> "(std::accumulate(§0.begin(), §0.end(), 0.0) / §0.size())"
@ verte zig (ego) -> "§.medium()"
@ externa
functio medium() -> fractus

# Minimum value
@ verte ts (ego) -> "Math.min(...§)"
@ verte py (ego) -> "min(§)"
@ verte rs (ego) -> "§.iter().min()"
@ verte cpp (ego) -> "*std::ranges::min_element(§)"
@ verte zig (ego) -> "§.minimus()"
@ externa
functio minimus() -> T?

# Maximum value
@ verte ts (ego) -> "Math.max(...§)"
@ verte py (ego) -> "max(§)"
@ verte rs (ego) -> "§.iter().max()"
@ verte cpp (ego) -> "*std::ranges::max_element(§)"
@ verte zig (ego) -> "§.maximus()"
@ externa
functio maximus() -> T?

# Minimum by key function
@ verte ts (ego, fn) -> "§.reduce((min, x) => (§)(x) < (§)(min) ? x : min)"
@ verte rs (ego, fn) -> "§.iter().min_by_key(§)"
@ verte cpp (ego, fn) -> "*std::ranges::min_element(§, [&](auto& a, auto& b) { return (§)(a) < (§)(b); })"
@ externa
functio minimusPer((T) -> U fn) -> T?

# Maximum by key function
@ verte ts (ego, fn) -> "§.reduce((max, x) => (§)(x) > (§)(max) ? x : max)"
@ verte rs (ego, fn) -> "§.iter().max_by_key(§)"
@ verte cpp (ego, fn) -> "*std::ranges::max_element(§, [&](auto& a, auto& b) { return (§)(a) < (§)(b); })"
@ externa
functio maximusPer((T) -> U fn) -> T?

# Count elements matching predicate
@ verte ts (ego, pred) -> "§.filter(§).length"
@ verte py (ego, pred) -> "sum(1 for x in § if (§)(x))"
@ verte rs (ego, pred) -> "§.iter().filter(§).count()"
@ verte cpp (ego, pred) -> "std::ranges::count_if(§, §)"
@ verte zig (ego, pred) -> "§.numera(§)"
@ externa
functio numera((T) -> bivalens pred) -> numerus

# =============================================================================
# LODASH-INSPIRED METHODS
# =============================================================================

# Group by key function
@ verte ts (ego, fn) -> "Object.groupBy(§, §)"
@ verte py (ego, fn) -> "{k: list(g) for k, g in itertools.groupby(sorted(§, key=§), key=§)}"
@ verte rs (ego, fn) -> "faber::lista_congrega(&§0, §1)"
@ verte cpp (ego, fn) -> "faber::lista_congrega(§0, §1)"
@ externa
functio congrega((T) -> K fn) -> tabula<K, lista<T>>

# Remove duplicates
@ verte ts (ego) -> "[...new Set(§)]"
@ verte py (ego) -> "list(dict.fromkeys(§))"
@ verte rs (ego) -> "faber::lista_unica(&§)"
@ verte cpp (ego) -> "faber::lista_unica(§)"
@ externa
functio unica() -> lista<T>

# Flatten all levels
@ verte ts (ego) -> "§.flat(Infinity)"
@ verte cpp (ego) -> "(§ | std::views::join | std::ranges::to<std::vector>())"
@ externa
functio planaOmnia() -> lista<T>

# Split into chunks of size n
@ verte ts (ego, n) -> "Array.from({ length: Math.ceil(§.length / §) }, (_, i) => §.slice(i * §, i * § + §))"
@ verte py (ego, n) -> "[§[i:i+§] for i in range(0, len(§), §)]"
@ verte rs (ego, n) -> "§.chunks(§).map(|c| c.to_vec()).collect::<Vec<_>>()"
@ verte cpp (ego, n) -> "faber::lista_fragmenta(§0, §1)"
@ externa
functio fragmenta(numerus n) -> lista<lista<T>>

# Remove falsy values
@ verte ts (ego) -> "§.filter(Boolean)"
@ verte py (ego) -> "[x for x in § if x]"
@ verte cpp (ego) -> "(§ | std::views::filter([](auto& x) { return static_cast<bool>(x); }) | std::ranges::to<std::vector>())"
@ externa
functio densa() -> lista<T>

# Partition by predicate (returns tuple [truthy, falsy])
@ verte ts (ego, pred) -> "§.reduce(([t, f], x) => (§)(x) ? [[...t, x], f] : [t, [...f, x]], [[], []])"
@ verte py (ego, pred) -> "[[x for x in § if (§)(x)], [x for x in § if not (§)(x)]]"
@ verte rs (ego, pred) -> "faber::lista_partire(&§0, §1)"
@ verte cpp (ego, pred) -> "faber::lista_partire(§0, §1)"
@ externa
functio partire((T) -> bivalens pred) -> lista<lista<T>>

# Shuffle (returns new list)
@ radix misc, perfectum
@ verte ts (ego) -> "(() => { const a = [...§]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; })()"
@ verte py (ego) -> "random.shuffle(§)"
@ verte cpp (ego) -> "faber::lista_miscita(§)"
@ externa
functio miscita() -> lista<T>

# Random element
@ verte ts (ego) -> "§0[Math.floor(Math.random() * §0.length)]"
@ verte py (ego) -> "random.choice(§)"
@ verte cpp (ego) -> "faber::lista_specimen(§0)"
@ externa
functio specimen() -> T

# Random n elements
@ verte ts (ego, n) -> "(() => { const a = [...§]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a.slice(0, §); })()"
@ verte py (ego, n) -> "random.sample(§, §)"
@ verte cpp (ego, n) -> "faber::lista_specimina(§0, §1)"
@ externa
functio specimina(numerus n) -> lista<T>
