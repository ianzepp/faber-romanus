# aleator.fab - Random Number Generation
#
# Etymology: "dice player, gambler" - games of chance.

# =============================================================================
# TYPE MAPPING
# =============================================================================

@ innatum ts "crypto", py "random", rs "rand", cpp "random", zig "std.rand"
genus aleator { }

# =============================================================================
# BASIC GENERATION
# =============================================================================

# Random float in [0, 1)
@ verte ts () -> "Math.random()"
@ verte py () -> "random.random()"
@ verte rs () -> "rand::random::<f64>()"
@ verte cpp () -> "[&]{ std::random_device rd; std::mt19937 gen(rd()); std::uniform_real_distribution<> dis(0.0, 1.0); return dis(gen); }()"
@ verte zig () -> "blk: { var seed: u64 = undefined; std.crypto.random.bytes(std.mem.asBytes(&seed)); var prng = std.rand.DefaultPrng.init(seed); break :blk prng.random().float(f64); }"
@ externa
functio fractus() -> fractus

# Random integer in [min, max]
@ verte ts (min, max) -> "Math.floor(Math.random() * (§1 - §0 + 1)) + §0"
@ verte py (min, max) -> "random.randint(§0, §1)"
@ verte rs (min, max) -> "rand::thread_rng().gen_range(§0..=§1)"
@ verte cpp (min, max) -> "[&]{ std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution<> dis(§0, §1); return dis(gen); }()"
@ verte zig (min, max) -> "blk: { var seed: u64 = undefined; std.crypto.random.bytes(std.mem.asBytes(&seed)); var prng = std.rand.DefaultPrng.init(seed); break :blk prng.random().intRangeAtMost(i64, §0, §1); }"
@ externa
functio inter(numerus min, numerus max) -> numerus

# Random bytes
@ verte ts (n) -> "crypto.getRandomValues(new Uint8Array(§))"
@ verte py (n) -> "secrets.token_bytes(§)"
@ verte rs (n) -> "{ let mut bytes = vec![0u8; §]; rand::thread_rng().fill(&mut bytes[..]); bytes }"
@ verte cpp (n) -> "[&]{ std::vector<uint8_t> bytes(§); std::random_device rd; for (auto& b : bytes) b = static_cast<uint8_t>(rd()); return bytes; }()"
@ verte zig (n, alloc) -> "blk: { var buf = §1.alloc(u8, §0) catch unreachable; std.crypto.random.bytes(buf); break :blk buf; }"
@ externa
functio octeti(numerus n) -> octeti

# UUID v4 string
@ verte ts () -> "crypto.randomUUID()"
@ verte py () -> "str(uuid.uuid4())"
@ verte rs () -> "uuid::Uuid::new_v4().to_string()"
@ verte cpp () -> "[&]{ std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution<> dis(0, 15); auto hex = [](int n) { return \"0123456789abcdef\"[n]; }; std::string uuid; for (int i = 0; i < 36; ++i) { if (i == 8 || i == 13 || i == 18 || i == 23) uuid += '-'; else if (i == 14) uuid += '4'; else if (i == 19) uuid += hex((dis(gen) & 0x3) | 0x8); else uuid += hex(dis(gen)); } return uuid; }()"
@ verte zig () -> "blk: { var buf: [36]u8 = undefined; var bytes: [16]u8 = undefined; std.crypto.random.bytes(&bytes); bytes[6] = (bytes[6] & 0x0f) | 0x40; bytes[8] = (bytes[8] & 0x3f) | 0x80; const hex = \"0123456789abcdef\"; var i: usize = 0; for (bytes, 0..) |b, j| { if (j == 4 or j == 6 or j == 8 or j == 10) { buf[i] = '-'; i += 1; } buf[i] = hex[b >> 4]; buf[i + 1] = hex[b & 0x0f]; i += 2; } break :blk buf; }"
@ externa
functio uuid() -> textus

# =============================================================================
# COLLECTION OPERATIONS
# =============================================================================

# Random element from list
@ verte ts (lista) -> "§[Math.floor(Math.random() * §.length)]"
@ verte py (lista) -> "random.choice(§)"
@ verte rs (lista) -> "§.choose(&mut rand::thread_rng()).unwrap().clone()"
@ verte cpp (lista) -> "[&]{ std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution<size_t> dis(0, §.size() - 1); return §[dis(gen)]; }()"
@ verte zig (lista) -> "blk: { var seed: u64 = undefined; std.crypto.random.bytes(std.mem.asBytes(&seed)); var prng = std.rand.DefaultPrng.init(seed); break :blk §[prng.random().uintLessThan(usize, §.len)]; }"
@ externa
functio selige(lista<T> lista) -> T

# Shuffled copy of list
@ verte ts (lista) -> "(() => { const a = [...§]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; })()"
@ verte py (lista) -> "random.sample(§, len(§))"
@ verte rs (lista) -> "{ let mut v = §.clone(); v.shuffle(&mut rand::thread_rng()); v }"
@ verte cpp (lista) -> "[&]{ auto v = §; std::random_device rd; std::mt19937 gen(rd()); std::ranges::shuffle(v, gen); return v; }()"
@ verte zig (lista, alloc) -> "blk: { var seed: u64 = undefined; std.crypto.random.bytes(std.mem.asBytes(&seed)); var prng = std.rand.DefaultPrng.init(seed); var copy = §1.dupe(@TypeOf(§0[0]), §0) catch unreachable; prng.random().shuffle(@TypeOf(copy[0]), copy); break :blk copy; }"
@ externa
functio misce(lista<T> lista) -> lista<T>

# =============================================================================
# SEEDING
# =============================================================================

# Seed the RNG (no-op on some targets)
@ verte ts (n) -> "undefined /* JS Math.random is not seedable */"
@ verte py (n) -> "random.seed(§)"
@ verte rs (n) -> "/* seed(§) - use rand::SeedableRng for reproducible results */"
@ verte cpp (n) -> "/* seed(§) - C++ requires explicit generator management */"
@ verte zig (n) -> "@compileLog(\"seed(§) - Zig requires explicit PRNG state management\")"
@ externa
functio semen(numerus n) -> vacuum
