# textus.fab - Standard Library textus (string) Definition
#
# Provides Latin method translations for string operations.

# =============================================================================
# TYPE MAPPING
# =============================================================================

@ innatum ts "string", py "str", rs "&str", cpp "std::string", zig "[]const u8"
genus textus { }

# =============================================================================
# LENGTH
# =============================================================================

# Get string length
@ verte ts (ego) -> "§.length"
@ verte py (ego) -> "len(§)"
@ verte rs (ego) -> "§.len()"
@ verte cpp (ego) -> "§.length()"
@ verte zig (ego) -> "§.len"
@ externa
functio longitudo() -> numerus

# =============================================================================
# SLICING
# =============================================================================

# Get substring from start to end (exclusive)
@ verte ts "slice"
@ verte py (ego, start, end) -> "§[§:§]"
@ verte rs (ego, start, end) -> "&§[§..§]"
@ verte cpp (ego, start, end) -> "§.substr(§, § - §)"
@ verte zig (ego, start, end) -> "§[§..§]"
@ externa
functio sectio(numerus start, numerus end) -> textus

# =============================================================================
# SEARCHING
# =============================================================================

# Check if string contains substring
@ verte ts "includes"
@ verte py (ego, sub) -> "§ in §"
@ verte rs "contains"
@ verte cpp (ego, sub) -> "(§.find(§) != std::string::npos)"
@ verte zig (ego, sub) -> "(std.mem.indexOf(u8, §, §) != null)"
@ externa
functio continet(textus sub) -> bivalens

# Check if string starts with prefix
@ verte ts "startsWith"
@ verte py "startswith"
@ verte rs "starts_with"
@ verte cpp (ego, prefix) -> "(§.rfind(§, 0) == 0)"
@ verte zig (ego, prefix) -> "std.mem.startsWith(u8, §, §)"
@ externa
functio initium(textus prefix) -> bivalens

# Check if string ends with suffix
@ verte ts "endsWith"
@ verte py "endswith"
@ verte rs "ends_with"
@ verte cpp (ego, suffix) -> "(§.size() >= §.size() && §.compare(§.size() - §.size(), §.size(), §) == 0)"
@ verte zig (ego, suffix) -> "std.mem.endsWith(u8, §, §)"
@ externa
functio finis(textus suffix) -> bivalens

# =============================================================================
# CASE CONVERSION
# =============================================================================

# Convert to uppercase
@ verte ts "toUpperCase"
@ verte py "upper"
@ verte rs "to_uppercase"
@ verte cpp (ego) -> "[&]{ auto s = §; std::transform(s.begin(), s.end(), s.begin(), ::toupper); return s; }()"
@ verte zig (ego) -> "std.ascii.upperString(§)"
@ externa
functio maiuscula() -> textus

# Convert to lowercase
@ verte ts "toLowerCase"
@ verte py "lower"
@ verte rs "to_lowercase"
@ verte cpp (ego) -> "[&]{ auto s = §; std::transform(s.begin(), s.end(), s.begin(), ::tolower); return s; }()"
@ verte zig (ego) -> "std.ascii.lowerString(§)"
@ externa
functio minuscula() -> textus

# =============================================================================
# TRIMMING
# =============================================================================

# Trim whitespace from both ends
@ verte ts "trim"
@ verte py "strip"
@ verte rs "trim"
@ verte cpp (ego) -> "[&]{ auto s = §; s.erase(0, s.find_first_not_of(\" \\t\\n\\r\")); s.erase(s.find_last_not_of(\" \\t\\n\\r\") + 1); return s; }()"
@ verte zig (ego) -> "std.mem.trim(u8, §, \" \\t\\n\\r\")"
@ externa
functio recide() -> textus

# =============================================================================
# SPLITTING
# =============================================================================

# Split by separator
@ verte ts "split"
@ verte py "split"
@ verte rs (ego, sep) -> "§.split(§).collect::<Vec<_>>()"
@ verte cpp (ego, sep) -> "@compileError(\"No single-expression split in C++ - use manual loop\")"
@ verte zig (ego, sep) -> "@compileError(\"Use std.mem.splitSequence for Zig\")"
@ externa
functio divide(textus sep) -> lista<textus>

# =============================================================================
# REPLACEMENT
# =============================================================================

# Replace all occurrences
@ verte ts "replaceAll"
@ verte py "replace"
@ verte rs "replace"
@ verte cpp (ego, old, new) -> "std::regex_replace(§, std::regex(§), §)"
@ verte zig (ego, old, new) -> "@compileError(\"Use std.mem.replace for Zig\")"
@ externa
functio muta(textus vetus, textus novum) -> textus
