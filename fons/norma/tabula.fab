# tabula.fab - Standard Library tabula<K,V> Definition
#
# Etymology: "board, tablet, table" - a writing surface with entries.
# Feminine noun, so participle endings use -a (e.g., inversa, not inversus).

# =============================================================================
# TYPE MAPPING
# =============================================================================

@ innatum ts "Map", py "dict", rs "HashMap", cpp "std::unordered_map", zig "Tabula"
genus tabula { }

# =============================================================================
# CORE OPERATIONS
# =============================================================================

# Set key-value pair (mutates)
@ verte ts "set"
@ verte py (ego, k, v) -> "§0[§1] = §2"
@ verte rs (ego, k, v) -> "§0.insert(§1, §2)"
@ verte cpp (ego, k, v) -> "§0.insert_or_assign(§1, §2)"
@ verte zig (ego, k, v, alloc) -> "§0.pone(§3, §1, §2)"
@ externa
functio pone(K clavis, V valor) -> vacuum

# Get value by key
@ verte ts "get"
@ verte py (ego, k) -> "§0.get(§1)"
@ verte rs (ego, k) -> "§0.get(&§1)"
@ verte cpp (ego, k) -> "§0.at(§1)"
@ verte zig (ego, k) -> "§0.accipe(§1)"
@ externa
functio accipe(K clavis) -> V?

# Get value or return default
@ verte ts (ego, k, def) -> "(§0.get(§1) ?? §2)"
@ verte py (ego, k, def) -> "§0.get(§1, §2)"
@ verte rs (ego, k, def) -> "§0.get(&§1).cloned().unwrap_or(§2)"
@ verte cpp (ego, k, def) -> "(§0.contains(§1) ? §0.at(§1) : §2)"
@ verte zig (ego, k, def) -> "§0.accipeAut(§1, §2)"
@ externa
functio accipeAut(K clavis, V defalta) -> V

# Check if key exists
@ verte ts "has"
@ verte py (ego, k) -> "(§1 in §0)"
@ verte rs (ego, k) -> "§0.contains_key(&§1)"
@ verte cpp (ego, k) -> "§0.contains(§1)"
@ verte zig (ego, k) -> "§0.habet(§1)"
@ externa
functio habet(K clavis) -> bivalens

# Delete key (mutates)
@ verte ts "delete"
@ verte py (ego, k) -> "del §0[§1]"
@ verte rs (ego, k) -> "§0.remove(&§1)"
@ verte cpp (ego, k) -> "§0.erase(§1)"
@ verte zig (ego, k) -> "_ = §0.dele(§1)"
@ externa
functio dele(K clavis) -> bivalens

# Get size
@ verte ts (ego) -> "§.size"
@ verte py (ego) -> "len(§)"
@ verte rs (ego) -> "§.len()"
@ verte cpp (ego) -> "§.size()"
@ verte zig (ego) -> "§.longitudo()"
@ externa
functio longitudo() -> numerus

# Check if empty
@ verte ts (ego) -> "§.size === 0"
@ verte py (ego) -> "len(§) == 0"
@ verte rs (ego) -> "§.is_empty()"
@ verte cpp (ego) -> "§.empty()"
@ verte zig (ego) -> "§.vacua()"
@ externa
functio vacua() -> bivalens

# Clear all entries (mutates)
@ verte ts "clear"
@ verte py "clear"
@ verte rs "clear"
@ verte cpp "clear"
@ verte zig (ego) -> "§.purga()"
@ externa
functio purga() -> vacuum

# =============================================================================
# ITERATION
# =============================================================================

# Get keys iterator
@ verte ts "keys"
@ verte py "keys"
@ verte rs (ego) -> "§.keys()"
@ verte cpp (ego) -> "§ | std::views::keys"
@ verte zig (ego) -> "§.claves()"
@ externa
functio claves() -> cursor<K>

# Get values iterator
@ verte ts "values"
@ verte py "values"
@ verte rs (ego) -> "§.values()"
@ verte cpp (ego) -> "§ | std::views::values"
@ verte zig (ego) -> "§.valores()"
@ externa
functio valores() -> cursor<V>

# Get entries iterator
@ verte ts "entries"
@ verte py "items"
@ verte rs (ego) -> "§.iter()"
@ verte cpp (ego) -> "§"
@ verte zig (ego) -> "§.paria()"
@ externa
functio paria() -> cursor<par<K, V>>

# =============================================================================
# ADVANCED OPERATIONS
# =============================================================================

# Keep only specified keys (returns new map)
@ verte ts (ego, claves) -> "new Map([...§0].filter(([k]) => [§1].flat().includes(k)))"
@ verte py (ego, claves) -> "{k: v for k, v in §0.items() if k in [§1]}"
@ verte zig (ego, claves) -> "@compileError(\"selige not implemented for Zig - use explicit loop\")"
@ externa
functio selige(lista<K> claves) -> tabula<K, V>

# Remove specified keys (returns new map)
@ verte ts (ego, claves) -> "new Map([...§0].filter(([k]) => ![§1].flat().includes(k)))"
@ verte py (ego, claves) -> "{k: v for k, v in §0.items() if k not in [§1]}"
@ verte zig (ego, claves) -> "@compileError(\"omitte not implemented for Zig - use explicit loop\")"
@ externa
functio omitte(lista<K> claves) -> tabula<K, V>

# Merge maps (returns new map)
@ verte ts (ego, alia) -> "new Map([...§0, ...§1])"
@ verte py (ego, alia) -> "{**§0, **§1}"
@ verte rs (ego, alia) -> "{ let mut m = §0.clone(); m.extend(§1.iter().map(|(k, v)| (k.clone(), v.clone()))); m }"
@ verte cpp (ego, alia) -> "[&]{ auto r = §0; for (auto& [k, v] : §1) r[k] = v; return r; }()"
@ verte zig (ego, alia) -> "§0.confla(&§1)"
@ externa
functio confla(tabula<K, V> alia) -> tabula<K, V>

# Swap keys and values (returns new map)
@ verte ts (ego) -> "new Map([...§].map(([k, v]) => [v, k]))"
@ verte py (ego) -> "{v: k for k, v in §.items()}"
@ verte zig (ego) -> "@compileError(\"inversa not implemented for Zig - use explicit loop\")"
@ externa
functio inversa() -> tabula<V, K>

# Transform values (returns new map)
@ verte ts (ego, fn) -> "new Map([...§0].map(([k, v]) => [k, (§1)(v)]))"
@ verte py (ego, fn) -> "{k: (§1)(v) for k, v in §0.items()}"
@ verte zig (ego, fn) -> "@compileError(\"mappaValores not implemented for Zig - use explicit loop\")"
@ externa
functio mappaValores((V) -> U fn) -> tabula<K, U>

# Transform keys (returns new map)
@ verte ts (ego, fn) -> "new Map([...§0].map(([k, v]) => [(§1)(k), v]))"
@ verte py (ego, fn) -> "{(§1)(k): v for k, v in §0.items()}"
@ verte zig (ego, fn) -> "@compileError(\"mappaClaves not implemented for Zig - use explicit loop\")"
@ externa
functio mappaClaves((K) -> J fn) -> tabula<J, V>

# =============================================================================
# CONVERSIONS
# =============================================================================

# Convert to list of [key, value] pairs
@ verte ts (ego) -> "[...§]"
@ verte py (ego) -> "list(§.items())"
@ verte rs (ego) -> "§.iter().map(|(k, v)| (k.clone(), v.clone())).collect::<Vec<_>>()"
@ verte cpp (ego) -> "std::vector(§.begin(), §.end())"
@ verte zig (ego, alloc) -> "§.inLista(§)"
@ externa
functio inLista() -> lista<par<K, V>>

# Convert to object (JS/Python only)
@ verte ts (ego) -> "Object.fromEntries(§)"
@ verte py (ego) -> "dict(§)"
@ verte zig (ego) -> "@compileError(\"inObjectum not implemented for Zig - Zig has no object type\")"
@ externa
functio inObjectum() -> objectum
