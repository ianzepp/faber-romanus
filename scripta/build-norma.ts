#!/usr/bin/env bun
/**
 * Build script: Generate norma-registry.gen.ts from fons/norma/*.fab
 *
 * WHY: Generates registry at build time using Faber's parser.
 * The parser attaches annotations directly to AST nodes.
 *
 * Usage: bun run build:norma
 */

import { readdir, readFile, writeFile } from 'fs/promises';
import { join } from 'path';

// WHY: Use Faber's actual parser - no hacky regex needed
import { tokenize } from '../fons/faber/tokenizer';
import { parse } from '../fons/faber/parser';
import type { Annotation, FunctioDeclaration, GenusDeclaration, Program } from '../fons/faber/parser/ast';

// =============================================================================
// TYPES
// =============================================================================

interface VerteTranslation {
    method?: string;
    template?: string;
    params?: string[];
}

interface MethodDef {
    name: string;
    translations: Map<string, VerteTranslation>;
    radixForms?: string[];
}

interface CollectionDef {
    name: string;
    innatum: Map<string, string>;
    methods: Map<string, MethodDef>;
}

// =============================================================================
// AST WALKER
// =============================================================================

function extractCollections(ast: Program): CollectionDef[] {
    const collections: CollectionDef[] = [];
    let currentCollection: CollectionDef | null = null;

    for (const stmt of ast.body) {
        // Look for genus declarations with @ innatum
        if (stmt.type === 'GenusDeclaration') {
            const genus = stmt as GenusDeclaration;
            const innatum = findInnatum(genus.annotations);

            if (innatum) {
                currentCollection = {
                    name: genus.name.name,
                    innatum,
                    methods: new Map(),
                };
                collections.push(currentCollection);
            }
        }

        // Look for functio declarations with @ verte
        if (stmt.type === 'FunctioDeclaration' && currentCollection) {
            const func = stmt as FunctioDeclaration;
            const methodDef = extractMethod(func);

            if (methodDef) {
                currentCollection.methods.set(methodDef.name, methodDef);
            }
        }
    }

    return collections;
}

function findInnatum(annotations?: Annotation[]): Map<string, string> | null {
    if (!annotations) return null;

    for (const ann of annotations) {
        if (ann.name === 'innatum' && ann.targetMappings) {
            return ann.targetMappings;
        }
    }
    return null;
}

function extractMethod(func: FunctioDeclaration): MethodDef | null {
    if (!func.annotations || func.annotations.length === 0) return null;

    const translations = new Map<string, VerteTranslation>();
    let radixForms: string[] | undefined;

    for (const ann of func.annotations) {
        if (ann.name === 'verte' && ann.verteTarget) {
            const trans: VerteTranslation = {};

            if (ann.verteMethod) {
                trans.method = ann.verteMethod;
            }
            else if (ann.verteTemplate && ann.verteParams) {
                trans.template = ann.verteTemplate;
                trans.params = ann.verteParams;
            }

            if (trans.method || trans.template) {
                translations.set(ann.verteTarget, trans);
            }
        }

        if (ann.name === 'radix' && ann.radixForms) {
            radixForms = ann.radixForms;
        }
    }

    if (translations.size === 0) return null;

    const method: MethodDef = {
        name: func.name.name,
        translations,
    };

    if (radixForms) {
        method.radixForms = radixForms;
    }

    return method;
}

// =============================================================================
// TYPESCRIPT CODE GENERATOR (for Faber)
// =============================================================================

function generateRegistryCode(collections: CollectionDef[]): string {
    const lines: string[] = [];

    lines.push('/**');
    lines.push(' * AUTO-GENERATED FILE - DO NOT EDIT');
    lines.push(' * Generated by: bun run build:norma');
    lines.push(' * Source: fons/norma/*.fab');
    lines.push(` * Generated: ${new Date().toISOString()}`);
    lines.push(' */');
    lines.push('');
    lines.push("import type { NormaCollection } from './norma-registry';");
    lines.push('');
    lines.push('export const registry: Map<string, NormaCollection> = new Map([');

    for (const coll of collections) {
        lines.push(`    ['${coll.name}', {`);
        lines.push(`        name: '${coll.name}',`);

        lines.push('        innatum: new Map([');
        for (const [target, type] of coll.innatum) {
            lines.push(`            ['${target}', '${type}'],`);
        }
        lines.push('        ]),');

        lines.push('        methods: new Map([');
        for (const [methodName, method] of coll.methods) {
            lines.push(`            ['${methodName}', {`);
            lines.push(`                name: '${methodName}',`);
            lines.push('                translations: new Map([');
            for (const [target, trans] of method.translations) {
                if (trans.method) {
                    lines.push(`                    ['${target}', { method: '${trans.method}' }],`);
                }
                else if (trans.template && trans.params) {
                    const paramsStr = trans.params.map(p => `'${p}'`).join(', ');
                    const templateEsc = trans.template.replace(/'/g, "\\'");
                    lines.push(`                    ['${target}', { template: '${templateEsc}', params: [${paramsStr}] }],`);
                }
            }
            lines.push('                ]),');
            if (method.radixForms && method.radixForms.length > 0) {
                const formsStr = method.radixForms.map(f => `'${f}'`).join(', ');
                lines.push(`                radixForms: [${formsStr}],`);
            }
            lines.push('            }],');
        }
        lines.push('        ]),');
        lines.push('    }],');
    }

    lines.push(']);');
    lines.push('');

    return lines.join('\n');
}

// =============================================================================
// FABER CODE GENERATOR (for Rivus)
// =============================================================================

function generateFaberCode(collections: CollectionDef[]): string {
    const lines: string[] = [];

    lines.push('# AUTO-GENERATED FILE - DO NOT EDIT');
    lines.push('# Generated by: bun run build:norma');
    lines.push('# Source: fons/norma/*.fab');
    lines.push(`# Generated: ${new Date().toISOString()}`);
    lines.push('');
    lines.push('# Translation result type');
    lines.push('@ publicum');
    lines.push('genus VerteTranslation {');
    lines.push('    textus? method');
    lines.push('    textus? template');
    lines.push('    lista<textus>? params');
    lines.push('}');
    lines.push('');
    lines.push('# Lookup translation for target/collection/method');
    lines.push('@ publica');
    lines.push('functio getNormaTranslation(textus target, textus collection, textus method) fit VerteTranslation? {');
    lines.push('    elige collection {');

    for (const coll of collections) {
        lines.push(`        casu "${coll.name}" {`);
        lines.push('            elige method {');

        for (const [methodName, method] of coll.methods) {
            lines.push(`                casu "${methodName}" {`);
            lines.push('                    elige target {');

            for (const [target, trans] of method.translations) {
                if (trans.method) {
                    lines.push(`                        casu "${target}" reddit novum VerteTranslation { method: "${trans.method}" }`);
                }
                else if (trans.template && trans.params) {
                    const paramsStr = trans.params.map(p => `"${p}"`).join(', ');
                    // WHY: Templates already have proper escaping from parser (preserves \" as-is)
                    lines.push(`                        casu "${target}" reddit novum VerteTranslation { template: "${trans.template}", params: [${paramsStr}] }`);
                }
            }

            lines.push('                    }');
            lines.push('                }');
        }

        lines.push('            }');
        lines.push('        }');
    }

    lines.push('    }');
    lines.push('    redde nihil');
    lines.push('}');
    lines.push('');

    return lines.join('\n');
}

// =============================================================================
// JSON GENERATOR (flat key structure)
// =============================================================================

interface JsonEntry {
    // Collection-level (1 part key: "lista")
    innatum?: Record<string, string>;
    // Method-level (2 part key: "lista:adde")
    radixForms?: string[];
    // Translation-level (3 part key: "lista:adde:ts")
    method?: string;
    template?: string;
    params?: string[];
}

function generateJsonRegistry(collections: CollectionDef[]): string {
    const registry: Record<string, JsonEntry> = {};

    for (const coll of collections) {
        // Collection-level: innatum
        if (coll.innatum.size > 0) {
            const innatum: Record<string, string> = {};
            for (const [target, type] of coll.innatum) {
                innatum[target] = type;
            }
            registry[coll.name] = { innatum };
        }

        for (const [methodName, method] of coll.methods) {
            // Method-level: radixForms
            if (method.radixForms && method.radixForms.length > 0) {
                registry[`${coll.name}:${methodName}`] = { radixForms: method.radixForms };
            }

            // Translation-level: method/template/params
            for (const [target, trans] of method.translations) {
                const key = `${coll.name}:${methodName}:${target}`;
                const entry: JsonEntry = {};

                if (trans.method) {
                    entry.method = trans.method;
                }
                if (trans.template) {
                    entry.template = trans.template;
                }
                if (trans.params && trans.params.length > 0) {
                    entry.params = trans.params;
                }

                registry[key] = entry;
            }
        }
    }

    const lines: string[] = ['{'];
    const sortedKeys = Object.keys(registry).sort();

    for (let i = 0; i < sortedKeys.length; i++) {
        const key = sortedKeys[i]!;
        const entry = registry[key]!;
        const parts: string[] = [];

        if (entry.innatum) {
            parts.push(`"innatum": ${JSON.stringify(entry.innatum)}`);
        }
        if (entry.radixForms) {
            parts.push(`"radixForms": ${JSON.stringify(entry.radixForms)}`);
        }
        if (entry.method) {
            parts.push(`"method": ${JSON.stringify(entry.method)}`);
        }
        if (entry.template) {
            parts.push(`"template": ${JSON.stringify(entry.template)}`);
        }
        if (entry.params && entry.params.length > 0) {
            parts.push(`"params": ${JSON.stringify(entry.params)}`);
        }

        const comma = i < sortedKeys.length - 1 ? ',' : '';
        lines.push(`  ${JSON.stringify(key)}: { ${parts.join(', ')} }${comma}`);
    }

    lines.push('}');
    return lines.join('\n') + '\n';
}

// =============================================================================
// MAIN
// =============================================================================

async function main() {
    const normaDir = join(import.meta.dir, '..', 'fons', 'norma');
    const outputFab = join(import.meta.dir, '..', 'fons', 'rivus', 'codegen', 'norma-registry.gen.fab');
    const outputJson = join(import.meta.dir, '..', 'fons', 'norma', 'index.json');

    const files = await readdir(normaDir);
    const fabFiles = files.filter(f => f.endsWith('.fab'));

    if (fabFiles.length === 0) {
        console.error('No .fab files found in fons/norma/');
        process.exit(1);
    }

    console.log(`Found ${fabFiles.length} norma file(s): ${fabFiles.join(', ')}`);

    const allCollections: CollectionDef[] = [];

    for (const file of fabFiles) {
        const content = await readFile(join(normaDir, file), 'utf-8');

        // WHY: Use Faber's parser to get proper AST with annotations
        const tokenResult = tokenize(content);
        if (tokenResult.errors.length > 0) {
            console.error(`Tokenizer errors in ${file}:`);
            for (const err of tokenResult.errors) {
                console.error(`  ${err.position.line}:${err.position.column} - ${err.text}`);
            }
            process.exit(1);
        }
        const result = parse(tokenResult.tokens);

        if (result.errors.length > 0) {
            console.error(`Parse errors in ${file}:`);
            for (const err of result.errors) {
                console.error(`  ${err.position.line}:${err.position.column} - ${err.message}`);
            }
            process.exit(1);
        }

        if (!result.program) {
            console.error(`No program generated for ${file}`);
            process.exit(1);
        }

        const collections = extractCollections(result.program);
        for (const coll of collections) {
            allCollections.push(coll);
            console.log(`  ${file}: ${coll.name} with ${coll.methods.size} method(s)`);
        }
    }

    // Generate Faber output (for Rivus)
    const fabCode = generateFaberCode(allCollections);
    await writeFile(outputFab, fabCode, 'utf-8');
    console.log(`Generated: ${outputFab}`);

    // Generate JSON output (trial flat format)
    const jsonCode = generateJsonRegistry(allCollections);
    await writeFile(outputJson, jsonCode, 'utf-8');
    console.log(`Generated: ${outputJson}`);
}

main().catch(err => {
    console.error('Error:', err);
    process.exit(1);
});
