// Norma - Faber Romanus Standard Library
//
// "Norma" (Latin: carpenter's square, rule, standard)
//
// This file is written in Faber and compiles to all targets.
// It depends on a small set of intrinsics provided by each target.

// =============================================================================
// INTRINSICS (provided by target runtime)
// =============================================================================
//
// These are "magic" functions the codegen emits directly.
// All intrinsics are prefixed with _ and wrapped by public functions.
//
// I/O:
//   _scribe(...args)         -> console.log / std.debug.print / etc.
//   _vide(...args)           -> console.debug / debug output
//   _mone(...args)           -> console.warn / warning output
//   _lege() -> textus        -> readline / stdin read
//
// Math:
//   _fortuitus() -> numerus  -> Math.random / std.rand (0.0 to 1.0)
//   _pavimentum(n) -> numerus -> Math.floor / @floor
//   _tectum(n) -> numerus     -> Math.ceil / @ceil
//   _radix(n) -> numerus      -> Math.sqrt / @sqrt
//   _potentia(base, exp) -> numerus -> Math.pow / std.math.pow

// =============================================================================
// I/O - Wrappers around intrinsics
// =============================================================================

// Print/log output
functio scribe(textus msg) {
    _scribe(msg)
}

// Debug output
functio vide(textus msg) {
    _vide(msg)
}

// Warning output
functio mone(textus msg) {
    _mone(msg)
}

// Read input line
functio lege() -> textus {
    redde _lege()
}

// =============================================================================
// ITERATION
// =============================================================================

// Generate sequence 0..n-1 (like Python's range(n))
functio series(numerus n) -> numerus[] {
    varia result = []
    varia i = 0
    dum i < n {
        result.push(i)
        i = i + 1
    }
    redde result
}

// Generate sequence start..end-1 with optional step
functio seriesAb(numerus initium, numerus finis, numerus gradus) -> numerus[] {
    varia result = []
    varia i = initium
    si gradus > 0 {
        dum i < finis {
            result.push(i)
            i = i + gradus
        }
    }
    aliter si gradus < 0 {
        dum i > finis {
            result.push(i)
            i = i + gradus
        }
    }
    redde result
}

// =============================================================================
// MATH - Wrappers around intrinsics
// =============================================================================

// Floor (round down)
functio pavimentum(numerus n) -> numerus {
    redde _pavimentum(n)
}

// Ceiling (round up)
functio tectum(numerus n) -> numerus {
    redde _tectum(n)
}

// Round to nearest integer
functio rotundus(numerus n) -> numerus {
    redde _pavimentum(n + 0.5)
}

// Square root
functio radix(numerus n) -> numerus {
    redde _radix(n)
}

// Power (exponentiation)
functio potentia(numerus basis, numerus exponens) -> numerus {
    redde _potentia(basis, exponens)
}

// =============================================================================
// MATH - Pure Faber implementations
// =============================================================================

// Absolute value
functio absolutus(numerus n) -> numerus {
    si n < 0 {
        redde 0 - n
    }
    redde n
}

// Minimum of two values
functio minimus(numerus a, numerus b) -> numerus {
    si a < b {
        redde a
    }
    redde b
}

// Maximum of two values
functio maximus(numerus a, numerus b) -> numerus {
    si a > b {
        redde a
    }
    redde b
}

// Clamp value between min and max
functio constrictus(numerus n, numerus min, numerus max) -> numerus {
    si n < min {
        redde min
    }
    si n > max {
        redde max
    }
    redde n
}

// Sign of number (-1, 0, or 1)
functio signum(numerus n) -> numerus {
    si n > 0 {
        redde 1
    }
    si n < 0 {
        redde 0 - 1
    }
    redde 0
}

// =============================================================================
// RANDOM
// =============================================================================

// Random number between 0 and 1 (wrapper around intrinsic)
functio fortuitus() -> numerus {
    redde _fortuitus()
}

// Random integer from 0 to n-1
functio fortunatus(numerus n) -> numerus {
    redde pavimentum(fortuitus() * n)
}

// Random integer from min to max (inclusive)
functio fortunatusInter(numerus min, numerus max) -> numerus {
    redde min + pavimentum(fortuitus() * (max - min + 1))
}

// =============================================================================
// TYPE CONVERSION
// =============================================================================

// These may need intrinsics depending on target capabilities
// For now, assume targets provide implicit conversion or we add intrinsics

// functio numerus(valor) -> numerus { ... }
// functio textus(valor) -> textus { ... }

// =============================================================================
// CONSTANTS
// =============================================================================

fixum PI = 3.141592653589793
fixum E = 2.718281828459045
fixum TAU = 6.283185307179586

// =============================================================================
// ARRAY UTILITIES
// =============================================================================

// Length is accessed via .length property, not a function

// Sum of numeric array
functio summa(numerus[] numeri) -> numerus {
    varia total = 0
    ex numeri pro n {
        total = total + n
    }
    redde total
}

// Product of numeric array
functio factum(numerus[] numeri) -> numerus {
    varia total = 1
    ex numeri pro n {
        total = total * n
    }
    redde total
}

// Average of numeric array
functio medium(numerus[] numeri) -> numerus {
    si numeri.length == 0 {
        redde 0
    }
    redde summa(numeri) / numeri.length
}
