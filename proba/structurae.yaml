# Structurae - Data structure codegen tests
# Covers: genus, pactum, destructuring, novum, ego, nexum

# =============================================================================
# Object Destructuring (brace-less syntax with ut aliasing)
# =============================================================================

# Extract named properties from object using ex-prefix syntax
- name: 'simple object destructuring'
  input: 'ex user fixum nomen, aetas'
  ts: 'const { nomen, aetas } = user;'
  py:
      - 'nomen = user["nomen"]'
      - 'aetas = user["aetas"]'
  zig:
      - 'const _tmp = user'
      - 'const nomen = _tmp.nomen'
      - 'const aetas = _tmp.aetas'
  cpp:
      - 'const auto& _tmp = user;'
      - 'const auto& nomen = _tmp.nomen;'
      - 'const auto& aetas = _tmp.aetas;'

# Rename during destructuring with ut (as)
- name: 'destructuring with rename'
  input: 'ex user fixum nomen ut localName'
  ts: 'const { nomen: localName } = user;'
  py:
      - 'localName = user["nomen"]'
  cpp:
      - 'const auto& _tmp = user;'
      - 'const auto& localName = _tmp.nomen;'

# Mutable destructuring uses varia
- name: 'mutable destructuring'
  input: 'ex data varia count'
  ts: 'let { count } = data;'
  cpp:
      - 'auto& _tmp = data;'
      - 'auto& count = _tmp.count;'

# =============================================================================
# Array Destructuring
# =============================================================================

# Extract elements by position
- name: 'simple array destructuring'
  input: 'fixum [a, b, c] = coords'
  ts: 'const [a, b, c] = coords;'
  py: 'a, b, c = coords'
  zig:
      - 'const _tmp = coords'
      - 'const a = _tmp[0]'
      - 'const b = _tmp[1]'
      - 'const c = _tmp[2]'
  cpp:
      - 'const auto& _tmp = coords;'
      - 'const auto& a = _tmp[0];'
      - 'const auto& b = _tmp[1];'

# ceteri collects remaining elements
- name: 'array destructuring with rest'
  input: 'fixum [first, ceteri rest] = items'
  ts: 'const [first, ...rest] = items;'
  py: 'first, *rest = items'
  zig:
      - 'const _tmp = items'
      - 'const first = _tmp[0]'
      - 'const rest = _tmp[1..]'
  cpp:
      - 'const auto& _tmp = items;'
      - 'const auto& first = _tmp[0];'
      - 'const auto rest = std::vector<decltype(_tmp)::value_type>(_tmp.begin() + 1, _tmp.end());'

# Underscore skips elements
- name: 'array destructuring with skip'
  input: 'fixum [_, second, _] = data'
  ts: 'const [, second, ] = data;'
  py: '_, second, _ = data'
  zig:
      - 'const _tmp = data'
      - 'const second = _tmp[1]'
  cpp:
      - 'const auto& _tmp = data;'
      - 'const auto& second = _tmp[1];'

# Mutable array destructuring
- name: 'mutable array destructuring'
  input: 'varia [x, y] = coords'
  ts: 'let [x, y] = coords;'
  zig:
      - 'const _tmp = coords'
      - 'var x = _tmp[0]'
      - 'var y = _tmp[1]'
  cpp:
      - 'auto& _tmp = coords;'
      - 'auto& x = _tmp[0];'
      - 'auto& y = _tmp[1];'

# ex array syntax (source first)
- name: 'ex array destructuring'
  input: 'ex coords fixum [x, y, z]'
  ts: 'const [x, y, z] = coords;'
  zig:
      - 'const _tmp = coords'
      - 'const x = _tmp[0]'
      - 'const y = _tmp[1]'
      - 'const z = _tmp[2]'
  cpp:
      - 'const auto& _tmp = coords;'
      - 'const auto& x = _tmp[0];'
      - 'const auto& y = _tmp[1];'

# ex array with rest
- name: 'ex array destructuring with rest'
  input: 'ex items fixum [first, ceteri tail]'
  ts: 'const [first, ...tail] = items;'
  cpp:
      - 'const auto& _tmp = items;'
      - 'const auto& first = _tmp[0];'
      - 'const auto tail = std::vector<decltype(_tmp)::value_type>(_tmp.begin() + 1, _tmp.end());'

# =============================================================================
# Genus (Class)
# =============================================================================

# genus generates class with auto-merge constructor
- name: 'genus with auto-merge constructor'
  input: 'genus persona { textus nomen: "X" }'
  ts:
      - 'class persona'
      - 'nomen: string = "X"'
      - 'constructor(overrides:'
      - 'if (overrides.nomen !== undefined)'
  py:
      - 'class persona:'
      - 'nomen: str = "X"'
      - 'def __init__'
  cpp:
      - 'struct persona {'
      - 'std::string nomen = '
      - '};'
  zig:
      - 'const persona = struct {'
      - 'nomen: []const u8 = "X"'
      - 'pub fn init(overrides: anytype) Self'
      - '@hasField(@TypeOf(overrides), "nomen")'

# creo becomes private method called from constructor
- name: 'genus with creo'
  input: |
      genus persona {
        numerus aetas: 0
        functio creo() {
          si ego.aetas < 0 { ego.aetas = 0 }
        }
      }
  ts:
      - 'this.creo();'
      - 'private creo()'
  py:
      - 'class persona:'
      - 'aetas: int = 0'
      - 'def __init__(self, overrides: dict = {}):'
      - "if 'aetas' in overrides:"
      - "self.aetas = overrides['aetas']"
      - 'self._creo()'
      - 'def _creo(self):'
      - 'if (self.aetas < 0):'
      - 'self.aetas = 0'
  zig:
      - 'self.creo();'
      - 'fn creo(self: *Self) void'
  cpp:
      - 'struct persona {'
      - 'int64_t aetas = 0;'
      - 'persona() = default;'

# Without creo, no creo method is generated
- name: 'genus without creo'
  input: 'genus persona { textus nomen: "X" }'
  ts:
      not_contains:
          - 'this.creo()'
          - 'private creo()'
  py:
      - 'class persona:'
      - 'nomen: str = "X"'
      - 'def __init__(self, overrides: dict = {}):'
      - "if 'nomen' in overrides:"
      - "self.nomen = overrides['nomen']"
  zig:
      not_contains:
          - 'self.creo()'
  cpp:
      - 'struct persona {'
      - 'std::string nomen = std::string("X");'
      - 'persona() = default;'

# =============================================================================
# Novum (New)
# =============================================================================

# novum creates instance - new in TS, direct call in Python
- name: 'novum without args'
  input: 'fixum p = novum persona'
  ts: 'const p = new persona();'
  py: 'p = persona()'
  cpp:
      - 'persona{}'
  zig:
      - 'persona.init(.{})'

# novum with object literal passes overrides to constructor
- name: 'novum with overrides'
  input: 'fixum p = novum persona { nomen: "Claudia" }'
  ts: 'const p = new persona({ nomen: "Claudia" });'
  py: 'p = persona({"nomen": "Claudia"})'
  cpp:
      - 'persona{.nomen = '
  zig:
      - 'persona.init(.{ .nomen = "Claudia" })'

# =============================================================================
# Ego (this/self)
# =============================================================================

# ego is this in TS, self in Python
- name: 'ego becomes this or self'
  input: |
      genus persona {
        textus nomen: "X"
        functio saluta() { redde ego.nomen }
      }
  ts:
      - 'return this.nomen'
  py:
      - 'return self.nomen'
  cpp:
      - 'void saluta()'
      - 'this->nomen'
  zig:
      - 'return self.nomen'

# =============================================================================
# Nexum (Reactive Fields) - TS only
# =============================================================================

# nexum emits private backing field
- name: 'nexum private backing field'
  input: 'genus counter { nexum numerus count: 0 }'
  ts:
      - '#count = 0;'
  py:
      - 'class counter:'
      - '_count: int = 0'
      - '@property'
      - 'def count(self) -> int:'
      - 'return self._count'
      - '@count.setter'
      - 'def count(self, value: int):'
      - 'self._count = value'
      - "if hasattr(self, '_pingo'):"
      - 'self._pingo()'
      - 'def __init__(self, overrides: dict = {}):'
      - "if 'count' in overrides:"
      - "self.count = overrides['count']"
  zig:
      - 'const counter = struct {'
      - 'count: i64 = 0,'
      - 'const Self = @This();'
      - 'pub fn init(overrides: anytype) Self {'
      - 'const self = Self{'
      - '.count = if (@hasField(@TypeOf(overrides), "count")) overrides.count else 0,'
      - '};'
      - 'return self;'
  cpp:
      - 'struct counter {'
      - 'int64_t count = 0;'
      - 'counter() = default;'

# nexum emits getter
- name: 'nexum getter'
  input: 'genus counter { nexum numerus count: 0 }'
  ts:
      - 'get count(): number { return this.#count; }'
  py:
      - 'class counter:'
      - '_count: int = 0'
      - '@property'
      - 'def count(self) -> int:'
      - 'return self._count'
      - '@count.setter'
      - 'def count(self, value: int):'
      - 'self._count = value'
      - "if hasattr(self, '_pingo'):"
      - 'self._pingo()'
      - 'def __init__(self, overrides: dict = {}):'
      - "if 'count' in overrides:"
      - "self.count = overrides['count']"
  zig:
      - 'const counter = struct {'
      - 'count: i64 = 0,'
      - 'const Self = @This();'
      - 'pub fn init(overrides: anytype) Self {'
      - 'const self = Self{'
      - '.count = if (@hasField(@TypeOf(overrides), "count")) overrides.count else 0,'
      - '};'
      - 'return self;'
  cpp:
      - 'struct counter {'
      - 'int64_t count = 0;'
      - 'counter() = default;'

# nexum emits setter with invalidation
- name: 'nexum setter with invalidation'
  input: 'genus counter { nexum numerus count: 0 }'
  ts:
      - 'set count(v: number)'
      - 'this.#count = v'
      - "__invalidate?.('count')"
  py:
      - 'class counter:'
      - '_count: int = 0'
      - '@property'
      - 'def count(self) -> int:'
      - 'return self._count'
      - '@count.setter'
      - 'def count(self, value: int):'
      - 'self._count = value'
      - "if hasattr(self, '_pingo'):"
      - 'self._pingo()'
      - 'def __init__(self, overrides: dict = {}):'
      - "if 'count' in overrides:"
      - "self.count = overrides['count']"
  zig:
      - 'const counter = struct {'
      - 'count: i64 = 0,'
      - 'const Self = @This();'
      - 'pub fn init(overrides: anytype) Self {'
      - 'const self = Self{'
      - '.count = if (@hasField(@TypeOf(overrides), "count")) overrides.count else 0,'
      - '};'
      - 'return self;'
  cpp:
      - 'struct counter {'
      - 'int64_t count = 0;'
      - 'counter() = default;'

# nexum works with different types
- name: 'nexum with textus'
  input: 'genus user { nexum textus name: "anon" }'
  ts:
      - '#name = "anon";'
      - 'get name(): string { return this.#name; }'
      - 'set name(v: string)'
  py:
      - 'class user:'
      - '_name: str = "anon"'
      - '@property'
      - 'def name(self) -> str:'
      - 'return self._name'
      - '@name.setter'
      - 'def name(self, value: str):'
      - 'self._name = value'
      - "if hasattr(self, '_pingo'):"
      - 'self._pingo()'
      - 'def __init__(self, overrides: dict = {}):'
      - "if 'name' in overrides:"
      - "self.name = overrides['name']"
  zig:
      - 'const user = struct {'
      - 'name: []const u8 = "anon",'
      - 'const Self = @This();'
      - 'pub fn init(overrides: anytype) Self {'
      - 'const self = Self{'
      - '.name = if (@hasField(@TypeOf(overrides), "name")) overrides.name else "anon",'
      - '};'
      - 'return self;'
  cpp:
      - 'struct user {'
      - 'std::string name = std::string("anon");'
      - 'user() = default;'

# nexum without initial value
- name: 'nexum without initial value'
  input: 'genus timer { nexum numerus elapsed }'
  ts:
      - '#elapsed;'
      - 'get elapsed(): number'
      - 'set elapsed(v: number)'
  py:
      - 'class timer:'
      - '_elapsed: int'
      - '@property'
      - 'def elapsed(self) -> int:'
      - 'return self._elapsed'
      - '@elapsed.setter'
      - 'def elapsed(self, value: int):'
      - 'self._elapsed = value'
      - "if hasattr(self, '_pingo'):"
      - 'self._pingo()'
      - 'def __init__(self, overrides: dict = {}):'
      - "if 'elapsed' in overrides:"
      - "self.elapsed = overrides['elapsed']"
  zig:
      - 'const timer = struct {'
      - 'elapsed: i64 = undefined,'
      - 'const Self = @This();'
      - 'pub fn init(overrides: anytype) Self {'
      - 'const self = Self{'
      - '.elapsed = if (@hasField(@TypeOf(overrides), "elapsed")) overrides.elapsed else undefined,'
      - '};'
      - 'return self;'
  cpp:
      - 'struct timer {'
      - 'int64_t elapsed;'
      - 'timer() = default;'

# Mixed nexum and regular fields
- name: 'mixed nexum and regular fields'
  input: |
      genus widget {
        textus id: "x"
        nexum numerus count: 0
        bivalens active: verum
      }
  ts:
      - 'id: string = "x";'
      - 'active: boolean = true;'
      - '#count = 0;'
      - 'get count(): number'
      - 'set count(v: number)'
  py:
      - 'class widget:'
      - 'id: str = "x"'
      - 'active: bool = True'
      - '_count: int = 0'
      - '@property'
      - 'def count(self) -> int:'
      - 'return self._count'
      - '@count.setter'
      - 'def count(self, value: int):'
      - 'self._count = value'
      - "if hasattr(self, '_pingo'):"
      - 'self._pingo()'
      - 'def __init__(self, overrides: dict = {}):'
      - "if 'id' in overrides:"
      - "self.id = overrides['id']"
      - "if 'count' in overrides:"
      - "self.count = overrides['count']"
      - "if 'active' in overrides:"
      - "self.active = overrides['active']"
  zig:
      - 'const widget = struct {'
      - 'id: []const u8 = "x",'
      - 'count: i64 = 0,'
      - 'active: bool = true,'
      - 'const Self = @This();'
      - 'pub fn init(overrides: anytype) Self {'
      - 'const self = Self{'
      - '.id = if (@hasField(@TypeOf(overrides), "id")) overrides.id else "x",'
      - '.count = if (@hasField(@TypeOf(overrides), "count")) overrides.count else 0,'
      - '.active = if (@hasField(@TypeOf(overrides), "active")) overrides.active else true,'
      - '};'
      - 'return self;'
  cpp:
      - 'struct widget {'
      - 'std::string id = std::string("x");'
      - 'int64_t count = 0;'

# =============================================================================
# Pactum (Interface/Protocol)
# =============================================================================

# pactum declares interface (interface in TS, Protocol in Python)
- name: 'pactum with method'
  input: |
      pactum Salutator {
        functio salve(textus nomen) -> textus
      }
  ts:
      - 'interface Salutator'
      - 'salve(nomen: string): string;'
  py:
      - 'class Salutator(Protocol):'
      - 'def salve(self, nomen: str) -> str:'
  cpp:
      - 'template<typename T>'
      - 'concept Salutator = requires'
  zig:
      - '// pactum Salutator'
      - 'interface contract'
      - 'requires fn salve'

# pactum with multiple methods
- name: 'pactum with multiple methods'
  input: |
      pactum Calculator {
        functio adde(numerus a, numerus b) -> numerus
        functio minue(numerus a, numerus b) -> numerus
      }
  ts:
      - 'interface Calculator'
      - 'adde(a: number, b: number): number;'
      - 'minue(a: number, b: number): number;'
  py:
      - 'class Calculator(Protocol):'
      - 'def adde(self, a: int, b: int) -> int: ...'
      - 'def minue(self, a: int, b: int) -> int: ...'
  zig:
      - '// pactum Calculator: interface contract (Zig uses duck typing)'
      - '//   requires fn adde(a: i64, b: i64) i64'
      - '//   requires fn minue(a: i64, b: i64) i64'
  cpp:
      - 'template<typename T>'
      - 'concept Calculator = requires(T t) {'
      - '{ t.adde(std::declval<int64_t>(), std::declval<int64_t>()) } -> std::same_as<int64_t>;'

# pactum with async method
- name: 'pactum with async method'
  input: |
      pactum DataFetcher {
        futura functio fetch(textus url) -> textus
      }
  ts:
      - 'interface DataFetcher'
      - 'fetch(url: string): Promise<string>;'
  py:
      - 'class DataFetcher(Protocol):'
      - 'async def fetch(self, url: str) -> Awaitable[str]: ...'
  zig:
      - '// pactum DataFetcher: interface contract (Zig uses duck typing)'
      - '//   requires fn fetch(url: []const u8) []const u8'
  cpp:
      - 'template<typename T>'
      - 'concept DataFetcher = requires(T t) {'
      - '{ t.fetch(std::declval<std::string>()) } -> std::same_as<std::string>;'

# pactum with generator method
- name: 'pactum with generator method'
  input: |
      pactum NumberGenerator {
        cursor functio generate(numerus max) -> numerus
      }
  ts:
      - 'interface NumberGenerator'
      - 'generate(max: number): Generator<number>;'
  py:
      - 'class NumberGenerator(Protocol):'
      - 'def generate(self, max: int) -> Iterator[int]: ...'
  zig:
      - '// pactum NumberGenerator: interface contract (Zig uses duck typing)'
      - '//   requires fn generate(max: i64) i64'
  cpp:
      - 'template<typename T>'
      - 'concept NumberGenerator = requires(T t) {'
      - '{ t.generate(std::declval<int64_t>()) } -> std::same_as<int64_t>;'

# pactum with async generator method
- name: 'pactum with async generator method'
  input: |
      pactum StreamReader {
        futura cursor functio read() -> textus
      }
  ts:
      - 'interface StreamReader'
      - 'read(): AsyncGenerator<string>;'
  py:
      - 'class StreamReader(Protocol):'
      - 'async def read(self) -> AsyncIterator[str]: ...'
  zig:
      - '// pactum StreamReader: interface contract (Zig uses duck typing)'
      - '//   requires fn read() []const u8'
  cpp:
      - 'template<typename T>'
      - 'concept StreamReader = requires(T t) {'
      - '{ t.read() } -> std::same_as<std::string>;'

# pactum with type parameters
- name: 'pactum with type parameters'
  input: |
      pactum Container<T> {
        functio get() -> T
        functio set(T value)
      }
  ts:
      - 'interface Container<T>'
      - 'get(): T;'
      - 'set(value: T): void;'
  py:
      - 'class Container[T](Protocol):'
      - 'def get(self) -> T: ...'
      - 'def set(self, value: T) -> None: ...'
  zig:
      - '// pactum Container: interface contract (Zig uses duck typing)'
      - '//   requires fn get() T'
      - '//   requires fn set(value: T) void'
  cpp:
      - 'template<typename T>'
      - 'concept Container = requires(T t) {'
      - '{ t.get() } -> std::same_as<T>;'

# implet makes a class implement an interface
- name: 'genus implements pactum'
  input: |
      pactum Greeter {
        functio greet(textus name) -> textus
      }
      genus FriendlyGreeter implet Greeter {
        functio greet(textus name) -> textus {
          redde "Hello, " + name
        }
      }
  ts:
      - 'interface Greeter'
      - 'class FriendlyGreeter implements Greeter'
      - 'greet(name: string): string'
  py:
      - 'class Greeter(Protocol):'
      - 'class FriendlyGreeter(Greeter):'
  zig:
      - '// pactum Greeter: interface contract (Zig uses duck typing)'
      - '//   requires fn greet(name: []const u8) []const u8'
      - 'const FriendlyGreeter = struct {'
      - 'const Self = @This();'
      - 'pub fn greet(self: *const Self, name: []const u8) []const u8 {'
      - 'return ("Hello, " ++ name);'
      - '};'
  cpp:
      - 'template<typename T>'
      - 'concept Greeter = requires(T t) {'
      - '{ t.greet(std::declval<std::string>()) } -> std::same_as<std::string>;'

# =============================================================================
# Discretio (Tagged Unions)
# =============================================================================

# discretio creates a tagged union type
- name: 'discretio with variants'
  input: |
      discretio Result {
        Success { numerus value }
        Error { textus message }
      }
  ts:
      - "type Result = { tag: 'Success'; value: number } | { tag: 'Error'; message: string }"
  py:
      - '@dataclass'
      - 'class Result_Success:'
      - 'value: int'
      - 'class Result_Error:'
      - 'message: str'
      - 'Result = Result_Success | Result_Error'
  cpp:
      - 'struct Success {'
      - 'int64_t value'
      - 'struct Error {'
      - 'std::string message'
      - 'using Result = std::variant<Success, Error>'
  zig:
      - 'const Result = union(enum) {'
      - 'success: struct { value: i64 }'
      - 'error: struct { message: []const u8 }'

# discretio variant without fields
- name: 'discretio with empty variant'
  input: |
      discretio Option {
        Some { numerus value }
        None
      }
  ts:
      - "type Option = { tag: 'Some'; value: number } | { tag: 'None' }"

# =============================================================================
# In Statement (Mutation Blocks)
# =============================================================================

# in allows chained mutations on an object
- name: 'in statement for object mutation'
  input: |
      in user {
        nomen = "Marcus"
        aetas = 30
      }
  ts:
      - 'user.nomen = "Marcus"'
      - 'user.aetas = 30'
  py:
      - 'user.nomen = "Marcus"'
      - 'user.aetas = 30'
