# Structurae - Data structure codegen tests
# Covers: genus, pactum, destructuring, novum, ego, nexum

# =============================================================================
# Object Destructuring
# =============================================================================

# Extract named properties from object
- name: 'simple object destructuring'
  input: 'fixum { nomen, aetas } = user'
  ts: 'const { nomen, aetas } = user;'
  py:
      - 'nomen = user["nomen"]'
      - 'aetas = user["aetas"]'
  zig:
      - 'const _tmp = user'
      - 'const nomen = _tmp.nomen'
      - 'const aetas = _tmp.aetas'

# Rename during destructuring with colon
- name: 'destructuring with rename'
  input: 'fixum { nomen: localName } = user'
  ts: 'const { nomen: localName } = user;'
  py:
      - 'localName = user["nomen"]'

# Mutable destructuring uses varia
- name: 'mutable destructuring'
  input: 'varia { count } = data'
  ts: 'let { count } = data;'

# =============================================================================
# Array Destructuring
# =============================================================================

# Extract elements by position
- name: 'simple array destructuring'
  input: 'fixum [a, b, c] = coords'
  ts: 'const [a, b, c] = coords;'
  py: 'a, b, c = coords'
  zig:
      - 'const _tmp = coords'
      - 'const a = _tmp[0]'
      - 'const b = _tmp[1]'
      - 'const c = _tmp[2]'

# ceteri collects remaining elements
- name: 'array destructuring with rest'
  input: 'fixum [first, ceteri rest] = items'
  ts: 'const [first, ...rest] = items;'
  py: 'first, *rest = items'
  zig:
      - 'const _tmp = items'
      - 'const first = _tmp[0]'
      - 'const rest = _tmp[1..]'

# Underscore skips elements
- name: 'array destructuring with skip'
  input: 'fixum [_, second, _] = data'
  ts: 'const [, second, ] = data;'
  py: '_, second, _ = data'
  zig:
      - 'const _tmp = data'
      - 'const second = _tmp[1]'

# Mutable array destructuring
- name: 'mutable array destructuring'
  input: 'varia [x, y] = coords'
  ts: 'let [x, y] = coords;'
  zig:
      - 'const _tmp = coords'
      - 'var x = _tmp[0]'
      - 'var y = _tmp[1]'

# ex array syntax (source first)
- name: 'ex array destructuring'
  input: 'ex coords fixum [x, y, z]'
  ts: 'const [x, y, z] = coords;'
  zig:
      - 'const _tmp = coords'
      - 'const x = _tmp[0]'
      - 'const y = _tmp[1]'
      - 'const z = _tmp[2]'

# ex array with rest
- name: 'ex array destructuring with rest'
  input: 'ex items fixum [first, ceteri tail]'
  ts: 'const [first, ...tail] = items;'

# =============================================================================
# Genus (Class)
# =============================================================================

# genus generates class with auto-merge constructor
- name: 'genus with auto-merge constructor'
  input: 'genus persona { textus nomen: "X" }'
  ts:
      - 'class persona'
      - 'nomen: string = "X"'
      - 'constructor(overrides:'
      - 'if (overrides.nomen !== undefined)'
  py:
      - 'class persona:'
      - 'nomen: str = "X"'
      - 'def __init__'
  cpp:
      - 'struct persona {'
      - 'std::string nomen = '
      - '};'
  zig:
      - 'const persona = struct {'
      - 'nomen: []const u8 = "X"'
      - 'pub fn init(overrides: anytype) Self'
      - '@hasField(@TypeOf(overrides), "nomen")'

# creo becomes private method called from constructor
- name: 'genus with creo'
  input: |
      genus persona {
        numerus aetas: 0
        functio creo() {
          si ego.aetas < 0 { ego.aetas = 0 }
        }
      }
  ts:
      - 'this.creo();'
      - 'private creo()'
  zig:
      - 'self.creo();'
      - 'fn creo(self: *Self) void'

# Without creo, no creo method is generated
- name: 'genus without creo'
  input: 'genus persona { textus nomen: "X" }'
  ts:
      not_contains:
          - 'this.creo()'
          - 'private creo()'
  zig:
      not_contains:
          - 'self.creo()'

# =============================================================================
# Novum (New)
# =============================================================================

# novum creates instance - new in TS, direct call in Python
- name: 'novum without args'
  input: 'fixum p = novum persona'
  ts: 'const p = new persona();'
  py: 'p = persona()'
  cpp:
      - 'persona{}'
  zig:
      - 'persona.init(.{})'

# novum with object literal passes overrides to constructor
- name: 'novum with overrides'
  input: 'fixum p = novum persona { nomen: "Claudia" }'
  ts: 'const p = new persona({ nomen: "Claudia" });'
  py: 'p = persona({"nomen": "Claudia"})'
  cpp:
      - 'persona{.nomen = '
  zig:
      - 'persona.init(.{ .nomen = "Claudia" })'

# =============================================================================
# Ego (this/self)
# =============================================================================

# ego is this in TS, self in Python
- name: 'ego becomes this or self'
  input: |
      genus persona {
        textus nomen: "X"
        functio saluta() { redde ego.nomen }
      }
  ts:
      - 'return this.nomen'
  py:
      - 'return self.nomen'
  cpp:
      - 'void saluta()'
      - 'this->nomen'
  zig:
      - 'return self.nomen'

# =============================================================================
# Nexum (Reactive Fields) - TS only
# =============================================================================

# nexum emits private backing field
- name: 'nexum private backing field'
  input: 'genus counter { nexum numerus count: 0 }'
  ts:
      - '#count = 0;'
  zig:
      - 'const counter = struct {'
      - 'count: i64 = 0,'
      - 'const Self = @This();'
      - 'pub fn init(overrides: anytype) Self {'
      - 'const self = Self{'
      - '.count = if (@hasField(@TypeOf(overrides), "count")) overrides.count else 0,'
      - '};'
      - 'return self;'

# nexum emits getter
- name: 'nexum getter'
  input: 'genus counter { nexum numerus count: 0 }'
  ts:
      - 'get count(): number { return this.#count; }'
  zig:
      - 'const counter = struct {'
      - 'count: i64 = 0,'
      - 'const Self = @This();'
      - 'pub fn init(overrides: anytype) Self {'
      - 'const self = Self{'
      - '.count = if (@hasField(@TypeOf(overrides), "count")) overrides.count else 0,'
      - '};'
      - 'return self;'

# nexum emits setter with invalidation
- name: 'nexum setter with invalidation'
  input: 'genus counter { nexum numerus count: 0 }'
  ts:
      - 'set count(v: number)'
      - 'this.#count = v'
      - "__invalidate?.('count')"
  zig:
      - 'const counter = struct {'
      - 'count: i64 = 0,'
      - 'const Self = @This();'
      - 'pub fn init(overrides: anytype) Self {'
      - 'const self = Self{'
      - '.count = if (@hasField(@TypeOf(overrides), "count")) overrides.count else 0,'
      - '};'
      - 'return self;'

# nexum works with different types
- name: 'nexum with textus'
  input: 'genus user { nexum textus name: "anon" }'
  ts:
      - '#name = "anon";'
      - 'get name(): string { return this.#name; }'
      - 'set name(v: string)'
  zig:
      - 'const user = struct {'
      - 'name: []const u8 = "anon",'
      - 'const Self = @This();'
      - 'pub fn init(overrides: anytype) Self {'
      - 'const self = Self{'
      - '.name = if (@hasField(@TypeOf(overrides), "name")) overrides.name else "anon",'
      - '};'
      - 'return self;'

# nexum without initial value
- name: 'nexum without initial value'
  input: 'genus timer { nexum numerus elapsed }'
  ts:
      - '#elapsed;'
      - 'get elapsed(): number'
      - 'set elapsed(v: number)'
  zig:
      - 'const timer = struct {'
      - 'elapsed: i64 = undefined,'
      - 'const Self = @This();'
      - 'pub fn init(overrides: anytype) Self {'
      - 'const self = Self{'
      - '.elapsed = if (@hasField(@TypeOf(overrides), "elapsed")) overrides.elapsed else undefined,'
      - '};'
      - 'return self;'

# Mixed nexum and regular fields
- name: 'mixed nexum and regular fields'
  input: |
      genus widget {
        textus id: "x"
        nexum numerus count: 0
        bivalens active: verum
      }
  ts:
      - 'id: string = "x";'
      - 'active: boolean = true;'
      - '#count = 0;'
      - 'get count(): number'
      - 'set count(v: number)'
  zig:
      - 'const widget = struct {'
      - 'id: []const u8 = "x",'
      - 'count: i64 = 0,'
      - 'active: bool = true,'
      - 'const Self = @This();'
      - 'pub fn init(overrides: anytype) Self {'
      - 'const self = Self{'
      - '.id = if (@hasField(@TypeOf(overrides), "id")) overrides.id else "x",'
      - '.count = if (@hasField(@TypeOf(overrides), "count")) overrides.count else 0,'
      - '.active = if (@hasField(@TypeOf(overrides), "active")) overrides.active else true,'
      - '};'
      - 'return self;'

# =============================================================================
# Pactum (Interface/Protocol)
# =============================================================================

# pactum declares interface (interface in TS, Protocol in Python)
- name: 'pactum with method'
  input: |
      pactum Salutator {
        functio salve(textus nomen) -> textus
      }
  ts:
      - 'interface Salutator'
      - 'salve(nomen: string): string;'
  py:
      - 'class Salutator(Protocol):'
      - 'def salve(self, nomen: str) -> str:'
  cpp:
      - 'template<typename T>'
      - 'concept Salutator = requires'
  zig:
      - '// pactum Salutator'
      - 'interface contract'
      - 'requires fn salve'

# pactum with multiple methods
- name: 'pactum with multiple methods'
  input: |
      pactum Calculator {
        functio adde(numerus a, numerus b) -> numerus
        functio minue(numerus a, numerus b) -> numerus
      }
  ts:
      - 'interface Calculator'
      - 'adde(a: number, b: number): number;'
      - 'minue(a: number, b: number): number;'
  zig:
      - '// pactum Calculator: interface contract (Zig uses duck typing)'
      - '//   requires fn adde(a: i64, b: i64) i64'
      - '//   requires fn minue(a: i64, b: i64) i64'

# pactum with async method
- name: 'pactum with async method'
  input: |
      pactum DataFetcher {
        futura functio fetch(textus url) -> textus
      }
  ts:
      - 'interface DataFetcher'
      - 'fetch(url: string): Promise<string>;'
  zig:
      - '// pactum DataFetcher: interface contract (Zig uses duck typing)'
      - '//   requires fn fetch(url: []const u8) []const u8'

# pactum with generator method
- name: 'pactum with generator method'
  input: |
      pactum NumberGenerator {
        cursor functio generate(numerus max) -> numerus
      }
  ts:
      - 'interface NumberGenerator'
      - 'generate(max: number): Generator<number>;'
  zig:
      - '// pactum NumberGenerator: interface contract (Zig uses duck typing)'
      - '//   requires fn generate(max: i64) i64'

# pactum with async generator method
- name: 'pactum with async generator method'
  input: |
      pactum StreamReader {
        futura cursor functio read() -> textus
      }
  ts:
      - 'interface StreamReader'
      - 'read(): AsyncGenerator<string>;'
  zig:
      - '// pactum StreamReader: interface contract (Zig uses duck typing)'
      - '//   requires fn read() []const u8'

# pactum with type parameters
- name: 'pactum with type parameters'
  input: |
      pactum Container<T> {
        functio get() -> T
        functio set(T value)
      }
  ts:
      - 'interface Container<T>'
      - 'get(): T;'
      - 'set(value: T): void;'
  zig:
      - '// pactum Container: interface contract (Zig uses duck typing)'
      - '//   requires fn get() T'
      - '//   requires fn set(value: T) void'

# implet makes a class implement an interface
- name: 'genus implements pactum'
  input: |
      pactum Greeter {
        functio greet(textus name) -> textus
      }
      genus FriendlyGreeter implet Greeter {
        functio greet(textus name) -> textus {
          redde "Hello, " + name
        }
      }
  ts:
      - 'interface Greeter'
      - 'class FriendlyGreeter implements Greeter'
      - 'greet(name: string): string'
  py:
      - 'class Greeter(Protocol):'
      - 'class FriendlyGreeter(Greeter):'
  zig:
      - '// pactum Greeter: interface contract (Zig uses duck typing)'
      - '//   requires fn greet(name: []const u8) []const u8'
      - 'const FriendlyGreeter = struct {'
      - 'const Self = @This();'
      - 'pub fn greet(self: *const Self, name: []const u8) []const u8 {'
      - 'return ("Hello, " ++ name);'
      - '};'
