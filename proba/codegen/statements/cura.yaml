# Cura statements - Scoped resource management with automatic cleanup
#
# Syntax:
#   cura resource fit binding { use } -- scoped resource with cleanup
#   cura asyncRes fiet binding { use } -- async scoped resource
#   cura arena fit mem { ... } -- arena allocator
#   cura page fit mem { ... } -- page allocator
#
# Note: Test hooks (praepara/postpara) are separate from cura statements.
#       CuraStatement (resource management) supports TS, RS, and Zig.

# =============================================================================
# CuraStatement - Scoped Resource Management
# TS: try/finally with solve?.()
# RS: let binding with scope-based drop
# Zig: defer binding.solve()
# =============================================================================

# WHY: liber curator kind is planned but not yet implemented
# Basic scoped resource with fit binding (liber = file handle)
- name: cura with fit binding
  skip: [ts, py, rs, cpp, zig, fab]
  faber: |
      cura liber aperi("file.txt") fit fd {
        read(fd)
      }

# WHY: conexio curator kind is planned but not yet implemented
# Async resource with fiet (conexio = connection)
- name: cura with async resource
  skip: [ts, py, rs, cpp, zig, fab]
  faber: |
      cura conexio connect(url) fiet conn {
        cede conn.query(sql)
      }

# Resource with catch clause
- name: cura with cape clause
  faber: |
      cura resource() fit r {
        use(r)
      }
      cape err {
        handleError(err)
      }
  expect:
      ts:
          - '{'
          - 'const r = resource();'
          - 'try {'
          - 'use(r);'
          - 'catch (err) {'
          - 'handleError(err);'
          - 'finally {'
          - 'r.solve?.();'
      rs:
          - 'let r = resource();'
          - '{'
          - 'use(r);'
      zig:
          - 'const r = resource();'
          - 'defer r.solve();'
          - 'use(r);'
      fab:
          - 'cura resource() fit r {'
          - 'use(r)'
          - 'cape err {'
          - 'handleError(err)'
  skip: [py, cpp]

# Nested resource management
- name: nested cura statements
  faber: |
      cura openFile("input.txt") fit inFile {
        cura openFile("output.txt") fit outFile {
          copy(inFile, outFile)
        }
      }
  expect:
      ts:
          - 'const inFile = openFile("input.txt");'
          - 'try {'
          - 'const outFile = openFile("output.txt");'
          - 'try {'
          - 'copy(inFile, outFile);'
          - 'finally {'
          - 'outFile.solve?.();'
          - 'finally {'
          - 'inFile.solve?.();'
      rs:
          - 'let inFile = openFile(String::from("input.txt"));'
          - 'let outFile = openFile(String::from("output.txt"));'
          - '{'
          - 'copy(inFile, outFile);'
      zig:
          - 'const inFile = openFile("input.txt");'
          - 'defer inFile.solve();'
          - 'const outFile = openFile("output.txt");'
          - 'defer outFile.solve();'
          - 'copy(inFile, outFile);'
      fab:
          - 'cura openFile("input.txt") fit inFile {'
          - 'cura openFile("output.txt") fit outFile {'
          - 'copy(inFile, outFile)'
  skip: [py, cpp]

# Multiple statements in resource body
- name: cura with multiple body statements
  faber: |
      cura mutex.lock() fit guard {
        counter += 1
        scribe counter
        redde counter
      }
  expect:
      ts:
          - 'const guard = mutex.lock();'
          - 'try {'
          - 'counter += 1;'
          - 'console.log(counter);'
          - 'return counter;'
          - 'finally {'
          - 'guard.solve?.();'
      rs:
          - 'let guard = mutex.lock();'
          - '{'
          - 'counter += 1;'
          - 'println!'
          - 'return counter;'
      zig:
          - 'const guard = mutex.lock();'
          - 'defer guard.solve();'
          - 'counter += 1;'
          - 'return counter;'
      fab:
          - 'cura mutex.lock() fit guard {'
          - 'counter += 1'
          - 'scribe counter'
          - 'redde counter'
  skip: [py, cpp]

# Resource with complex expression
- name: cura with complex resource expression
  faber: |
      cura novum Database(config.url) fit db {
        db.init()
      }
  expect:
      ts:
          - 'const db = new Database(config.url);'
          - 'try {'
          - 'db.init();'
          - 'finally {'
          - 'db.solve?.();'
      rs:
          - 'let db = Database::new();'
          - '{'
          - 'db.init();'
      zig:
          - 'defer db.solve();'
          - 'db.init();'
      fab:
          - 'cura novum Database(config.url) fit db {'
          - 'db.init()'
  skip: [py, cpp]

# Empty resource body
- name: cura with empty body
  faber: 'cura getResource() fit r { }'
  expect:
      ts:
          - 'const r = getResource();'
          - 'try {}'
          - 'finally {'
          - 'r.solve?.();'
      rs:
          - 'let r = getResource();'
          - '{'
      zig:
          - 'const r = getResource();'
          - 'defer r.solve();'
      fab:
          - 'cura getResource() fit r {'
  skip: [py, cpp]

# Async resource with catch and multiple operations
- name: async cura with cape and operations
  faber: |
      cura acquire(lock) fiet handle {
        varia data = cede fetch()
        process(data)
        redde data
      }
      cape err {
        mone "Failed:", err
        iace err
      }
  expect:
      ts:
          - 'const handle = await acquire(lock);'
          - 'try {'
          - 'let data = await fetch();'
          - 'process(data);'
          - 'return data;'
          - 'catch (err) {'
          - 'console.warn("Failed:", err);'
          - 'throw err;'
          - 'finally {'
          - 'handle.solve?.();'
      rs:
          - 'let handle = acquire(lock).await;'
          - '{'
          - 'let mut data = fetch().await;'
          - 'process(data);'
          - 'return data;'
      zig:
          - 'const handle = try acquire(lock);'
          - 'defer handle.solve();'
          - 'process(data);'
          - 'return data;'
      fab:
          - 'cura acquire(lock) fiet handle {'
          - 'varia data = cede fetch()'
          - 'process(data)'
          - 'redde data'
          - 'cape err {'
          - 'mone "Failed:", err'
          - 'iace err'
  skip: [py, cpp]

# =============================================================================
# Curator Kinds - Allocators (arena, page)
# =============================================================================

# Arena allocator - TS/RS strip it (GC), Zig emits ArenaAllocator
- name: cura arena basic
  faber: |
      cura arena fit mem {
        varia x = 42
        process(x)
      }
  expect:
      ts:
          - 'let x = 42;'
          - 'process(x);'
      rs:
          - 'let mut x = 42;'
          - 'process(x);'
      zig:
          - 'var mem_arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);'
          - 'defer mem_arena.deinit();'
          - 'const mem = mem_arena.allocator();'
      fab:
          - 'cura arena fit mem {'
          - 'varia x = 42'
          - 'process(x)'
  skip: [py, cpp]

# Page allocator - TS/RS strip it (GC), Zig emits page_allocator
- name: cura page basic
  faber: |
      cura page fit mem {
        fixum buffer = allocate(1024)
      }
  expect:
      ts:
          - 'const buffer = allocate(1024);'
      rs:
          - 'let buffer = allocate(1024);'
      zig:
          - 'const mem = std.heap.page_allocator;'
          - 'const buffer = allocate(1024);'
      fab:
          - 'cura page fit mem {'
          - 'fixum buffer = allocate(1024)'
  skip: [py, cpp]

# Nested arena blocks
- name: nested cura arena
  faber: |
      cura arena fit outer {
        varia a = 1
        process(a)
        cura arena fit inner {
          varia b = 2
          process(b)
        }
        process(a)
      }
  expect:
      ts:
          - 'let a = 1;'
          - 'process(a);'
          - 'let b = 2;'
          - 'process(b);'
      rs:
          - 'let mut a = 1;'
          - 'process(a);'
          - 'let mut b = 2;'
          - 'process(b);'
      zig:
          - 'var outer_arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);'
          - 'defer outer_arena.deinit();'
          - 'const outer = outer_arena.allocator();'
          - 'var inner_arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);'
          - 'defer inner_arena.deinit();'
          - 'const inner = inner_arena.allocator();'
      fab:
          - 'cura arena fit outer {'
          - 'varia a = 1'
          - 'process(a)'
          - 'cura arena fit inner {'
          - 'varia b = 2'
          - 'process(b)'
  skip: [py, cpp]

# Arena with pro binding (neutral)
- name: cura arena with pro
  faber: |
      cura arena pro alloc {
        process(alloc)
      }
  expect:
      ts:
          - 'process(alloc);'
      rs:
          - 'process(alloc);'
      zig:
          - 'var alloc_arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);'
          - 'defer alloc_arena.deinit();'
          - 'const alloc = alloc_arena.allocator();'
          - 'process(alloc);'
      fab:
          - 'cura arena pro alloc {'
          - 'process(alloc)'
  skip: [py, cpp]
