# Cura statements - Resource management and test lifecycle hooks
# Two forms:
#   1. CuraBlock: Test lifecycle hooks (beforeEach, afterEach, etc.)
#   2. CuraStatement: Scoped resource management with automatic cleanup
#
# Syntax:
#   cura ante { ... }           -- beforeEach (runs before each test)
#   cura ante omnia { ... }     -- beforeAll (runs before all tests)
#   cura post { ... }           -- afterEach (runs after each test)
#   cura post omnia { ... }     -- afterAll (runs after all tests)
#   cura resource fit binding { use } -- scoped resource with cleanup
#   cura asyncRes fiet binding { use } -- async scoped resource
#
# Note: CuraBlock (test hooks) only implemented for TS and Rust.
#       CuraStatement (resource management) also supports Zig.

# =============================================================================
# CuraBlock - Test Lifecycle Hooks
# Note: Zig has no test framework with beforeEach/afterEach semantics
# =============================================================================

# cura ante becomes beforeEach in TS, comment in Rust
- name: cura ante hook
  faber: |
      cura ante {
        lexer = init()
      }
  expect:
      ts:
          - 'beforeEach(() => {'
          - 'lexer = init();'
      rs:
          - '// setup_each:'
          - 'lexer = init();'
      fab:
          - 'cura ante {'
          - 'lexer = init()'
  skip: [py, cpp, zig]

# cura ante omnia becomes beforeAll in TS
- name: cura ante omnia hook
  faber: |
      cura ante omnia {
        db = connect()
      }
  expect:
      ts:
          - 'beforeAll(() => {'
          - 'db = connect();'
      rs:
          - '// setup_all:'
          - 'db = connect();'
      fab:
          - 'cura ante omnia {'
          - 'db = connect()'
  skip: [py, cpp, zig]

# cura post becomes afterEach in TS
- name: cura post hook
  faber: |
      cura post {
        cleanup()
      }
  expect:
      ts:
          - 'afterEach(() => {'
          - 'cleanup();'
      rs:
          - '// teardown_each:'
          - 'cleanup();'
      fab:
          - 'cura post {'
          - 'cleanup()'
  skip: [py, cpp, zig]

# cura post omnia becomes afterAll in TS
- name: cura post omnia hook
  faber: |
      cura post omnia {
        db.close()
      }
  expect:
      ts:
          - 'afterAll(() => {'
          - 'db.close();'
      rs:
          - '// teardown_all:'
          - 'db.close();'
      fab:
          - 'cura post omnia {'
          - 'db.close()'
  skip: [py, cpp, zig]

# Multiple statements in hook body
- name: cura ante with multiple statements
  faber: |
      cura ante {
        varia lexer = novum Lexer()
        lexer.init()
        scribe "ready"
      }
  expect:
      ts:
          - 'beforeEach(() => {'
          - 'let lexer = new Lexer();'
          - 'lexer.init();'
          - 'console.log("ready");'
      rs:
          - '// setup_each:'
          - 'let mut lexer = Lexer::new();'
          - 'lexer.init();'
      fab:
          - 'cura ante {'
          - 'varia lexer = novum Lexer()'
          - 'lexer.init()'
          - 'scribe "ready"'
  skip: [py, cpp, zig]

# =============================================================================
# CuraStatement - Scoped Resource Management
# TS: try/finally with solve?.()
# RS: let binding with scope-based drop
# Zig: defer binding.solve()
# =============================================================================

# Basic scoped resource with fit binding
- name: cura with fit binding
  faber: |
      cura aperi("file.txt") fit fd {
        lege(fd)
      }
  expect:
      ts:
          - '{'
          - 'const fd = aperi("file.txt");'
          - 'try {'
          - 'lege(fd);'
          - 'finally {'
          - 'fd.solve?.();'
      rs:
          - 'let fd = aperi(String::from("file.txt"));'
          - '{'
          - 'lege(fd);'
      zig:
          - 'const fd = aperi("file.txt");'
          - 'defer fd.solve();'
          - 'lege(fd);'
      fab:
          - 'cura aperi("file.txt") fit fd {'
          - 'lege(fd)'
  skip: [py, cpp]

# Async resource with fiet
- name: cura with async resource
  faber: |
      cura connect(url) fiet conn {
        cede conn.query(sql)
      }
  expect:
      ts:
          - '{'
          - 'const conn = await connect(url);'
          - 'try {'
          - 'await conn.query(sql);'
          - 'finally {'
          - 'conn.solve?.();'
      rs:
          - 'let conn = connect(url).await;'
          - '{'
          - 'conn.query(sql).await;'
      zig:
          - 'const conn = try connect(url);'
          - 'defer conn.solve();'
      fab:
          - 'cura connect(url) fiet conn {'
          - 'cede conn.query(sql)'
  skip: [py, cpp]

# Resource with catch clause
- name: cura with cape clause
  faber: |
      cura resource() fit r {
        use(r)
      }
      cape err {
        handleError(err)
      }
  expect:
      ts:
          - '{'
          - 'const r = resource();'
          - 'try {'
          - 'use(r);'
          - 'catch (err) {'
          - 'handleError(err);'
          - 'finally {'
          - 'r.solve?.();'
      rs:
          - 'let r = resource();'
          - '{'
          - 'use(r);'
      zig:
          - 'const r = resource();'
          - 'defer r.solve();'
          - 'use(r);'
      fab:
          - 'cura resource() fit r {'
          - 'use(r)'
          - 'cape err {'
          - 'handleError(err)'
  skip: [py, cpp]

# Nested resource management
- name: nested cura statements
  faber: |
      cura openFile("input.txt") fit inFile {
        cura openFile("output.txt") fit outFile {
          copy(inFile, outFile)
        }
      }
  expect:
      ts:
          - 'const inFile = openFile("input.txt");'
          - 'try {'
          - 'const outFile = openFile("output.txt");'
          - 'try {'
          - 'copy(inFile, outFile);'
          - 'finally {'
          - 'outFile.solve?.();'
          - 'finally {'
          - 'inFile.solve?.();'
      rs:
          - 'let inFile = openFile(String::from("input.txt"));'
          - 'let outFile = openFile(String::from("output.txt"));'
          - '{'
          - 'copy(inFile, outFile);'
      zig:
          - 'const inFile = openFile("input.txt");'
          - 'defer inFile.solve();'
          - 'const outFile = openFile("output.txt");'
          - 'defer outFile.solve();'
          - 'copy(inFile, outFile);'
      fab:
          - 'cura openFile("input.txt") fit inFile {'
          - 'cura openFile("output.txt") fit outFile {'
          - 'copy(inFile, outFile)'
  skip: [py, cpp]

# Multiple statements in resource body
- name: cura with multiple body statements
  faber: |
      cura mutex.lock() fit guard {
        counter += 1
        scribe counter
        redde counter
      }
  expect:
      ts:
          - 'const guard = mutex.lock();'
          - 'try {'
          - 'counter += 1;'
          - 'console.log(counter);'
          - 'return counter;'
          - 'finally {'
          - 'guard.solve?.();'
      rs:
          - 'let guard = mutex.lock();'
          - '{'
          - 'counter += 1;'
          - 'println!'
          - 'return counter;'
      zig:
          - 'const guard = mutex.lock();'
          - 'defer guard.solve();'
          - 'counter += 1;'
          - 'return counter;'
      fab:
          - 'cura mutex.lock() fit guard {'
          - 'counter += 1'
          - 'scribe counter'
          - 'redde counter'
  skip: [py, cpp]

# Resource with complex expression
- name: cura with complex resource expression
  faber: |
      cura novum Database(config.url) fit db {
        db.init()
      }
  expect:
      ts:
          - 'const db = new Database(config.url);'
          - 'try {'
          - 'db.init();'
          - 'finally {'
          - 'db.solve?.();'
      rs:
          - 'let db = Database::new();'
          - '{'
          - 'db.init();'
      zig:
          - 'defer db.solve();'
          - 'db.init();'
      fab:
          - 'cura novum Database(config.url) fit db {'
          - 'db.init()'
  skip: [py, cpp]

# Empty resource body
- name: cura with empty body
  faber: 'cura getResource() fit r { }'
  expect:
      ts:
          - 'const r = getResource();'
          - 'try {}'
          - 'finally {'
          - 'r.solve?.();'
      rs:
          - 'let r = getResource();'
          - '{'
      zig:
          - 'const r = getResource();'
          - 'defer r.solve();'
      fab:
          - 'cura getResource() fit r {'
  skip: [py, cpp]

# Async resource with catch and multiple operations
- name: async cura with cape and operations
  faber: |
      cura acquire(lock) fiet handle {
        varia data = cede fetch()
        process(data)
        redde data
      }
      cape err {
        mone "Failed:", err
        iace err
      }
  expect:
      ts:
          - 'const handle = await acquire(lock);'
          - 'try {'
          - 'let data = await fetch();'
          - 'process(data);'
          - 'return data;'
          - 'catch (err) {'
          - 'console.warn("Failed:", err);'
          - 'throw err;'
          - 'finally {'
          - 'handle.solve?.();'
      rs:
          - 'let handle = acquire(lock).await;'
          - '{'
          - 'let mut data = fetch().await;'
          - 'process(data);'
          - 'return data;'
      zig:
          - 'const handle = try acquire(lock);'
          - 'defer handle.solve();'
          - 'process(data);'
          - 'return data;'
      fab:
          - 'cura acquire(lock) fiet handle {'
          - 'varia data = cede fetch()'
          - 'process(data)'
          - 'redde data'
          - 'cape err {'
          - 'mone "Failed:", err'
          - 'iace err'
  skip: [py, cpp]

# =============================================================================
# Curator Kinds - Allocators (arena, page)
# =============================================================================

# Arena allocator - TS/RS strip it (GC), Zig emits ArenaAllocator
- name: cura arena basic
  faber: |
      cura arena fit mem {
        varia x = 42
        process(x)
      }
  expect:
      ts:
          - 'let x = 42;'
          - 'process(x);'
      rs:
          - 'let mut x = 42;'
          - 'process(x);'
      zig:
          - 'var mem_arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);'
          - 'defer mem_arena.deinit();'
          - 'const mem = mem_arena.allocator();'
      fab:
          - 'cura arena fit mem {'
          - 'varia x = 42'
          - 'process(x)'
  skip: [py, cpp]

# Page allocator - TS/RS strip it (GC), Zig emits page_allocator
- name: cura page basic
  faber: |
      cura page fit mem {
        fixum buffer = allocate(1024)
      }
  expect:
      ts:
          - 'const buffer = allocate(1024);'
      rs:
          - 'let buffer = allocate(1024);'
      zig:
          - 'const mem = std.heap.page_allocator;'
          - 'const buffer = allocate(1024);'
      fab:
          - 'cura page fit mem {'
          - 'fixum buffer = allocate(1024)'
  skip: [py, cpp]

# Nested arena blocks
- name: nested cura arena
  faber: |
      cura arena fit outer {
        varia a = 1
        process(a)
        cura arena fit inner {
          varia b = 2
          process(b)
        }
        process(a)
      }
  expect:
      ts:
          - 'let a = 1;'
          - 'process(a);'
          - 'let b = 2;'
          - 'process(b);'
      rs:
          - 'let mut a = 1;'
          - 'process(a);'
          - 'let mut b = 2;'
          - 'process(b);'
      zig:
          - 'var outer_arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);'
          - 'defer outer_arena.deinit();'
          - 'const outer = outer_arena.allocator();'
          - 'var inner_arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);'
          - 'defer inner_arena.deinit();'
          - 'const inner = inner_arena.allocator();'
      fab:
          - 'cura arena fit outer {'
          - 'varia a = 1'
          - 'process(a)'
          - 'cura arena fit inner {'
          - 'varia b = 2'
          - 'process(b)'
  skip: [py, cpp]

# Arena with pro binding (neutral)
- name: cura arena with pro
  faber: |
      cura arena pro alloc {
        process(alloc)
      }
  expect:
      ts:
          - 'process(alloc);'
      rs:
          - 'process(alloc);'
      zig:
          - 'var alloc_arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);'
          - 'defer alloc_arena.deinit();'
          - 'const alloc = alloc_arena.allocator();'
          - 'process(alloc);'
      fab:
          - 'cura arena pro alloc {'
          - 'process(alloc)'
  skip: [py, cpp]
