# Flumina (streams-first) - fit/fiunt/fiet/fient functions with Responsum protocol
# Maps Faber verbs to generator-wrapped ut* helpers:
#   fit   -> utFit()   (sync single-value)
#   fiunt -> utFiunt() (sync multi-value)
#   fiet  -> utFiet()  (async single-value)
#   fient -> utFient() (async multi-value)
#
# - redde becomes yield respond.ok(value)
# - cede becomes yield respond.item(value)
# - iace becomes yield respond.error(...); return;
# - mori remains throw new Panic(...) (panics are fatal)

# =============================================================================
# Basic fit Functions
# =============================================================================

- name: fit function with redde
  faber: |
      functio getId() fit textus {
        redde "abc"
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'function getId(): string'
              - 'return utFit(function* ()'
              - 'yield respond.ok("abc")'

- name: fit function with redde and param
  faber: |
      functio greet(textus name) fit textus {
        redde name
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'function greet(name: string): string'
              - 'return utFit(function* ()'
              - 'yield respond.ok(name)'

- name: fit function with no return value
  faber: |
      functio doWork() fit vacuum {
        redde
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'function doWork(): void'
              - 'yield respond.ok(undefined)'

# =============================================================================
# Error Handling
# =============================================================================

- name: fit function with iace
  faber: |
      functio mightFail() fit textus {
        iace "not found"
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'yield respond.error("EFAIL", "not found")'
              - 'return;'
          not_contains:
              - 'throw "not found"'

- name: fit function with mori unchanged
  faber: |
      functio mustWork() fit textus {
        mori "fatal error"
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'throw new Panic("fatal error")'
          not_contains:
              - 'respond.error'

# =============================================================================
# Control Flow
# =============================================================================

- name: fit function with conditional return
  faber: |
      functio check(bivalens ok) fit textus {
        si ok {
          redde "success"
        }
        redde "failure"
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'function check(ok: boolean): string'
              - 'if (ok)'
              - 'yield respond.ok("success")'
              - 'yield respond.ok("failure")'

- name: fit function with conditional error
  faber: |
      functio validate(numerus x) fit numerus {
        si x < 0 {
          iace "negative not allowed"
        }
        redde x
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'yield respond.error("EFAIL", "negative not allowed")'
              - 'return;'
              - 'yield respond.ok(x)'

# =============================================================================
# Non-flumina Functions (should NOT be transformed)
# =============================================================================

- name: arrow async function not transformed
  faber: |
      futura functio fetchData() -> textus {
        redde "data"
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'async function fetchData(): Promise<string>'
              - 'return "data"'
          not_contains:
              - 'utFit'
              - 'respond.ok'

# =============================================================================
# fiunt Functions (multi-value streams with Responsum protocol)
# =============================================================================

- name: fiunt function with cede
  faber: |
      functio items() fiunt numerus {
        cede 1
        cede 2
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'function* items(): Generator<number>'
              - 'yield* utFiunt('
              - 'yield respond.item(1)'
              - 'yield respond.item(2)'
              - 'yield respond.done()'

- name: fiunt function with single cede
  faber: |
      functio single() fiunt textus {
        cede "hello"
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'function* single(): Generator<string>'
              - 'yield respond.item("hello")'
              - 'yield respond.done()'

- name: fiunt function with iace
  faber: |
      functio mayFail() fiunt numerus {
        cede 1
        iace "error occurred"
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'yield respond.item(1)'
              - 'yield respond.error("EFAIL", "error occurred")'
              - 'return;'

- name: fiunt function with mori unchanged
  faber: |
      functio mustWork() fiunt numerus {
        cede 1
        mori "fatal"
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'yield respond.item(1)'
              - 'throw new Panic("fatal")'
          not_contains:
              - 'respond.error'

- name: fiunt function with conditional cede
  faber: |
      functio conditional(bivalens flag) fiunt numerus {
        si flag {
          cede 1
        }
        cede 2
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'function* conditional(flag: boolean): Generator<number>'
              - 'if (flag)'
              - 'yield respond.item(1)'
              - 'yield respond.item(2)'
              - 'yield respond.done()'

- name: fiunt function with loop
  faber: |
      functio range(numerus n) fiunt numerus {
        varia numerus i = 0
        dum i < n {
          cede i
          i = i + 1
        }
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'function* range(n: number): Generator<number>'
              - 'while ('
              - 'i < n'
              - 'yield respond.item(i)'
              - 'yield respond.done()'

# =============================================================================
# fiet Functions (async single-value streams with Responsum protocol)
# =============================================================================

- name: fiet function with redde
  faber: |
      functio fetchData() fiet textus {
        redde "data"
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'async function fetchData(): Promise<string>'
              - 'return await utFiet(async function* ()'
              - 'yield respond.ok("data")'

- name: fiet function with cede and redde
  faber: |
      functio fetchAndReturn() fiet textus {
        fixum result = cede getData()
        redde result
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'async function fetchAndReturn(): Promise<string>'
              - 'utFiet(async function* ()'
              - 'await getData()'
              - 'yield respond.ok(result)'

- name: fiet function with iace
  faber: |
      functio mightFail() fiet textus {
        iace "network error"
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'async function mightFail(): Promise<string>'
              - 'yield respond.error("EFAIL", "network error")'
              - 'return;'

- name: fiet function with mori unchanged
  faber: |
      functio mustWork() fiet textus {
        mori "fatal"
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'throw new Panic("fatal")'
          not_contains:
              - 'respond.error'

# =============================================================================
# fient Functions (async multi-value streams with Responsum protocol)
# =============================================================================

- name: fient function with cede
  faber: |
      functio fetchItems() fient textus {
        cede fetch("a")
        cede fetch("b")
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'async function* fetchItems(): AsyncGenerator<string>'
              - 'yield* utFient('
              - 'yield respond.item(await fetch("a"))'
              - 'yield respond.item(await fetch("b"))'
              - 'yield respond.done()'

- name: fient function with iace
  faber: |
      functio fetchMayFail() fient textus {
        cede fetch("a")
        iace "failed"
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'async function* fetchMayFail(): AsyncGenerator<string>'
              - 'yield respond.item(await fetch("a"))'
              - 'yield respond.error("EFAIL", "failed")'
              - 'return;'

- name: fient function with loop
  faber: |
      functio fetchAll(lista<textus> urls) fient textus {
        ex urls pro url {
          cede fetch(url)
        }
      }
  skip: [py, rs, cpp, zig]
  expect:
      ts:
          contains:
              - 'async function* fetchAll(urls: Array<string>): AsyncGenerator<string>'
              - 'for (const url of urls)'
              - 'yield respond.item(await fetch(url))'
              - 'yield respond.done()'
