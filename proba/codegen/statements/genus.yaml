# Genus declarations - class/struct data types
# Maps Faber genus syntax to target-language classes/structs
#
# Syntax:
#   genus Name { typeAnnotation fieldName: defaultValue }
#   genus Name { functio methodName() { body } }
#   genus Name { functio creo() { initialization } }
#   genus Name implet Interface1, Interface2 { ... }
#
# Features:
#   - Fields are public by default (struct semantics)
#   - privatus modifier for private fields
#   - generis modifier for static/class-level fields
#   - Auto-merge constructor accepts overrides object
#   - creo() method is post-initialization hook
#   - Type parameters: genus Box<T> { T value }

# =============================================================================
# Simple Genus
# =============================================================================

# Basic struct with single field
- name: simple genus with one field
  faber: 'genus Persona { textus nomen }'
  expect:
      ts:
          - 'class Persona'
          - 'nomen: string'
          - 'constructor(overrides:'
      py:
          - 'class Persona:'
          - 'nomen: str'
          - 'def __init__(self, overrides: dict = {}):'
      rs:
          - 'struct Persona'
          - 'pub nomen: String,'
      cpp:
          - 'struct Persona'
          - 'std::string nomen'
      zig:
          - 'const Persona = struct'
          - 'nomen: []const u8'
      fab:
          - 'genus Persona'
          - 'textus nomen'

# Genus with multiple fields
- name: genus with multiple fields
  faber: |
      genus Persona {
        textus nomen
        numerus aetas
      }
  expect:
      ts:
          - 'class Persona'
          - 'nomen: string'
          - 'aetas: number'
      py:
          - 'class Persona:'
          - 'nomen: str'
          - 'aetas: int'
      rs:
          - 'struct Persona'
          - 'pub nomen: String,'
          - 'pub aetas: i64,'
      cpp:
          - 'struct Persona'
          - 'std::string nomen'
          - 'int64_t aetas'
      zig:
          - 'const Persona = struct'
          - 'nomen: []const u8'
          - 'aetas: i64'
      fab:
          - 'genus Persona'
          - 'textus nomen'
          - 'numerus aetas'

# =============================================================================
# Field Defaults
# =============================================================================

# Fields with default values
- name: genus with field defaults
  faber: 'genus Config { textus nomen: "default" numerus port: 8080 }'
  expect:
      ts:
          - 'nomen: string = "default"'
          - 'port: number = 8080'
      py:
          - 'nomen: str = "default"'
          - 'port: int = 8080'
      rs:
          - 'struct Config'
      cpp:
          - 'std::string nomen = std::string("default")'
          - 'int64_t port = 8080'
      zig:
          - 'nomen: []const u8 = "default"'
          - 'port: i64 = 8080'
      fab:
          - 'genus Config'
          - 'textus nomen: "default"'
          - 'numerus port: 8080'

# =============================================================================
# Field Modifiers
# =============================================================================

# Private fields
- name: genus with private field
  faber: |
      genus Persona {
          @ privatum
          textus secretum
      }
  expect:
      ts:
          - 'private secretum: string'
      py:
          - '_secretum: str'
      rs:
          - 'secretum: String,'
      cpp:
          - 'std::string secretum'
      zig:
          - 'secretum: []const u8'
      fab:
          - 'genus Persona'
          - '@ privatum'
          - 'textus secretum'

# Static fields
- name: genus with static field
  faber: 'genus Config { generis textus VERSION: "1.0" }'
  expect:
      ts:
          - 'static VERSION: string = "1.0"'
      py:
          - 'VERSION: str = "1.0"'
      rs:
          - 'struct Config'
      cpp:
          - 'struct Config'
      zig:
          - 'const Config = struct'
      fab:
          - 'genus Config'
          - 'generis textus VERSION: "1.0"'

# =============================================================================
# Methods
# =============================================================================

# Simple method
- name: genus with method
  faber: |
      genus Persona {
        textus nomen
        functio saluta() -> textus {
          redde nomen
        }
      }
  expect:
      ts:
          - 'class Persona'
          - 'saluta(): string'
          - 'return nomen'
      py:
          - 'class Persona:'
          - 'def saluta(self) -> str:'
          - 'return nomen'
      rs:
          - 'struct Persona'
          - 'impl Persona'
      cpp:
          - 'struct Persona'
          - 'std::string saluta()'
      zig:
          - 'const Persona = struct'
          - 'pub fn saluta(self: *const Self)'
      fab:
          - 'genus Persona'
          - 'textus nomen'
          - 'functio saluta() -> textus'
          - 'redde nomen'

# =============================================================================
# Constructor (creo)
# =============================================================================

# Genus with creo initialization
- name: genus with creo method
  faber: |
      genus Persona {
        numerus aetas
        functio creo() {
          si aetas < 0 {
            aetas = 0
          }
        }
      }
  expect:
      ts:
          - 'class Persona'
          - 'private creo()'
          - 'this.creo()'
      py:
          - 'class Persona:'
          - 'def _creo(self):'
          - 'self._creo()'
      rs:
          - 'struct Persona'
          - 'impl Persona'
          - 'pub fn new()'
      cpp:
          - 'struct Persona'
          - 'void _creo()'
          - '_creo();'
      zig:
          - 'const Persona = struct'
          - 'fn creo(self: *Self) void'
          - 'self.creo()'
      fab:
          - 'genus Persona'
          - 'numerus aetas'
          - 'functio creo()'
          - 'si aetas < 0'
          - 'aetas = 0'

# =============================================================================
# Type Parameters (Generics)
# =============================================================================

# Generic genus with type parameter
- name: genus with type parameter
  faber: 'genus Box<T> { T value }'
  expect:
      ts:
          - 'class Box<T>'
          - 'value: T'
      py:
          - 'class Box[T]:'
          - 'value: T'
      rs:
          - 'struct Box<T>'
          - 'pub value: T,'
      cpp:
          - 'struct Box'
      zig:
          - 'const Box = struct'
          - 'value: T'
      fab:
          - 'genus Box<T>'
          - 'T value'

# =============================================================================
# Implements (Interface Implementation)
# =============================================================================

# Genus implementing interface
- name: genus implementing pactum
  faber: 'genus Reader implet Legibilis { functio lege() -> textus { redde "" } }'
  expect:
      ts:
          - 'class Reader implements Legibilis'
      py:
          - 'class Reader(Legibilis):'
      rs:
          - 'struct Reader'
      cpp:
          - 'struct Reader'
      zig:
          - 'const Reader = struct'
      fab:
          - 'genus Reader implet Legibilis'
          - 'functio lege() -> textus'
          - 'redde ""'

# =============================================================================
# Edge Cases
# =============================================================================

# Genus with many fields (6+)
- name: genus with many fields
  faber: |
      genus Entity {
        textus id
        textus nomen
        numerus aetas
        textus email
        numerus createdAt
        textus status
      }
  expect:
      ts:
          - 'class Entity'
          - 'id: string'
          - 'nomen: string'
          - 'aetas: number'
          - 'email: string'
          - 'createdAt: number'
          - 'status: string'
      py:
          - 'class Entity:'
          - 'id: str'
          - 'nomen: str'
          - 'aetas: int'
          - 'email: str'
          - 'createdAt: int'
          - 'status: str'
      fab:
          - 'genus Entity'
          - 'textus id'
          - 'textus nomen'
          - 'numerus aetas'
          - 'textus email'
          - 'numerus createdAt'
          - 'textus status'

# Genus with multiple methods
- name: genus with multiple methods
  faber: |
      genus Calculator {
        numerus value
        functio add(numerus n) -> numerus {
          redde value + n
        }
        functio subtract(numerus n) -> numerus {
          redde value - n
        }
        functio reset() {
          value = 0
        }
      }
  expect:
      ts:
          - 'class Calculator'
          - 'add(n: number): number'
          - 'subtract(n: number): number'
          - 'reset()'
      py:
          - 'class Calculator:'
          - 'def add(self, n: int) -> int:'
          - 'def subtract(self, n: int) -> int:'
          - 'def reset(self):'
      fab:
          - 'genus Calculator'
          - 'numerus value'
          - 'functio add(numerus n) -> numerus'
          - 'redde value + n'
          - 'functio subtract(numerus n) -> numerus'
          - 'redde value - n'
          - 'functio reset()'
          - 'value = 0'

# Genus with static method (generis)
# WHY: generis modifier should produce static methods, but codegen may not support it yet
- name: genus with static method
  skip:
      - ts
      - py
      - rs
      - cpp
      - zig
      - fab
  faber: |
      genus Factory {
        textus nomen
        generis functio create() -> textus {
          redde "created"
        }
      }
  expect:
      ts:
          - 'class Factory'
          - 'static create(): string'
      py:
          - 'class Factory:'
          - '@classmethod'
      fab:
          - 'genus Factory'
          - 'textus nomen'
          - 'generis functio create() -> textus'
          - 'redde "created"'

# Genus with nested method calls on ego
- name: genus with nested ego method calls
  faber: |
      genus Node {
        textus data
        Node? parent
        functio rootData() -> textus {
          redde ego.parent.data
        }
      }
  expect:
      ts:
          - 'class Node'
          - 'parent: Node | null'
          - 'rootData(): string'
          - 'return this.parent.data'
      py:
          - 'class Node:'
          - 'parent: Node | None'
          - 'def rootData(self) -> str:'
          - 'return self.parent.data'
      fab:
          - 'genus Node'
          - 'textus data'
          - 'Node? parent'
          - 'functio rootData() -> textus'
          - 'redde ego.parent.data'

# Genus with computed method
- name: genus with computed method
  faber: |
      genus Rectangle {
        numerus width
        numerus height
        functio area() -> numerus {
          redde width * height
        }
      }
  expect:
      ts:
          - 'class Rectangle'
          - 'width: number'
          - 'height: number'
          - 'area(): number'
          - 'return (width * height)'
      py:
          - 'class Rectangle:'
          - 'width: int'
          - 'height: int'
          - 'def area(self) -> int:'
          - 'return (width * height)'
      fab:
          - 'genus Rectangle'
          - 'numerus width'
          - 'numerus height'
          - 'functio area() -> numerus'
          - 'redde width * height'

# Genus implementing multiple interfaces
- name: genus implementing multiple interfaces
  faber: 'genus Service implet Readable, Writable { functio read() -> textus { redde "" } functio write(textus data) { } }'
  expect:
      ts:
          - 'class Service implements Readable, Writable'
      py:
          - 'class Service(Readable, Writable):'
      fab:
          - 'genus Service implet Readable, Writable'
          - 'functio read() -> textus'
          - 'functio write(textus data)'

# Empty genus (no fields or methods)
- name: empty genus
  faber: 'genus Empty { }'
  expect:
      ts:
          - 'class Empty'
      py:
          - 'class Empty:'
      fab:
          - 'genus Empty'

# Genus with generic type parameter
- name: genus with generic type parameter
  faber: 'genus Container<T> { T value }'
  expect:
      ts:
          - 'class Container<T>'
          - 'value: T'
      py:
          - 'class Container[T]:'
          - 'value: T'
      fab:
          - 'genus Container<T>'
          - 'T value'

# =============================================================================
# Inheritance (sub)
# =============================================================================

# Genus extending another genus
- name: genus with sub inheritance
  faber: 'genus Employee sub Persona { textus title }'
  expect:
      ts:
          - 'class Employee extends Persona'
          - 'title: string'
      fab:
          - 'genus Employee sub Persona'
          - 'textus title'

# Genus with sub and implet
- name: genus with sub and implet
  faber: 'genus Manager sub Employee implet Leader { functio lead() { } }'
  expect:
      ts:
          - 'class Manager extends Employee implements Leader'
          - 'lead()'
      fab:
          - 'genus Manager sub Employee implet Leader'
          - 'functio lead()'

# =============================================================================
# Abstract Classes and Methods
# =============================================================================

# Abstract genus
- name: abstract genus with abstract method
  faber: |
      @ abstractum
      genus Animal {
          @ abstracta
          functio speak() -> textus
      }
  expect:
      ts:
          - 'abstract class Animal'
          - 'abstract speak(): string'
      fab:
          - '@ abstractum'
          - 'genus Animal'
          - '@ abstracta'
          - 'functio speak() -> textus'

# Concrete genus extending abstract
- name: genus extending abstract class
  faber: |
      genus Dog sub Animal {
        functio speak() -> textus {
          redde "woof"
        }
      }
  expect:
      ts:
          - 'class Dog extends Animal'
          - 'speak(): string'
          - 'return "woof"'
      fab:
          - 'genus Dog sub Animal'
          - 'functio speak() -> textus'
          - 'redde "woof"'

# =============================================================================
# Protected Fields and Methods
# =============================================================================

# Protected field
- name: genus with protected field
  faber: |
      genus Animal {
          @ protectum
          textus species
      }
  expect:
      ts:
          - 'class Animal'
          - 'protected species: string'
      fab:
          - 'genus Animal'
          - '@ protectum'
          - 'textus species'

# Protected method
- name: genus with protected method
  faber: |
      genus Animal {
          @ protecta
          functio internal() { }
      }
  expect:
      ts:
          - 'class Animal'
          - 'protected internal()'
      fab:
          - 'genus Animal'
          - '@ protecta'
          - 'functio internal()'
