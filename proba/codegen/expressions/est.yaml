# Est expressions - type checking operator
# Maps Faber "est" (is) to typeof/instanceof equivalents

- name: est with primitive string
  faber: fixum check = x est textus
  expect:
      ts:
          - 'typeof x === "string"'
      py:
          - 'isinstance(x, str)'
      rs:
          - 'let check = matches!(x, textus);'
      cpp:
          - 'std::is_same_v<std::decay_t<decltype(x)>, std::string>'
      zig:
          - '@TypeOf(x) == []const u8'
      fab:
          - 'x est textus'

- name: est with primitive number
  faber: fixum check = x est numerus
  expect:
      ts:
          - 'typeof x === "number"'
      py:
          - 'isinstance(x, int)'
      rs:
          - 'let check = matches!(x, numerus);'
      cpp:
          - 'std::is_same_v<std::decay_t<decltype(x)>, int64_t>'
      zig:
          - '@TypeOf(x) == i64'
      fab:
          - 'x est numerus'

- name: non est negated check
  faber: fixum check = x non est numerus
  expect:
      ts:
          - 'typeof x !== "number"'
      py:
          - 'not isinstance(x, int)'
      rs:
          - 'let check = !matches!(x, numerus);'
      cpp:
          - '!std::is_same_v<std::decay_t<decltype(x)>, int64_t>'
      zig:
          - '@TypeOf(x) != i64'
      fab:
          - 'x non est numerus'

- name: est with user type
  faber: fixum check = obj est Persona
  expect:
      ts:
          - 'instanceof Persona'
      py:
          - 'isinstance(obj, Persona)'
      rs:
          - 'let check = matches!(obj, Persona);'
      cpp:
          - 'std::is_same_v<std::decay_t<decltype(obj)>, Persona>'
      zig:
          - '@TypeOf(obj) == Persona'
      fab:
          - 'obj est Persona'

- name: est with array type
  faber: fixum check = x est lista<numerus>
  expect:
      ts:
          - 'Array.isArray(x)'
      py:
          - 'isinstance(x, list)'
      fab:
          - 'x est lista<numerus>'

- name: est with nullable type
  faber: fixum check = x est textus?
  expect:
      ts:
          - 'typeof x === "string" || x === null'
      py:
          - 'isinstance(x, str) or x is None'
      fab:
          - 'x est textus?'

- name: chained est checks
  faber: x est numerus et x > 0
  expect:
      ts:
          - 'typeof x === "number"'
          - 'x > 0'
      py:
          - 'isinstance(x, int)'
          - 'x > 0'
      cpp:
          - 'std::is_same_v<std::decay_t<decltype(x)>, int64_t>'
          - 'x > 0'
      zig:
          - '@TypeOf(x) == i64'
          - 'x > 0'
      fab:
          - 'x est numerus'
          - 'x > 0'

- name: est in conditional
  faber: |
      si data est textus { scribe data }
  expect:
      ts:
          - 'if (typeof data === "string")'
      py:
          - 'if isinstance(data, str)'
      cpp:
          - 'if (std::is_same_v<std::decay_t<decltype(data)>, std::string>)'
      zig:
          - 'if ((@TypeOf(data) == []const u8))'
      fab:
          - 'si data est textus'
          - 'scribe data'

- name: est with nihil
  faber: fixum isNull = x est nihil
  expect:
      ts:
          - 'x === null'
      py:
          - 'x is None'
      fab:
          - 'x est nihil'

- name: est with bivalens
  faber: fixum isBool = x est bivalens
  expect:
      ts:
          - 'typeof x === "boolean"'
      py:
          - 'isinstance(x, bool)'
      cpp:
          - 'std::is_same_v<std::decay_t<decltype(x)>, bool>'
      zig:
          - '@TypeOf(x) == bool'
      fab:
          - 'x est bivalens'

- name: non est with primitive
  faber: fixum notNum = x non est numerus
  expect:
      ts:
          - 'typeof x !== "number"'
      py:
          - 'not isinstance(x, int)'
      cpp:
          - '!std::is_same_v<std::decay_t<decltype(x)>, int64_t>'
      zig:
          - '@TypeOf(x) != i64'
      fab:
          - 'x non est numerus'
