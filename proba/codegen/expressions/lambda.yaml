# Lambda expressions - Latin pro syntax for lambdas
# Maps Faber pro/redde to target-language lambda equivalents

- name: lambda with return type (expression body)
  faber: 'pro x -> numerus: x * 2'
  expect:
      ts: '(x): number => (x * 2);'
      py: 'lambda x: (x * 2)'
      rs:
          - '|x| -> i64 { (x * 2) };'
      cpp:
          - '[&](auto x) -> int64_t { return (x * 2); };'
      zig:
          - 'struct { fn call(x: anytype) i64 { return (x * 2); } }.call'
      fab:
          - 'pro x -> numerus:'
          - 'x * 2'

- name: lambda with return type (block body)
  faber: |
      pro x -> numerus {
          redde x * 2
      }
  expect:
      ts:
          - '(x): number =>'
          - 'return (x * 2);'
      py:
          - 'lambda x:'
      rs:
          - '|x| -> i64 {'
          - 'return (x * 2);'
      cpp:
          - '[&](auto x) -> int64_t {'
          - 'return (x * 2);'
      zig:
          - 'struct { fn call(x: anytype) i64 {'
          - 'return (x * 2);'
          - '} }.call'
      fab:
          - 'pro x -> numerus {'
          - 'redde x * 2'

- name: single param lambda
  faber: pro x redde x * 2
  expect:
      ts: '(x) => (x * 2);'
      py: 'lambda x: (x * 2)'
      rs:
          - '|x| (x * 2);'
      cpp:
          - '[&](auto x) { return (x * 2); };'
      zig:
          - 'struct { fn call(x: anytype) i64 { return (x * 2); } }.call'
      fab:
          - 'pro x:'
          - 'x * 2'

- name: multi param lambda
  faber: pro x, y redde x + y
  expect:
      ts: '(x, y) => (x + y);'
      py: 'lambda x, y: (x + y)'
      rs:
          - '|x, y| (x + y);'
      cpp:
          - '[&](auto x, auto y) { return (x + y); };'
      zig:
          - 'struct { fn call(x: anytype, y: anytype) i64 { return (x + y); } }.call'
      fab:
          - 'pro x, y:'
          - 'x + y'

- name: zero param lambda
  faber: pro redde 42
  expect:
      ts: '() => 42;'
      py: 'lambda : 42'
      rs:
          - '|| 42;'
      cpp:
          - '[&]() { return 42; };'
      zig:
          - 'struct { fn call() i64 { return 42; } }.call'
      fab:
          - 'pro:'
          - '42'

- name: lambda in variable
  faber: fixum double = pro x redde x * 2
  expect:
      ts: 'const double = (x) => (x * 2);'
      py: 'double = lambda x: (x * 2)'
      rs:
          - 'let double = |x| (x * 2);'
      cpp:
          - 'const auto double = [&](auto x) { return (x * 2); };'
      zig:
          - 'const double = struct { fn call(x: anytype) i64 { return (x * 2); } }.call'
      fab:
          - 'fixum double = pro x:'
          - 'x * 2'

- name: lambda as callback
  faber: items.filtrata(pro x redde x > 0)
  expect:
      ts: 'items.filter((x) => (x > 0));'
      py:
          - 'filter'
          - 'lambda x: (x > 0)'
      rs:
          - '.iter().filter(|x| (x > 0)).cloned().collect::<Vec<_>>()'
      cpp:
          - '(items | std::views::filter([&](auto x) { return (x > 0); }) | std::ranges::to<std::vector>());'
      fab:
          - 'items.filtrata(pro x:'
          - 'x > 0'

- name: lambda returning lambda (curried)
  faber: fixum curry = pro x redde pro y redde x + y
  expect:
      ts: 'const curry = (x) => (y) => (x + y);'
      py: 'curry = lambda x: lambda y: (x + y)'
      rs:
          - 'let curry = |x| |y| (x + y);'
      cpp:
          - 'const auto curry = [&](auto x) { return [&](auto y) { return (x + y); }; };'
      zig:
          # WHY: Inner lambda return type is a function, which becomes anytype (invalid in Zig)
          - 'struct { fn call(x: anytype) anytype { return struct { fn call(y: anytype) i64 { return (x + y); } }.call; } }.call'
      fab:
          - 'fixum curry = pro x:'
          - 'pro y:'
          - 'x + y'

- name: lambda with block and multiple statements
  faber: |
      pro x {
        varia r = x * 2
        redde r
      }
  expect:
      ts:
          - '(x) => {'
          - 'let r = (x * 2);'
          - 'return r;'
          - '}'
      py:
          - 'lambda x:'
      rs:
          - '|x| {'
          - 'let mut r = (x * 2);'
          - 'r'
          - '}'
      cpp:
          - '[&](auto x) {'
          - 'auto r = (x * 2);'
          - 'return r;'
          - '}'
      zig:
          # WHY: Block body with redde infers void return type
          - 'struct { fn call(x: anytype) void {'
          - 'var r: i64 = (x * 2);'
          - 'return r;'
          - '} }.call'
      fab:
          - 'pro x {'
          - 'varia r = x * 2'
          - 'redde r'

- name: triple nested lambda
  faber: fixum nested = pro a redde pro b redde pro c redde a + b + c
  expect:
      ts: 'const nested = (a) => (b) => (c) => ((a + b) + c);'
      py: 'nested = lambda a: lambda b: lambda c: ((a + b) + c)'
      rs:
          - 'let nested = |a| |b| |c| ((a + b) + c);'
      cpp:
          - 'const auto nested = [&](auto a) { return [&](auto b) { return [&](auto c) { return ((a + b) + c); }; }; };'
      zig:
          # WHY: Nested lambdas return function types which become anytype
          - 'struct { fn call(a: anytype) anytype { return struct { fn call(b: anytype) anytype { return struct { fn call(c: anytype) i64 { return ((a + b) + c); } }.call; } }.call; } }.call'
      fab:
          - 'fixum nested = pro a:'
          - 'pro b:'
          - 'pro c:'
          - 'a + b + c'

- name: lambda capturing outer variable (closure)
  faber: |
      fixum multiplier = 3
      fixum scale = pro x redde x * multiplier
  expect:
      ts:
          - 'const multiplier = 3;'
          - 'const scale = (x) => (x * multiplier);'
      py:
          - 'multiplier = 3'
          - 'scale = lambda x: (x * multiplier)'
      rs:
          - 'let multiplier = 3;'
          - 'let scale = |x| (x * multiplier);'
      cpp:
          - 'const auto multiplier = 3;'
          - 'const auto scale = [&](auto x) { return (x * multiplier); };'
      zig:
          # NOTE: This compiles but will fail at Zig compile time - closures not supported
          - 'const multiplier = 3;'
          - 'const scale = struct { fn call(x: anytype) i64 { return (x * multiplier); } }.call'
      fab:
          - 'fixum multiplier = 3'
          - 'fixum scale = pro x:'
          - 'x * multiplier'

- name: lambda immediately invoked
  faber: fixum result = (pro x redde x * 2)(5)
  expect:
      ts: 'const result = (x) => (x * 2)(5);'
      py: 'result = lambda x: (x * 2)(5)'
      rs:
          - 'let result = |x| (x * 2)(5);'
      cpp:
          - 'const auto result = [&](auto x) { return (x * 2); }(5);'
      zig:
          - 'const result = struct { fn call(x: anytype) i64 { return (x * 2); } }.call(5)'
      fab:
          - 'fixum result ='
          - 'pro x:'
          - 'x * 2'
          - '(5)'
