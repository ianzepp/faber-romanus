# Binary expressions - arithmetic, comparison, logical operators
# Maps Faber binary operators to target-language equivalents

- name: addition
  faber: 1 + 2
  expect:
      ts: '(1 + 2);'
      py: '(1 + 2)'
      rs:
          - '(1 + 2);'
      cpp:
          - '(1 + 2)'
      zig:
          - '(1 + 2)'
      fab:
          - '1 + 2'

- name: subtraction
  faber: 5 - 3
  expect:
      ts: '(5 - 3);'
      py: '(5 - 3)'
      rs:
          - '(5 - 3);'
      cpp:
          - '(5 - 3)'
      zig:
          - '(5 - 3)'
      fab:
          - '5 - 3'

- name: multiplication
  faber: 4 * 2
  expect:
      ts: '(4 * 2);'
      py: '(4 * 2)'
      rs:
          - '(4 * 2);'
      cpp:
          - '(4 * 2)'
      zig:
          - '(4 * 2)'
      fab:
          - '4 * 2'

- name: division
  faber: 10 / 2
  expect:
      ts: '(10 / 2);'
      py: '(10 / 2)'
      rs:
          - '(10 / 2);'
      cpp:
          - '(10 / 2)'
      zig:
          - '@divTrunc(10, 2)'
      fab:
          - '10 / 2'

- name: equality comparison
  faber: a == b
  expect:
      ts: '(a == b);'
      py: '(a == b)'
      rs:
          - '(a == b);'
      cpp:
          - '(a == b)'
      fab:
          - 'a == b'

- name: logical and with et
  faber: a et b
  expect:
      ts: '(a && b);'
      py: '(a and b)'
      rs:
          - '(a && b);'
      cpp:
          - '(a && b)'
      zig:
          - '(a and b)'
      fab:
          - 'a && b'

- name: operator precedence - multiplication before addition
  faber: 1 + 2 * 3
  expect:
      ts: '(1 + (2 * 3));'
      py: '(1 + (2 * 3))'
      rs:
          - '(1 + (2 * 3));'
      cpp:
          - '(1 + (2 * 3))'
      zig:
          - '(1 + (2 * 3))'
      fab:
          - '1 + 2 * 3'

- name: operator precedence with parentheses
  faber: (1 + 2) * 3
  expect:
      ts: '((1 + 2) * 3);'
      py: '((1 + 2) * 3)'
      rs:
          - '((1 + 2) * 3);'
      cpp:
          - '((1 + 2) * 3)'
      zig:
          - '((1 + 2) * 3)'
      fab:
          - '(1 + 2) * 3'

- name: logical aut (OR) operator
  faber: a aut b
  expect:
      ts: '(a || b);'
      py: '(a or b)'
      rs:
          - '(a || b);'
      cpp:
          - '(a || b)'
      zig:
          - '(a or b)'
      fab:
          - 'a || b'

- name: inequality comparison
  faber: a != b
  expect:
      ts: '(a != b);'
      py: '(a != b)'
      rs:
          - '(a != b);'
      cpp:
          - '(a != b)'
      zig:
          - '(a != b)'
      fab:
          - 'a != b'

- name: less than or equal
  faber: a <= b
  expect:
      ts: '(a <= b);'
      py: '(a <= b)'
      rs:
          - '(a <= b);'
      cpp:
          - '(a <= b)'
      zig:
          - '(a <= b)'
      fab:
          - 'a <= b'

- name: greater than or equal
  faber: a >= b
  expect:
      ts: '(a >= b);'
      py: '(a >= b)'
      rs:
          - '(a >= b);'
      cpp:
          - '(a >= b)'
      zig:
          - '(a >= b)'
      fab:
          - 'a >= b'

- name: mixed logical operators (precedence)
  faber: a et b aut c
  expect:
      ts: '((a && b) || c);'
      py: '((a and b) or c)'
      rs:
          - '((a && b) || c);'
      cpp:
          - '((a && b) || c)'
      zig:
          - '((a and b) or c)'
      fab:
          - 'a && b || c'

- name: chained comparisons pattern
  faber: a < b et b < c
  expect:
      ts: '((a < b) && (b < c));'
      py: '((a < b) and (b < c))'
      rs:
          - '((a < b) && (b < c));'
      cpp:
          - '((a < b) && (b < c))'
      zig:
          - '((a < b) and (b < c))'
      fab:
          - 'a < b && b < c'

- name: deeply nested binary expressions
  faber: ((a + b) * (c - d)) / ((e + f) - (g * h))
  expect:
      ts: '(((a + b) * (c - d)) / ((e + f) - (g * h)));'
      py: '(((a + b) * (c - d)) / ((e + f) - (g * h)))'
      rs:
          - '(((a + b) * (c - d)) / ((e + f) - (g * h)));'
      cpp:
          - '(((a + b) * (c - d)) / ((e + f) - (g * h)))'
      zig:
          - '@divTrunc(((a + b) * (c - d)), ((e + f) - (g * h)))'
      fab:
          - '(a + b) * (c - d) / ((e + f) - g * h)'

# WHY: String concat with + is intentionally unsupported for Zig target.
#      Users should use scriptum() for formatted strings instead.
#      See proba/codegen/expressions/scriptum.yaml for Zig string formatting tests.
- name: string concatenation
  faber: '"hello" + " " + "world"'
  skip: [zig]
  expect:
      ts: '(("hello" + " ") + "world");'
      py: '(("hello" + " ") + "world")'
      rs:
          - '((String::from("hello") + String::from(" ")) + String::from("world"));'
      cpp:
          - '((std::string("hello") + std::string(" ")) + std::string("world"))'
      fab:
          - '"hello" + " " + "world"'

- name: modulo operator
  faber: 10 % 3
  expect:
      ts: '(10 % 3);'
      py: '(10 % 3)'
      rs:
          - '(10 % 3);'
      cpp:
          - '(10 % 3)'
      zig:
          - '@mod(10, 3)'
      fab:
          - '10 % 3'

- name: nullish coalescing (vel)
  faber: value vel defaultValue
  expect:
      ts: '(value ?? defaultValue);'
      py: '(value if value is not None else defaultValue)'
      rs:
          - '(value ?? defaultValue);'
      cpp:
          - '(value != nullptr ? value : defaultValue)'
      zig:
          - '(value orelse defaultValue)'
      fab:
          - 'value ?? defaultValue'

- name: range containment with intra (exclusive end)
  faber: x intra 0..100
  expect:
      ts: '(x >= 0 && x < 100);'
      py: '(x >= 0 and x < 100)'
      rs:
          - '(x >= 0 && x < 100);'
      cpp:
          - '(x >= 0 && x < 100)'
      zig:
          - '(x >= 0 and x < 100)'
      fab:
          - 'x intra 0..100'

- name: range containment with intra (inclusive end with usque)
  faber: age intra 18 usque 65
  expect:
      ts: '(age >= 18 && age <= 65);'
      py: '(age >= 18 and age <= 65)'
      rs:
          - '(age >= 18 && age <= 65);'
      cpp:
          - '(age >= 18 && age <= 65)'
      zig:
          - '(age >= 18 and age <= 65)'
      fab:
          - 'age intra 18 usque 65'

- name: range containment with intra (explicit exclusive with ante)
  faber: x intra 0 ante 10
  expect:
      ts: '(x >= 0 && x < 10);'
      py: '(x >= 0 and x < 10)'
      rs:
          - '(x >= 0 && x < 10);'
      cpp:
          - '(x >= 0 && x < 10)'
      zig:
          - '(x >= 0 and x < 10)'
      fab:
          - 'x intra 0 ante 10'

- name: set membership with inter (numeric array)
  faber: age inter [18, 21, 65]
  expect:
      ts: '[18, 21, 65].includes(age);'
      py: 'age in [18, 21, 65]'
      rs:
          - '[18, 21, 65].contains(&age);'
      cpp:
          - 'std::ranges::contains(std::vector{18, 21, 65}, age)'
      zig:
          - '(std.mem.indexOfScalar(i64, .{ 18, 21, 65 }, age) != null)'
      fab:
          - 'age inter [18, 21, 65]'

- name: set membership with inter (string array)
  faber: status inter ["pending", "active", "paused"]
  expect:
      ts: '["pending", "active", "paused"].includes(status);'
      py: 'status in ["pending", "active", "paused"]'
      rs:
          - '[String::from("pending"), String::from("active"), String::from("paused")].contains(&status);'
      cpp:
          - 'std::ranges::contains(std::vector{std::string("pending"), std::string("active"), std::string("paused")}, status)'
      zig:
          - '(std.mem.indexOfScalar(i64, .{ "pending", "active", "paused" }, status) != null)'
      fab:
          - 'status inter ["pending", "active", "paused"]'

- name: character range containment with intra (exclusive)
  faber: c intra "a".."z"
  expect:
      ts: '(c >= "a" && c < "z");'
      py: '(c >= "a" and c < "z")'
      rs:
          - '(c >= String::from("a") && c < String::from("z"));'
      cpp:
          - '(c >= std::string("a") && c < std::string("z"))'
      zig:
          - '(c >= "a" and c < "z")'
      fab:
          - 'c intra "a".."z"'

- name: character range containment with intra (inclusive)
  faber: c intra "a" usque "z"
  expect:
      ts: '(c >= "a" && c <= "z");'
      py: '(c >= "a" and c <= "z")'
      rs:
          - '(c >= String::from("a") && c <= String::from("z"));'
      cpp:
          - '(c >= std::string("a") && c <= std::string("z"))'
      zig:
          - '(c >= "a" and c <= "z")'
      fab:
          - 'c intra "a" usque "z"'

- name: character range containment for hex digits
  faber: c intra "0".."9" aut c intra "a".."f" aut c intra "A".."F"
  expect:
      ts: '(((c >= "0" && c < "9") || (c >= "a" && c < "f")) || (c >= "A" && c < "F"));'
      py: '(((c >= "0" and c < "9") or (c >= "a" and c < "f")) or (c >= "A" and c < "F"))'
      rs:
          - '(((c >= String::from("0") && c < String::from("9")) || (c >= String::from("a") && c < String::from("f"))) || (c >= String::from("A") && c < String::from("F")));'
      cpp:
          - '(((c >= std::string("0") && c < std::string("9")) || (c >= std::string("a") && c < std::string("f"))) || (c >= std::string("A") && c < std::string("F")))'
      zig:
          - '(((c >= "0" and c < "9") or (c >= "a" and c < "f")) or (c >= "A" and c < "F"))'
      fab:
          - 'c intra "0".."9" || c intra "a".."f" || c intra "A".."F"'
