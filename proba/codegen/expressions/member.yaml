# Member expressions - property access, computed access, optional chaining
# Maps Faber member access to target-language equivalents

- name: simple property access
  faber: usuario.nomen
  expect:
      ts: 'usuario.nomen;'
      py: 'usuario.nomen'
      rs:
          - 'usuario.nomen;'
      cpp:
          - 'usuario.nomen;'
      zig:
          - 'usuario.nomen'
      fab:
          - 'usuario.nomen'

- name: computed access with variable
  faber: obj[key]
  expect:
      ts: 'obj[key];'
      py: 'obj[key]'
      rs:
          - 'obj[key];'
      cpp:
          - 'obj[key];'
      fab:
          - 'obj[key]'

- name: computed access with literal
  faber: arr[0]
  expect:
      ts: 'arr[0];'
      py: 'arr[0]'
      rs:
          - 'arr[0];'
      cpp:
          - 'arr[0];'
      fab:
          - 'arr[0]'

- name: optional property access
  faber: user?.name
  expect:
      ts: 'user?.name;'
      py:
          - 'user.name if user is not None else None'
      rs:
          - 'user.as_ref().map'
          - '.name'
      cpp:
          - 'user ? user->name : std::nullopt'
      zig:
          - 'if (user)'
          - '_o.name'
          - 'else null'
      fab:
          - 'user?.name'

- name: optional computed access
  faber: arr?[0]
  expect:
      ts: 'arr?.[0];'
      py:
          - 'arr[0] if arr is not None else None'
      rs:
          - 'arr.get(0);'
      cpp:
          - 'arr ? (*arr)[0] : std::nullopt'
      zig:
          - 'if (arr)'
          - '_o[0]'
          - 'else null'
      fab:
          - 'arr?[0]'

- name: non-null property access
  faber: user!.name
  expect:
      ts: 'user!.name;'
      py: 'user.name'
      rs:
          - 'user.name;'
      cpp:
          - 'user->name;'
      zig:
          - 'user.?.name'
      fab:
          - 'user!.name'

- name: very long member chain
  faber: a.b.c.d.e.f.g
  expect:
      ts: 'a.b.c.d.e.f.g;'
      py: 'a.b.c.d.e.f.g'
      zig:
          - 'a.b.c.d.e.f.g'
      fab:
          - 'a.b.c.d.e.f.g'

- name: mixed optional and non-optional chain
  faber: a?.b.c?.d.e
  expect:
      ts: 'a?.b.c?.d.e;'
      py:
          - 'a.b.c.d.e if a is not None'
          - 'and a.b.c is not None else None'
      fab:
          - 'a?.b.c?.d.e'

- name: computed access with expression
  faber: arr[i * 2 + 1]
  expect:
      ts: 'arr[i * 2 + 1];'
      py: 'arr[i * 2 + 1]'
      zig:
          - 'arr[i * 2 + 1]'
      fab:
          - 'arr[i * 2 + 1]'

- name: computed access with string key
  faber: obj["property-name"]
  expect:
      ts: 'obj["property-name"];'
      py: 'obj["property-name"]'
      zig:
          - 'obj["property-name"]'
      fab:
          - 'obj["property-name"]'

- name: member on string literal
  faber: '"hello".length'
  expect:
      ts: '"hello".length;'
      py: 'len("hello")'
      fab:
          - '"hello".length'

- name: member on array literal
  faber: '[1, 2, 3].length'
  expect:
      ts: '[1, 2, 3].length;'
      py: 'len([1, 2, 3])'
      fab:
          - '[1, 2, 3].length'

- name: optional computed then call
  faber: obj?[key]()
  expect:
      ts: 'obj?.[key]();'
      py:
          - 'obj[key]() if obj is not None else None'
      fab:
          - 'obj?[key]()'

- name: non-null after call
  faber: getUser()!.name
  expect:
      ts: 'getUser()!.name;'
      py: 'getUser().name'
      fab:
          - 'getUser()!.name'

- name: computed with template
  faber: obj[`key_${id}`]
  expect:
      ts: 'obj[`key_${id}`];'
      py: 'obj[f"key_{id}"]'
      fab:
          - 'obj[`key_${id}`]'

- name: double computed access
  faber: matrix[i][j]
  expect:
      ts: 'matrix[i][j];'
      py: 'matrix[i][j]'
      zig:
          - 'matrix[i][j]'
      fab:
          - 'matrix[i][j]'

- name: slice with exclusive range
  faber: arr[1..3]
  expect:
      ts: 'arr.slice(1, 3);'
      py: 'arr[1:3]'
      zig:
          - 'arr[1..3]'
      fab:
          - 'arr[1..3]'

- name: slice with inclusive range
  faber: arr[1 usque 3]
  expect:
      ts: 'arr.slice(1, 4);'
      py: 'arr[1:4]'
      zig:
          - 'arr[1..4]'
      fab:
          - 'arr[1 usque 3]'

- name: negative index access
  faber: arr[-1]
  expect:
      ts: 'arr.at(-1);'
      py: 'arr[-1]'
      zig:
          - 'arr[arr.len - 1]'
      fab:
          - 'arr[-1]'

- name: negative slice range
  faber: arr[-3..-1]
  expect:
      ts: 'arr.slice(-3, -1);'
      py: 'arr[-3:-1]'
      zig:
          - 'arr[arr.len - 3..arr.len - 1]'
      fab:
          - 'arr[-3..-1]'

- name: non-null computed access
  faber: arr![0]
  expect:
      ts: 'arr![0];'
      py: 'arr[0]'
      zig:
          - 'arr.?[0]'
      fab:
          - 'arr![0]'

- name: inclusive negative slice (to end)
  faber: arr[-3 usque -1]
  expect:
      ts: 'arr.slice(-3);'
      py: 'arr[-3:]'
      zig:
          - 'arr[arr.len - 3..arr.len]'
      fab:
          - 'arr[-3 usque -1]'
