# Operatores - Operator codegen tests
# Covers: binary, logical, bitwise, compound assignment, ternary

# =============================================================================
# Binary Operators
# =============================================================================

# Basic arithmetic - parentheses added for precedence clarity
- name: 'addition'
  input: '1 + 2'
  ts: '(1 + 2);'
  py: '(1 + 2)'
  cpp:
      - '(1 + 2)'
  zig:
      - '(1 + 2)'

# Function calls pass through unchanged
- name: 'function call'
  input: 'salve(nomen)'
  ts: 'salve(nomen);'
  py: 'salve(nomen)'
  zig:
      - 'salve(nomen)'

# Method calls on objects
- name: 'method call'
  input: 'lista.filter(f)'
  ts: 'lista.filter(f);'
  py: 'lista.filter(f)'

# Property access via dot notation
- name: 'member access'
  input: 'usuario.nomen'
  ts: 'usuario.nomen;'
  py: 'usuario.nomen'
  zig:
      - 'usuario.nomen'

# =============================================================================
# Logical Operators
# =============================================================================

# et is logical AND (&& in TS, 'and' in Python)
- name: 'et becomes and'
  input: 'a et b'
  ts: '(a && b);'
  py: '(a and b)'
  cpp:
      - '(a && b)'
  zig:
      - '(a and b)'

# aut is logical OR (|| in TS, 'or' in Python)
- name: 'aut becomes or'
  input: 'a aut b'
  ts: '(a || b);'
  py: '(a or b)'
  cpp:
      - '(a || b)'
  zig:
      - '(a or b)'

# vel is nullish coalescing (?? in TS, conditional in Python)
- name: 'vel becomes nullish coalescing'
  input: 'a vel b'
  ts: '(a ?? b);'
  py:
      - 'a if a is not None else b'

# vel chains left-to-right
- name: 'vel chains correctly'
  input: 'a vel b vel c'
  ts: '((a ?? b) ?? c);'
  py:
      - 'if'
      - 'is not None'

# =============================================================================
# Bitwise Operators
# =============================================================================

# Bitwise AND - same in both targets
- name: 'bitwise AND'
  input: '5 & 3'
  ts: '(5 & 3);'
  py: '(5 & 3)'
  zig:
      - '(5 & 3)'

# Bitwise OR - same in both targets
- name: 'bitwise OR'
  input: '5 | 3'
  ts: '(5 | 3);'
  py: '(5 | 3)'
  zig:
      - '(5 | 3)'

# Bitwise XOR - same in both targets
- name: 'bitwise XOR'
  input: '5 ^ 3'
  ts: '(5 ^ 3);'
  py: '(5 ^ 3)'
  zig:
      - '(5 ^ 3)'

# Bitwise NOT - same in both targets
- name: 'bitwise NOT'
  input: '~5'
  ts: '~5;'
  py: '~5'
  zig:
      - '~5'

# Left shift - same in both targets
- name: 'left shift'
  input: '1 << 4'
  ts: '(1 << 4);'
  py: '(1 << 4)'
  zig:
      - '(1 << 4)'

# Right shift - same in both targets
- name: 'right shift'
  input: '16 >> 2'
  ts: '(16 >> 2);'
  py: '(16 >> 2)'
  zig:
      - '(16 >> 2)'

# =============================================================================
# Compound Assignment
# =============================================================================

# += operator - same in both targets
- name: 'compound add'
  input: |
      varia x = 0
      x += 1
  ts:
      - 'x += 1'
  py:
      - 'x += 1'
  zig:
      - 'var x: i64 = 0;'
      - 'x += 1;'

# -= operator - same in both targets
- name: 'compound subtract'
  input: |
      varia x = 10
      x -= 1
  ts:
      - 'x -= 1'
  py:
      - 'x -= 1'
  zig:
      - 'var x: i64 = 10;'
      - 'x -= 1;'

# &= bitwise AND assignment
- name: 'compound bitwise AND'
  input: |
      varia flags = 0xFF
      flags &= 0x0F
  ts:
      - 'flags &= 0x0F'
  py:
      - 'flags &= 0x0F'
  zig:
      - 'var flags: i64 = 0xFF;'
      - 'flags &= 0x0F;'

# |= bitwise OR assignment
- name: 'compound bitwise OR'
  input: |
      varia flags = 0
      flags |= 0x01
  ts:
      - 'flags |= 0x01'
  py:
      - 'flags |= 0x01'
  zig:
      - 'var flags: i64 = 0;'
      - 'flags |= 0x01;'

# =============================================================================
# Ternary Operator
# =============================================================================

# condition ? then : else syntax
- name: 'ternary with symbols'
  input: 'verum ? 1 : 0'
  ts: 'true ? 1 : 0;'
  py: '1 if True else 0'
  cpp:
      - '(true ? 1 : 0)'
  zig:
      - '_ = if (true) 1 else 0;'

# Latin sic/secus syntax for ternary
- name: 'ternary with sic secus'
  input: 'verum sic 1 secus 0'
  ts: 'true ? 1 : 0;'
  py: '1 if True else 0'
  zig:
      - '_ = if (true) 1 else 0;'

# Ternary in variable initialization
- name: 'ternary in variable'
  input: 'varia x = verum ? 1 : 0'
  ts: 'let x = true ? 1 : 0;'
  py: 'x = 1 if True else 0'
  zig:
      - 'var x: i64 = if (true) 1 else 0;'

# =============================================================================
# Comparison Operators
# =============================================================================

# Equality - same in both targets
- name: 'equality'
  input: 'a == b'
  ts: '(a == b);'
  py: '(a == b)'
  cpp:
      - '(a == b)'

# Inequality - same in both targets
- name: 'inequality'
  input: 'a != b'
  ts: '(a != b);'
  py: '(a != b)'
  cpp:
      - '(a != b)'

# Less than - same in both targets
- name: 'less than'
  input: 'a < b'
  ts: '(a < b);'
  py: '(a < b)'

# Greater than - same in both targets
- name: 'greater than'
  input: 'a > b'
  ts: '(a > b);'
  py: '(a > b)'

# =============================================================================
# Spread Operator (sparge)
# =============================================================================

# sparge unpacks arrays (... in TS, * in Python)
- name: 'spread in array'
  input: 'fixum combined = [sparge a, sparge b]'
  ts: 'const combined = [...a, ...b];'
  py: 'combined = [*a, *b]'

# sparge in function calls
- name: 'spread in function call'
  input: 'fn(sparge args)'
  ts: 'fn(...args);'
  py: 'fn(*args)'

# sparge unpacks objects (... in TS, ** in Python)
- name: 'spread in object'
  input: 'fixum merged = { sparge defaults, x: 1 }'
  ts: 'const merged = { ...defaults, x: 1 };'
  py: 'merged = {**defaults, "x": 1}'

# =============================================================================
# Rest Operator (ceteri)
# =============================================================================

# ceteri collects remaining elements in array destructuring
- name: 'rest in array destructuring'
  input: 'fixum [first, ceteri rest] = items'
  ts: 'const [first, ...rest] = items;'
  py: 'first, *rest = items'
  zig:
      - 'const _tmp = items'
      - 'const first = _tmp[0]'
      - 'const rest = _tmp[1..]'

# ceteri as function parameter collects variadic args
- name: 'rest in function params'
  input: 'functio sum(ceteri lista<numerus> nums) { redde 0 }'
  ts:
      - '...nums: Array<number>'
  py:
      - '*nums: list[int]'

# =============================================================================
# Optional Chaining
# =============================================================================

# ?. safely accesses properties (conditional in Python)
- name: 'optional property access'
  input: 'user?.name'
  ts: 'user?.name;'
  py:
      - 'user.name if user is not None else None'

# ?[ safely accesses array elements
- name: 'optional computed access'
  input: 'arr?[0]'
  ts: 'arr?.[0];'
  py:
      - 'arr[0] if arr is not None else None'

# ?( safely calls functions
- name: 'optional call'
  input: 'callback?()'
  ts: 'callback?.();'
  py:
      - 'callback() if callback is not None else None'

# =============================================================================
# Non-null Assertion
# =============================================================================

# !. asserts non-null then accesses (Python ignores assertion)
- name: 'non-null property access'
  input: 'user!.name'
  ts: 'user!.name;'
  py: 'user.name'

# ![ asserts non-null then indexes
- name: 'non-null computed access'
  input: 'arr![0]'
  ts: 'arr![0];'
  py: 'arr[0]'

# =============================================================================
# Computed Member Access
# =============================================================================

# Dynamic property access via brackets
- name: 'computed access with variable'
  input: 'obj[key]'
  ts: 'obj[key];'
  py: 'obj[key]'

# Literal index access
- name: 'computed access with literal'
  input: 'arr[0]'
  ts: 'arr[0];'
  py: 'arr[0]'

# =============================================================================
# Negative Indexing
# =============================================================================

# Negative indices use .at() in TS, native in Python
- name: 'negative index uses at'
  input: 'fixum x = nums[-1]'
  ts: 'const x = nums.at(-1);'
  py: 'x = nums[-1]'
  zig:
      - 'nums[nums.len - 1]'

# =============================================================================
# Slicing
# =============================================================================

# Exclusive range slicing (.. operator)
- name: 'slice with exclusive range'
  input: 'fixum x = nums[1..3]'
  ts: 'const x = nums.slice(1, 3);'
  py: 'x = nums[1:3]'
  zig:
      - 'nums[1..3]'

# Inclusive range slicing (usque operator) - end+1 for both targets
- name: 'slice with inclusive range'
  input: 'fixum x = nums[0 usque 2]'
  ts: 'const x = nums.slice(0, 3);'
  py: 'x = nums[0:3]'
  zig:
      - 'nums[0..3]'

# =============================================================================
# Type Cast (ut)
# =============================================================================

# ut casts expression to type (as in TS, ignored in Python)
- name: 'simple type cast'
  input: 'fixum name = data ut textus'
  ts: 'const name = (data as string);'
  py: 'name = data'

# Cast member expression
- name: 'cast member expression'
  input: 'fixum body = response.body ut objectum'
  ts: 'const body = (response.body as object);'
  py: 'body = response.body'

# =============================================================================
# Type Check (est)
# =============================================================================

# est with primitive uses typeof in TS, isinstance in Python
- name: 'est with primitive typeof'
  input: 'fixum check = x est textus'
  ts:
      - 'typeof x === "string"'
  py:
      - 'isinstance(x, str)'

# non est negates the check
- name: 'non est negated'
  input: 'fixum check = x non est numerus'
  ts:
      - 'typeof x !== "number"'
  py:
      - 'not isinstance(x, int)'

# est with user type uses instanceof
- name: 'est with user type instanceof'
  input: 'fixum check = obj est Persona'
  ts:
      - 'instanceof Persona'
  py:
      - 'isinstance(obj, Persona)'

# =============================================================================
# Null Check Operators
# =============================================================================

# nihil unary checks if value is null
- name: 'nihil unary'
  input: 'si nihil x { scribe "null" }'
  ts:
      - '(x === null)'
  py:
      - '(x is None)'
  zig:
      - '(x == null)'

# nonnihil unary checks if value is not null
- name: 'nonnihil unary'
  input: 'si nonnihil x { scribe "not null" }'
  ts:
      - '(x !== null)'
  py:
      - '(x is not None)'
  zig:
      - '(x != null)'
