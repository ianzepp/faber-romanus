# Regimen - Control flow codegen tests
# Covers: si/aliter, dum, ex/de...pro, elige, custodi, adfirma, redde/rumpe/perge

# =============================================================================
# If Statements
# =============================================================================

# si is the if keyword - verum becomes true/True
- name: 'simple if'
  input: |
      si verum {
        scribe "yes"
      }
  ts:
      - 'if (true)'
      - 'console.log("yes")'
  py:
      - 'if True:'
      - 'print("yes")'
  cpp:
      - 'if (true)'
  zig:
      - 'if (true)'

# aliter is the else keyword
- name: 'if with else'
  input: |
      si falsum {
        a()
      }
      aliter {
        b()
      }
  ts:
      - 'if (false)'
      - '} else {'
  py:
      - 'if False:'
      - 'else:'
  cpp:
      - 'if (false)'
      - '} else {'
  zig:
      - 'if (false)'
      - '} else {'

# aliter si chains become else if/elif
- name: 'if-elif-else chain'
  input: |
      si x == 1 { a() }
      aliter si x == 2 { b() }
      aliter { c() }
  ts:
      - 'if ((x == 1))'
      - 'else if ((x == 2))'
      - 'else {'
  py:
      - 'if (x == 1):'
      - 'elif (x == 2):'
      - 'else:'

# =============================================================================
# While Loops
# =============================================================================

# dum is the while keyword
- name: 'while loop'
  input: |
      dum verum {
        scribe "loop"
      }
  ts:
      - 'while (true)'
  py:
      - 'while True:'
  cpp:
      - 'while (true)'
  zig:
      - 'while (true)'

# =============================================================================
# For Loops
# =============================================================================

# ex...pro is for-of (iterate values)
- name: 'for-of loop'
  input: |
      ex numeros pro numero {
        scribe numero
      }
  ts:
      - 'for (const numero of numeros)'
  py:
      - 'for numero in numeros:'
  cpp:
      - 'for (auto& numero : numeros)'

# de...pro is for-in (iterate keys/indices)
- name: 'for-in loop'
  input: |
      de lista pro item {
        scribe item
      }
  ts:
      - 'for (const item in lista)'
  py:
      - 'for item in lista:'

# =============================================================================
# Range Loops
# =============================================================================

# .. creates exclusive range (0..10 = 0 to 9)
- name: 'simple range loop'
  input: |
      ex 0..10 pro i {
        scribe i
      }
  ts:
      - 'for (let i = 0; i < 10; i++)'
  py:
      - 'for i in range(0, 10):'
  cpp:
      - 'for (int64_t i = 0; i < 10; i += 1)'
  zig:
      - 'var i: usize = 0'
      - 'while (i < 10)'
      - '(i += 1)'

# per specifies step size
- name: 'range with step'
  input: |
      ex 0..10 per 2 pro i {
        scribe i
      }
  ts:
      - 'for (let i = 0; i < 10; i += 2)'
  py:
      - 'for i in range(0, 10, 2):'
  zig:
      - 'while (i < 10)'
      - '(i += 2)'

# usque creates inclusive range (0 usque 10 = 0 to 10)
- name: 'inclusive range loop'
  input: |
      ex 0 usque 10 pro i {
        scribe i
      }
  ts:
      - 'for (let i = 0; i <= 10; i++)'
  py:
      - 'for i in range(0, 10 + 1):'
  cpp:
      - 'for (int64_t i = 0; i <= 10; i += 1)'
  zig:
      - 'while (i <= 10)'

# =============================================================================
# Break and Continue
# =============================================================================

# rumpe is break
- name: 'break statement'
  input: |
      dum verum {
        rumpe
      }
  ts:
      - 'break;'
  py:
      - 'break'

# perge is continue
- name: 'continue statement'
  input: |
      dum verum {
        perge
      }
  ts:
      - 'continue;'
  py:
      - 'continue'

# =============================================================================
# Return
# =============================================================================

# redde with value returns that value
- name: 'return with value'
  input: |
      functio f() {
        redde 42
      }
  ts:
      - 'return 42;'
  py:
      - 'return 42'

# redde without value returns undefined/None
- name: 'return without value'
  input: |
      functio f() {
        redde
      }
  ts:
      - 'return;'
  py:
      - 'return'

# =============================================================================
# Assert
# =============================================================================

# adfirma is assert - TS emits if(!condition) throw, Python uses assert
- name: 'assert without message'
  input: 'adfirma x > 0'
  ts:
      - 'if (!('
      - 'throw new Error'
  py: 'assert (x > 0)'
  zig:
      - 'std.debug.assert'

# adfirma with message includes that in the error
- name: 'assert with message'
  input: 'adfirma x > 0, "x must be positive"'
  ts:
      - 'throw new Error("x must be positive")'
  py: 'assert (x > 0), "x must be positive"'
  zig:
      - 'if (!((x > 0)))'
      - '@panic("x must be positive")'

# =============================================================================
# Elige (Switch/Match)
# =============================================================================

# elige with si cases becomes if/else-if chain in TS, match/case in Python
- name: 'elige with cases'
  input: |
      elige x {
        si 1 { a() }
        si 2 { b() }
      }
  ts:
      - 'if (x === 1)'
      - 'else if (x === 2)'
  py:
      - 'match x:'
      - 'case 1:'
      - 'case 2:'
  zig:
      - 'if ((x == 1))'
      - 'else if ((x == 2))'

# aliter in elige is the default case
- name: 'elige with default'
  input: |
      elige x {
        si 1 { a() }
        aliter { c() }
      }
  ts:
      - 'if (x === 1)'
      - 'else {'
  py:
      - 'match x:'
      - 'case 1:'
      - 'case _:'
  zig:
      - 'if ((x == 1))'
      - 'else {'

# =============================================================================
# Guard Statements
# =============================================================================

# custodi provides early-exit guard clauses
- name: 'guard with condition'
  input: |
      custodi {
        si x == nihil { redde }
      }
  ts:
      - 'if ((x == null))'
      - 'return;'
  py:
      - 'if (x == None):'
      - 'return'
  zig:
      - 'if ((x == null))'
      - 'return;'

# =============================================================================
# Praefixum (Compile-time Blocks)
# =============================================================================

# praefixum expression form evaluates at compile time
- name: 'praefixum expression form'
  input: 'fixum size = praefixum(256 * 4)'
  cpp:
      - '(256 * 4)'
  zig:
      - 'comptime ((256 * 4))'

# praefixum block form wraps in IIFE for compile-time evaluation
- name: 'praefixum block form'
  input: |
      fixum result = praefixum {
        varia x = 10
        redde x * 2
      }
  cpp:
      - '[&]'
      - 'auto x = 10'
      - 'return (x * 2)'
      - '}()'
  zig:
      - 'comptime blk:'
      - 'break :blk (x * 2)'
