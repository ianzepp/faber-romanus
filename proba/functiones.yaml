# Functiones - Function declaration and lambda codegen tests
# Covers: functio, futura, cursor, arrow functions, pro lambdas

# =============================================================================
# Simple Functions
# =============================================================================

# functio declares a function (function in TS, def in Python)
- name: 'simple function'
  input: |
      functio salve(nomen) {
        redde nomen
      }
  ts:
      - 'function salve(nomen)'
      - 'return nomen;'
  py:
      - 'def salve(nomen):'
      - 'return nomen'
  cpp:
      - 'void salve(auto nomen)'
      - 'return nomen'
  zig:
      - 'fn salve(nomen: anytype) void'
      - 'return nomen;'

# -> specifies return type annotation
- name: 'function with return type'
  input: 'functio greet() -> textus { redde "hello" }'
  ts:
      - 'function greet(): string'
  py:
      - 'def greet() -> str:'
  cpp:
      - 'std::string greet()'
      - 'return std::string("hello")'

# =============================================================================
# Async Functions
# =============================================================================

# futura makes a function async
- name: 'async function'
  input: |
      futura functio fetch(url) {
        redde data
      }
  ts:
      - 'async function fetch(url)'
  py:
      - 'async def fetch(url):'
  zig:
      - '!void'

# fiet is async + return type (wraps in Promise/Awaitable)
- name: 'async function with return type'
  input: 'functio fetch() fiet textus { redde "data" }'
  ts:
      - 'async function fetch(): Promise<string>'
  py:
      - 'async def fetch() -> Awaitable[str]:'

# =============================================================================
# Generator Functions
# =============================================================================

# fiunt makes a function a generator (wraps return in Generator/Iterator)
- name: 'generator function'
  input: 'functio range() fiunt numerus { redde 1 }'
  ts:
      - 'function* range(): Generator<number>'
  py:
      - 'def range() -> Iterator[int]:'

# fient is async generator (wraps in AsyncGenerator/AsyncIterator)
- name: 'async generator function'
  input: 'functio stream() fient textus { redde "chunk" }'
  ts:
      - 'async function* stream(): AsyncGenerator<string>'
  py:
      - 'async def stream() -> AsyncIterator[str]:'

# =============================================================================
# Yield/Await
# =============================================================================

# cede in generator context becomes yield
- name: 'cede in generator'
  input: 'functio range() fiunt numerus { cede 1 }'
  ts:
      - 'yield 1'
  py:
      - 'yield 1'

# cede in async context becomes await
- name: 'cede in async function'
  input: 'functio fetch() fiet textus { cede getData() }'
  ts:
      - 'await getData()'
  py:
      - 'await getData()'
  zig:
      - 'try getData()'

# =============================================================================
# Arrow Functions
# =============================================================================

# JavaScript-style arrow syntax
- name: 'simple arrow'
  input: '(x) => x'
  ts: '(x) => x;'
  py: 'lambda x: x'
  cpp:
      - '[&](auto x) { return x; }'

# Arrow with block body
- name: 'arrow with block'
  input: '(x) => { redde x }'
  ts:
      - '(x) =>'
      - 'return x;'
  py: 'lambda x: x'

# =============================================================================
# Lambda Expressions (pro)
# =============================================================================

# pro is the Latin lambda syntax - single param
- name: 'single param lambda'
  input: 'pro x redde x * 2'
  ts: '(x) => (x * 2);'
  py: 'lambda x: (x * 2)'

# Multiple parameters separated by comma
- name: 'multi param lambda'
  input: 'pro x, y redde x + y'
  ts: '(x, y) => (x + y);'
  py: 'lambda x, y: (x + y)'

# Zero parameters - empty param list
- name: 'zero param lambda'
  input: 'pro redde 42'
  ts: '() => 42;'
  py: 'lambda : 42'

# Lambda assigned to variable
- name: 'lambda in variable'
  input: 'fixum double = pro x redde x * 2'
  ts: 'const double = (x) => (x * 2);'
  py: 'double = lambda x: (x * 2)'

# Lambda passed as callback argument
- name: 'lambda as callback'
  input: 'items.filtrata(pro x redde x > 0)'
  ts: 'items.filter((x) => (x > 0));'
  py:
      - 'filter'
      - 'lambda x: (x > 0)'

# =============================================================================
# Empty Blocks
# =============================================================================

# Empty function body - TS allows {}, Python needs pass
- name: 'empty function body'
  input: 'functio noop() {}'
  ts: 'function noop() {}'
  py:
      - 'def noop():'
      - 'pass'
