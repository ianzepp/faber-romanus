# Lista - List/vector collection method codegen tests
# Covers: adde, addita, praepone, remove, decapita, purga, primus, ultimus,
#         accipe, longitudo, vacua, continet, indiceDe, filtrata, mappata,
#         inversa, prima, omitte, omnes, aliquis, ordina, inverte, summa,
#         minimus, maximus, perambula

# =============================================================================
# Adding Elements
# =============================================================================

# adde mutates the list by appending (push_back in C++)
- name: 'adde -> push_back'
  input: 'items.adde(1)'
  cpp:
      - '.push_back(1)'
  ts:
      - '.push('
  rs:
      - '.push(1)'
  zig:
      - '.adde(1)'
  fab:
      - 'items.adde(1)'

# addita returns a new list with the element appended (copy + push_back)
- name: 'addita -> copy and push_back'
  input: 'items.addita(1)'
  cpp:
      - 'auto v = items'
      - 'v.push_back(1)'
      - 'return v'
  ts:
      - '[...'
  rs:
      - 'let mut v = items.clone()'
      - 'v.push(1)'
  zig:
      - '.addita(1)'
  fab:
      - 'items.addita(1)'

# praepone inserts at the beginning
- name: 'praepone -> insert at begin'
  input: 'items.praepone(1)'
  cpp:
      - '.insert('
      - '.begin()'
  ts:
      - '.unshift('
  rs:
      - '.insert(0, 1)'
  zig:
      - '.praepone(1)'
  fab:
      - 'items.praepone(1)'

# =============================================================================
# Removing Elements
# =============================================================================

# remove pops and returns the last element
- name: 'remove -> pop_back with return'
  input: 'items.remove()'
  cpp:
      - '.back()'
      - '.pop_back()'
  ts:
      - '.pop('
  rs:
      - '.pop()'
  zig:
      - '.remove()'
  fab:
      - 'items.remove()'

# decapita removes and returns the first element
- name: 'decapita -> erase at begin'
  input: 'items.decapita()'
  cpp:
      - '.front()'
      - '.erase('
  ts:
      - '.shift('
  rs:
      - '.remove(0)'
  zig:
      - '.decapita()'
  fab:
      - 'items.decapita()'

# purga clears the entire list
- name: 'purga -> clear'
  input: 'items.purga()'
  cpp:
      - '.clear()'
  ts:
      - '.length = 0'
  rs:
      - '.clear()'
  zig:
      - '.purga()'
  fab:
      - 'items.purga()'

# =============================================================================
# Accessing Elements
# =============================================================================

# primus returns the first element
- name: 'primus -> front'
  input: 'items.primus()'
  cpp:
      - '.front()'
  ts:
      - '[0]'
  rs:
      - '.first()'
  zig:
      - '.primus()'
  fab:
      - 'items.primus()'

# ultimus returns the last element
- name: 'ultimus -> back'
  input: 'items.ultimus()'
  cpp:
      - '.back()'
  ts:
      - '.at('
  rs:
      - '.last()'
  zig:
      - '.ultimus()'
  fab:
      - 'items.ultimus()'

# accipe returns element at index (bounds-checked)
- name: 'accipe -> at'
  input: 'items.accipe(0)'
  cpp:
      - '.at(0)'
  ts:
      - '[0]'
  rs:
      - '.get(0)'
  zig:
      - '.accipe(0)'
  fab:
      - 'items.accipe(0)'

# longitudo returns the size
- name: 'longitudo -> size'
  input: 'items.longitudo()'
  cpp:
      - '.size()'
  ts:
      - '.length'
  rs:
      - '.len()'
  zig:
      - '.longitudo()'
  fab:
      - 'items.longitudo()'

# vacua returns whether the list is empty
- name: 'vacua -> empty'
  input: 'items.vacua()'
  cpp:
      - '.empty()'
  ts:
      - '.length === 0'
  rs:
      - '.is_empty()'
  zig:
      - '.vacua()'
  fab:
      - 'items.vacua()'

# =============================================================================
# Searching
# =============================================================================

# continet checks if element exists
- name: 'continet -> std::find'
  input: 'items.continet(5)'
  cpp:
      - 'std::find('
      - '!= items.end()'
  ts:
      - '.includes('
  rs:
      - '.contains(&5)'
  zig:
      - '.continet(5)'
  fab:
      - 'items.continet(5)'

# indiceDe returns the index of an element
- name: 'indiceDe -> std::find with distance'
  input: 'items.indiceDe(5)'
  cpp:
      - 'std::find('
      - 'std::distance('
  ts:
      - '.indexOf('
  rs:
      - '.iter().position(|e| e == &5)'
  zig:
      - '.indiceDe(5)'
  fab:
      - 'items.indiceDe(5)'

# =============================================================================
# Transformations (C++23 ranges)
# =============================================================================

# filtrata returns filtered copy using views::filter
- name: 'filtrata -> views::filter'
  input: 'items.filtrata(pro x: x > 0)'
  cpp:
      - 'std::views::filter'
      - 'std::ranges::to<std::vector>'
  ts:
      - '.filter('
  rs:
      - '.iter().filter('
      - '.cloned().collect'
  zig:
      - '.filtrata('
  fab:
      - 'items.filtrata(pro x: x > 0)'

# mappata transforms elements using views::transform
- name: 'mappata -> views::transform'
  input: 'items.mappata(pro x: x * 2)'
  cpp:
      - 'std::views::transform'
      - 'std::ranges::to<std::vector>'
  ts:
      - '.map('
  rs:
      - '.iter().map('
      - '.collect'
  zig:
      - '.mappata('
  fab:
      - 'items.mappata(pro x: x * 2)'

# inversa returns reversed copy
- name: 'inversa -> views::reverse'
  input: 'items.inversa()'
  cpp:
      - 'std::views::reverse'
      - 'std::ranges::to<std::vector>'
  ts:
      - '.reverse('
  rs:
      - '.iter().rev()'
      - '.cloned().collect'
  zig:
      - '.inversa()'
  fab:
      - 'items.inversa()'

# prima takes first n elements
- name: 'prima -> views::take'
  input: 'items.prima(5)'
  cpp:
      - 'std::views::take(5)'
      - 'std::ranges::to<std::vector>'
  ts:
      - '.slice('
  rs:
      - '.iter().take(5)'
      - '.cloned().collect'
  zig:
      - '.prima(5)'
  fab:
      - 'items.prima(5)'

# omitte drops first n elements
- name: 'omitte -> views::drop'
  input: 'items.omitte(2)'
  cpp:
      - 'std::views::drop(2)'
      - 'std::ranges::to<std::vector>'
  ts:
      - '.slice('
  rs:
      - '.iter().skip(2)'
      - '.cloned().collect'
  zig:
      - '.omitte(2)'
  fab:
      - 'items.omitte(2)'

# =============================================================================
# Predicates
# =============================================================================

# omnes checks if all elements match predicate
- name: 'omnes -> ranges::all_of'
  input: 'items.omnes(pro x: x > 0)'
  cpp:
      - 'std::ranges::all_of('
  ts:
      - '.every('
  rs:
      - '.iter().all('
  zig:
      - '.omnes('
  fab:
      - 'items.omnes(pro x: x > 0)'

# aliquis checks if any element matches predicate
- name: 'aliquis -> ranges::any_of'
  input: 'items.aliquis(pro x: x > 0)'
  cpp:
      - 'std::ranges::any_of('
  ts:
      - '.some('
  rs:
      - '.iter().any('
  zig:
      - '.aliquis('
  fab:
      - 'items.aliquis(pro x: x > 0)'

# =============================================================================
# Mutating Operations
# =============================================================================

# ordina sorts the list in-place
- name: 'ordina -> ranges::sort'
  input: 'items.ordina()'
  cpp:
      - 'std::ranges::sort(items)'
  ts:
      - '.sort('
  rs:
      - '.sort()'
  zig:
      - '.ordina()'
  fab:
      - 'items.ordina()'

# inverte reverses the list in-place
- name: 'inverte -> ranges::reverse'
  input: 'items.inverte()'
  cpp:
      - 'std::ranges::reverse(items)'
  ts:
      - '.reverse('
  rs:
      - '.reverse()'
  zig:
      - '.inverte()'
  fab:
      - 'items.inverte()'

# =============================================================================
# Numeric Aggregation
# =============================================================================

# summa returns the sum of all elements
- name: 'summa -> std::accumulate'
  input: 'nums.summa()'
  cpp:
      - 'std::accumulate('
  ts:
      - '.reduce('
  rs:
      - '.iter().sum'
  zig:
      - '.summa()'
  fab:
      - 'nums.summa()'

# minimus returns the minimum element
- name: 'minimus -> ranges::min_element'
  input: 'nums.minimus()'
  cpp:
      - 'std::ranges::min_element('
  ts:
      - 'Math.min(...'
  rs:
      - '.iter().min()'
  zig:
      - '.minimus()'
  fab:
      - 'nums.minimus()'

# maximus returns the maximum element
- name: 'maximus -> ranges::max_element'
  input: 'nums.maximus()'
  cpp:
      - 'std::ranges::max_element('
  ts:
      - 'Math.max(...'
  rs:
      - '.iter().max()'
  zig:
      - '.maximus()'
  fab:
      - 'nums.maximus()'

# =============================================================================
# Iteration
# =============================================================================

# perambula iterates over all elements
- name: 'perambula -> ranges::for_each'
  input: 'items.perambula(pro x { scribe x })'
  cpp:
      - 'std::ranges::for_each('
  ts:
      - '.forEach('
  rs:
      - '.iter().for_each('
  zig:
      - '.perambula('
  fab:
      - 'items.perambula(pro x { scribe x })'

# =============================================================================
# Header Includes
# =============================================================================

# Algorithm methods add algorithm header
- name: 'algorithm methods add algorithm header'
  input: 'items.continet(5)'
  cpp:
      - '#include <algorithm>'
  ts:
      - '.includes('
  rs:
      - '.contains(&5)'
  fab:
      - 'items.continet(5)'
  skip: [zig] # Zig uses @import("std"), no header system

# Ranges methods add ranges header
- name: 'ranges methods add ranges header'
  input: 'items.filtrata(pro x: x > 0)'
  cpp:
      - '#include <ranges>'
  ts:
      - '.filter('
  rs:
      - '.iter().filter('
  fab:
      - 'items.filtrata(pro x: x > 0)'
  skip: [zig] # Zig uses @import("std"), no header system

# Numeric methods add numeric header
- name: 'numeric methods add numeric header'
  input: 'nums.summa()'
  cpp:
      - '#include <numeric>'
  ts:
      - '.reduce('
  rs:
      - '.iter().sum'
  fab:
      - 'nums.summa()'
  skip: [zig] # Zig uses @import("std"), no header system

# =============================================================================
# Collection DSL
# =============================================================================

# DSL prima in iteration context
- name: 'DSL prima in iteration'
  input: 'ex items prima 5 pro x { scribe x }'
  ts:
      - 'for (const x of items.slice(0, 5))'
  fab:
      - 'ex items prima 5 pro x {'
      - 'scribe x'
  skip: [rs]

# DSL ultima in iteration context
- name: 'DSL ultima in iteration'
  input: 'ex items ultima 3 pro x { scribe x }'
  ts:
      - 'for (const x of items.slice(-3))'
  fab:
      - 'ex items ultima 3 pro x {'
      - 'scribe x'
  skip: [rs]

# DSL prima as expression
- name: 'DSL prima as expression'
  input: 'fixum top = ex items prima 5'
  ts:
      - 'const top = items.slice(0, 5)'
  fab:
      - 'fixum top = ex items prima 5'
  skip: [rs]

# DSL summa as expression
- name: 'DSL summa as expression'
  input: 'fixum total = ex nums summa'
  ts:
      - 'const total = nums.reduce((a, b) => a + b, 0)'
  fab:
      - 'fixum total = ex nums summa'
  skip: [rs]

# DSL chained transforms
- name: 'DSL chained transforms'
  input: 'fixum result = ex items prima 10, ultima 3'
  ts:
      - 'const result = items.slice(0, 10).slice(-3)'
  fab:
      - 'fixum result = ex items prima 10, ultima 3'
  skip: [rs]
