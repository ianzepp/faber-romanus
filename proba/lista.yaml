# Lista - List/vector collection method codegen tests
# Covers: adde, addita, praepone, remove, decapita, purga, primus, ultimus,
#         accipe, longitudo, vacua, continet, indiceDe, filtrata, mappata,
#         inversa, prima, omitte, omnes, aliquis, ordina, inverte, summa,
#         minimus, maximus, perambula

# =============================================================================
# Adding Elements
# =============================================================================

# adde mutates the list by appending (push_back in C++)
- name: 'adde -> push_back'
  input: 'items.adde(1)'
  cpp:
      - '.push_back(1)'
  ts:
      - '.push('
  fab:
      - 'items.adde(1)'
  skip: [rs]

# addita returns a new list with the element appended (copy + push_back)
- name: 'addita -> copy and push_back'
  input: 'items.addita(1)'
  cpp:
      - 'auto v = items'
      - 'v.push_back(1)'
      - 'return v'
  ts:
      - '[...'
  fab:
      - 'items.addita(1)'
  skip: [rs]

# praepone inserts at the beginning
- name: 'praepone -> insert at begin'
  input: 'items.praepone(1)'
  cpp:
      - '.insert('
      - '.begin()'
  ts:
      - '.unshift('
  fab:
      - 'items.praepone(1)'
  skip: [rs]

# =============================================================================
# Removing Elements
# =============================================================================

# remove pops and returns the last element
- name: 'remove -> pop_back with return'
  input: 'items.remove()'
  cpp:
      - '.back()'
      - '.pop_back()'
  ts:
      - '.pop('
  fab:
      - 'items.remove()'
  skip: [rs]

# decapita removes and returns the first element
- name: 'decapita -> erase at begin'
  input: 'items.decapita()'
  cpp:
      - '.front()'
      - '.erase('
  ts:
      - '.shift('
  fab:
      - 'items.decapita()'
  skip: [rs]

# purga clears the entire list
- name: 'purga -> clear'
  input: 'items.purga()'
  cpp:
      - '.clear()'
  ts:
      - '.length = 0'
  fab:
      - 'items.purga()'
  skip: [rs]

# =============================================================================
# Accessing Elements
# =============================================================================

# primus returns the first element
- name: 'primus -> front'
  input: 'items.primus()'
  cpp:
      - '.front()'
  ts:
      - '[0]'
  fab:
      - 'items.primus()'
  skip: [rs]

# ultimus returns the last element
- name: 'ultimus -> back'
  input: 'items.ultimus()'
  cpp:
      - '.back()'
  ts:
      - '.at('
  fab:
      - 'items.ultimus()'
  skip: [rs]

# accipe returns element at index (bounds-checked)
- name: 'accipe -> at'
  input: 'items.accipe(0)'
  cpp:
      - '.at(0)'
  ts:
      - '[0]'
  fab:
      - 'items.accipe(0)'
  skip: [rs]

# longitudo returns the size
- name: 'longitudo -> size'
  input: 'items.longitudo()'
  cpp:
      - '.size()'
  ts:
      - '.length'
  fab:
      - 'items.longitudo()'
  skip: [rs]

# vacua returns whether the list is empty
- name: 'vacua -> empty'
  input: 'items.vacua()'
  cpp:
      - '.empty()'
  ts:
      - '.length === 0'
  fab:
      - 'items.vacua()'
  skip: [rs]

# =============================================================================
# Searching
# =============================================================================

# continet checks if element exists
- name: 'continet -> std::find'
  input: 'items.continet(5)'
  cpp:
      - 'std::find('
      - '!= items.end()'
  ts:
      - '.includes('
  fab:
      - 'items.continet(5)'
  skip: [rs]

# indiceDe returns the index of an element
- name: 'indiceDe -> std::find with distance'
  input: 'items.indiceDe(5)'
  cpp:
      - 'std::find('
      - 'std::distance('
  ts:
      - '.indexOf('
  fab:
      - 'items.indiceDe(5)'
  skip: [rs]

# =============================================================================
# Transformations (C++23 ranges)
# =============================================================================

# filtrata returns filtered copy using views::filter
- name: 'filtrata -> views::filter'
  input: 'items.filtrata(pro x: x > 0)'
  cpp:
      - 'std::views::filter'
      - 'std::ranges::to<std::vector>'
  ts:
      - '.filter('
  fab:
      - 'items.filtrata(pro x: x > 0)'
  skip: [rs]

# mappata transforms elements using views::transform
- name: 'mappata -> views::transform'
  input: 'items.mappata(pro x: x * 2)'
  cpp:
      - 'std::views::transform'
      - 'std::ranges::to<std::vector>'
  ts:
      - '.map('
  fab:
      - 'items.mappata(pro x: x * 2)'
  skip: [rs]

# inversa returns reversed copy
- name: 'inversa -> views::reverse'
  input: 'items.inversa()'
  cpp:
      - 'std::views::reverse'
      - 'std::ranges::to<std::vector>'
  ts:
      - '.reverse('
  fab:
      - 'items.inversa()'
  skip: [rs]

# prima takes first n elements
- name: 'prima -> views::take'
  input: 'items.prima(5)'
  cpp:
      - 'std::views::take(5)'
      - 'std::ranges::to<std::vector>'
  ts:
      - '.slice('
  fab:
      - 'items.prima(5)'
  skip: [rs]

# omitte drops first n elements
- name: 'omitte -> views::drop'
  input: 'items.omitte(2)'
  cpp:
      - 'std::views::drop(2)'
      - 'std::ranges::to<std::vector>'
  ts:
      - '.slice('
  fab:
      - 'items.omitte(2)'
  skip: [rs]

# =============================================================================
# Predicates
# =============================================================================

# omnes checks if all elements match predicate
- name: 'omnes -> ranges::all_of'
  input: 'items.omnes(pro x: x > 0)'
  cpp:
      - 'std::ranges::all_of('
  ts:
      - '.every('
  fab:
      - 'items.omnes(pro x: x > 0)'
  skip: [rs]

# aliquis checks if any element matches predicate
- name: 'aliquis -> ranges::any_of'
  input: 'items.aliquis(pro x: x > 0)'
  cpp:
      - 'std::ranges::any_of('
  ts:
      - '.some('
  fab:
      - 'items.aliquis(pro x: x > 0)'
  skip: [rs]

# =============================================================================
# Mutating Operations
# =============================================================================

# ordina sorts the list in-place
- name: 'ordina -> ranges::sort'
  input: 'items.ordina()'
  cpp:
      - 'std::ranges::sort(items)'
  ts:
      - '.sort('
  fab:
      - 'items.ordina()'
  skip: [rs]

# inverte reverses the list in-place
- name: 'inverte -> ranges::reverse'
  input: 'items.inverte()'
  cpp:
      - 'std::ranges::reverse(items)'
  ts:
      - '.reverse('
  fab:
      - 'items.inverte()'
  skip: [rs]

# =============================================================================
# Numeric Aggregation
# =============================================================================

# summa returns the sum of all elements
- name: 'summa -> std::accumulate'
  input: 'nums.summa()'
  cpp:
      - 'std::accumulate('
  ts:
      - '.reduce('
  fab:
      - 'nums.summa()'
  skip: [rs]

# minimus returns the minimum element
- name: 'minimus -> ranges::min_element'
  input: 'nums.minimus()'
  cpp:
      - 'std::ranges::min_element('
  ts:
      - 'Math.min(...'
  fab:
      - 'nums.minimus()'
  skip: [rs]

# maximus returns the maximum element
- name: 'maximus -> ranges::max_element'
  input: 'nums.maximus()'
  cpp:
      - 'std::ranges::max_element('
  ts:
      - 'Math.max(...'
  fab:
      - 'nums.maximus()'
  skip: [rs]

# =============================================================================
# Iteration
# =============================================================================

# perambula iterates over all elements
- name: 'perambula -> ranges::for_each'
  input: 'items.perambula(pro x { scribe x })'
  cpp:
      - 'std::ranges::for_each('
  ts:
      - '.forEach('
  fab:
      - 'items.perambula(pro x { scribe x })'
  skip: [rs]

# =============================================================================
# Header Includes
# =============================================================================

# Algorithm methods add algorithm header
- name: 'algorithm methods add algorithm header'
  input: 'items.continet(5)'
  cpp:
      - '#include <algorithm>'
  ts:
      - '.includes('
  fab:
      - 'items.continet(5)'
  skip: [rs]

# Ranges methods add ranges header
- name: 'ranges methods add ranges header'
  input: 'items.filtrata(pro x: x > 0)'
  cpp:
      - '#include <ranges>'
  ts:
      - '.filter('
  fab:
      - 'items.filtrata(pro x: x > 0)'
  skip: [rs]

# Numeric methods add numeric header
- name: 'numeric methods add numeric header'
  input: 'nums.summa()'
  cpp:
      - '#include <numeric>'
  ts:
      - '.reduce('
  fab:
      - 'nums.summa()'
  skip: [rs]

# =============================================================================
# Collection DSL
# =============================================================================

# DSL prima in iteration context
- name: 'DSL prima in iteration'
  input: 'ex items prima 5 pro x { scribe x }'
  ts:
      - 'for (const x of items.slice(0, 5))'
  fab:
      - 'ex items prima 5 pro x {'
      - 'scribe x'
  skip: [rs]

# DSL ultima in iteration context
- name: 'DSL ultima in iteration'
  input: 'ex items ultima 3 pro x { scribe x }'
  ts:
      - 'for (const x of items.slice(-3))'
  fab:
      - 'ex items ultima 3 pro x {'
      - 'scribe x'
  skip: [rs]

# DSL prima as expression
- name: 'DSL prima as expression'
  input: 'fixum top = ex items prima 5'
  ts:
      - 'const top = items.slice(0, 5)'
  fab:
      - 'fixum top = ex items prima 5'
  skip: [rs]

# DSL summa as expression
- name: 'DSL summa as expression'
  input: 'fixum total = ex nums summa'
  ts:
      - 'const total = nums.reduce((a, b) => a + b, 0)'
  fab:
      - 'fixum total = ex nums summa'
  skip: [rs]

# DSL chained transforms
- name: 'DSL chained transforms'
  input: 'fixum result = ex items prima 10, ultima 3'
  ts:
      - 'const result = items.slice(0, 10).slice(-3)'
  fab:
      - 'fixum result = ex items prima 10, ultima 3'
  skip: [rs]
