# Copia - Set collection method codegen tests
# Covers: adde, habet, dele, longitudo, vacua, purga, unio, intersectio,
#         differentia, symmetrica, subcopia, supercopia, inLista, perambula

# =============================================================================
# Core Operations
# =============================================================================

# adde inserts an element into the set
- name: 'adde -> insert'
  input: |
      varia copia<numerus> set = {}
      set.adde(5)
  cpp:
      - '.insert(5)'
  rs:
      - 'HashSet<i64>'
      - '.adde(5)'
  ts:
      - '.add('
  fab:
      - 'varia copia<numerus> set = {}'
      - 'set.adde(5)'

# habet checks if element exists in set
- name: 'habet -> contains'
  input: |
      fixum copia<numerus> set = {}
      set.habet(5)
  cpp:
      - '.contains(5)'
  rs:
      - 'HashSet<i64>'
      - '.habet(5)'
  ts:
      - '.has('
  fab:
      - 'fixum copia<numerus> set = {}'
      - 'set.habet(5)'

# dele removes an element from the set
- name: 'dele -> erase'
  input: |
      varia copia<numerus> set = {}
      set.dele(5)
  cpp:
      - '.erase(5)'
  rs:
      - 'HashSet<i64>'
      - '.dele(5)'
  ts:
      - '.delete('
  fab:
      - 'varia copia<numerus> set = {}'
      - 'set.dele(5)'

# longitudo returns the number of elements
- name: 'longitudo -> size'
  input: |
      fixum copia<numerus> set = {}
      set.longitudo()
  cpp:
      - '.size()'
  rs:
      - 'HashSet<i64>'
      - '.longitudo()'
  ts:
      - '.size'
  fab:
      - 'fixum copia<numerus> set = {}'
      - 'set.longitudo()'

# vacua checks if the set is empty
- name: 'vacua -> empty'
  input: |
      fixum copia<numerus> set = {}
      set.vacua()
  cpp:
      - '.empty()'
  rs:
      - 'HashSet<i64>'
      - '.vacua()'
  ts:
      - '.size === 0'
  fab:
      - 'fixum copia<numerus> set = {}'
      - 'set.vacua()'

# purga clears the entire set
- name: 'purga -> clear'
  input: |
      varia copia<numerus> set = {}
      set.purga()
  cpp:
      - '.clear()'
  rs:
      - 'HashSet<i64>'
      - '.purga()'
  ts:
      - '.clear('
  fab:
      - 'varia copia<numerus> set = {}'
      - 'set.purga()'

# =============================================================================
# Set Operations
# =============================================================================

# unio returns the union of two sets
- name: 'unio -> set union'
  input: |
      fixum copia<numerus> setA = {}
      fixum copia<numerus> setB = {}
      setA.unio(setB)
  cpp:
      - 'std::unordered_set'
      - '.insert('
  rs:
      - 'HashSet<i64>'
      - '.unio(setB)'
  ts:
      - '[...'
  fab:
      - 'fixum copia<numerus> setA = {}'
      - 'fixum copia<numerus> setB = {}'
      - 'setA.unio(setB)'

# intersectio returns the intersection of two sets
- name: 'intersectio -> set intersection'
  input: |
      fixum copia<numerus> setA = {}
      fixum copia<numerus> setB = {}
      setA.intersectio(setB)
  cpp:
      - '.contains('
      - '.insert('
  rs:
      - 'HashSet<i64>'
      - '.intersectio(setB)'
  ts:
      - '.filter('
  fab:
      - 'fixum copia<numerus> setA = {}'
      - 'fixum copia<numerus> setB = {}'
      - 'setA.intersectio(setB)'

# differentia returns elements in A but not in B
- name: 'differentia -> set difference'
  input: |
      fixum copia<numerus> setA = {}
      fixum copia<numerus> setB = {}
      setA.differentia(setB)
  cpp:
      - '!'
      - '.contains('
  rs:
      - 'HashSet<i64>'
      - '.differentia(setB)'
  ts:
      - '.filter('
  fab:
      - 'fixum copia<numerus> setA = {}'
      - 'fixum copia<numerus> setB = {}'
      - 'setA.differentia(setB)'

# symmetrica returns elements in either set but not both
- name: 'symmetrica -> symmetric difference'
  input: |
      fixum copia<numerus> setA = {}
      fixum copia<numerus> setB = {}
      setA.symmetrica(setB)
  cpp:
      - '!'
      - '.contains('
  rs:
      - 'HashSet<i64>'
      - '.symmetrica(setB)'
  ts:
      - '.filter('
  fab:
      - 'fixum copia<numerus> setA = {}'
      - 'fixum copia<numerus> setB = {}'
      - 'setA.symmetrica(setB)'

# =============================================================================
# Predicates
# =============================================================================

# subcopia checks if A is a subset of B
- name: 'subcopia -> all_of with contains'
  input: |
      fixum copia<numerus> setA = {}
      fixum copia<numerus> setB = {}
      setA.subcopia(setB)
  cpp:
      - 'std::ranges::all_of'
      - '.contains('
  rs:
      - 'HashSet<i64>'
      - '.subcopia(setB)'
  ts:
      - '.every('
  fab:
      - 'fixum copia<numerus> setA = {}'
      - 'fixum copia<numerus> setB = {}'
      - 'setA.subcopia(setB)'

# supercopia checks if A is a superset of B
- name: 'supercopia -> all_of reversed'
  input: |
      fixum copia<numerus> setA = {}
      fixum copia<numerus> setB = {}
      setA.supercopia(setB)
  cpp:
      - 'std::ranges::all_of'
  rs:
      - 'HashSet<i64>'
      - '.supercopia(setB)'
  ts:
      - '.every('
  fab:
      - 'fixum copia<numerus> setA = {}'
      - 'fixum copia<numerus> setB = {}'
      - 'setA.supercopia(setB)'

# =============================================================================
# Conversions
# =============================================================================

# inLista converts the set to a vector
- name: 'inLista -> vector from set'
  input: |
      fixum copia<numerus> set = {}
      set.inLista()
  cpp:
      - 'std::vector('
  rs:
      - 'HashSet<i64>'
      - '.inLista()'
  ts:
      - '[...'
  fab:
      - 'fixum copia<numerus> set = {}'
      - 'set.inLista()'

# =============================================================================
# Iteration
# =============================================================================

# perambula iterates over all elements
- name: 'perambula -> ranges::for_each'
  input: |
      fixum copia<numerus> set = {}
      set.perambula(pro x { scribe x })
  cpp:
      - 'std::ranges::for_each('
  rs:
      - 'HashSet<i64>'
      - '.perambula(|x|'
  ts:
      - '.forEach('
  fab:
      - 'fixum copia<numerus> set = {}'
      - 'set.perambula(pro x { scribe x })'
