# Semantic Types - Type System Definitions
#
# This module defines the type system used during semantic analysis. Types are
# resolved from Latin type annotations and inferred from expressions.

# =============================================================================
# SEMANTIC TYPE (Discriminated Union)
# =============================================================================

# SemanticTypus is a discretio covering all possible types in the type system.
# Each variant carries specific metadata for its kind.

@ publicum
discretio SemanticTypus {
    # Primitive types (textus, numerus, fractus, decimus, magnus, bivalens, nihil, vacuum, octeti)
    Primitivum {
        textus nomen           # "textus" | "numerus" | "fractus" | etc.
        bivalens nullabilis    # T? types
        numerus? amplitudo     # Bit width for numerus<32>, etc.
    }

    # Generic types (lista<T>, tabula<K,V>, promissum<T>)
    Genericum {
        textus nomen                       # "lista" | "tabula" | etc.
        lista<SemanticTypus> parametri     # Type parameters
        bivalens nullabilis
    }

    # Function types
    Functio {
        lista<SemanticTypus> parametriTypi     # Parameter types
        SemanticTypus reditusTypus             # Return type
        bivalens asyncronum                    # async function?
        bivalens habetCuratorem                # Has curator param?
    }

    # Union types (A | B | C)
    Unio {
        lista<SemanticTypus> typi
    }

    # Unknown type for unresolved/error cases
    Ignotum {
        textus? ratio      # Optional reason for being unknown
    }

    # User-defined type (class, interface, etc.)
    Usitatum {
        textus nomen
        bivalens nullabilis
    }

    # Enum type (ordo) with named members
    Ordo {
        textus nomen
        tabula<textus, SemanticTypus> membra
        bivalens nullabilis
    }

    # Genus (class/struct) with fields and methods
    Genus {
        textus nomen
        tabula<textus, SemanticTypus> agri              # Fields
        tabula<textus, SemanticTypus> methodi           # Methods (FunctionType)
        tabula<textus, SemanticTypus> agriStatici       # Static fields
        tabula<textus, SemanticTypus> methodiStatici    # Static methods
        bivalens nullabilis
    }

    # Pactum (interface/protocol) with method signatures
    Pactum {
        textus nomen
        tabula<textus, SemanticTypus> methodi           # Methods (FunctionType)
        bivalens nullabilis
    }
}

# =============================================================================
# TYPE CONSTRUCTORS
# =============================================================================

# Create a primitive type
@ publica
@ publica
functio primitivumTypus(textus nomen, bivalens nullabilis) -> SemanticTypus {
    redde finge Primitivum {
        nomen: nomen,
        nullabilis: nullabilis,
        amplitudo: nihil
    } qua SemanticTypus
}

# Create a primitive type with size
@ publica
@ publica
functio primitivumTypusCumAmplitudine(textus nomen, numerus amplitudo, bivalens nullabilis) -> SemanticTypus {
    redde finge Primitivum {
        nomen: nomen,
        nullabilis: nullabilis,
        amplitudo: amplitudo
    } qua SemanticTypus
}

# Create a generic type
@ publica
@ publica
functio genericumTypus(textus nomen, lista<SemanticTypus> parametri, bivalens nullabilis) -> SemanticTypus {
    redde finge Genericum {
        nomen: nomen,
        parametri: parametri,
        nullabilis: nullabilis
    } qua SemanticTypus
}

# Create a function type
@ publica
@ publica
functio functioTypus(
    lista<SemanticTypus> parametriTypi,
    SemanticTypus reditusTypus,
    bivalens asyncronum,
    bivalens habetCuratorem
) -> SemanticTypus {
    redde finge Functio {
        parametriTypi: parametriTypi,
        reditusTypus: reditusTypus,
        asyncronum: asyncronum,
        habetCuratorem: habetCuratorem
    } qua SemanticTypus
}

# Create a union type
@ publica
@ publica
functio unioTypus(lista<SemanticTypus> typi) -> SemanticTypus {
    redde finge Unio { typi: typi } qua SemanticTypus
}

# Create an unknown type
@ publica
@ publica
functio ignotumTypus(si textus ratio) -> SemanticTypus {
    redde finge Ignotum { ratio: ratio } qua SemanticTypus
}

# Create a user-defined type
@ publica
@ publica
functio usitatumTypus(textus nomen, bivalens nullabilis) -> SemanticTypus {
    redde finge Usitatum {
        nomen: nomen,
        nullabilis: nullabilis
    } qua SemanticTypus
}

# Create an enum type
@ publica
@ publica
functio ordoTypus(textus nomen, tabula<textus, SemanticTypus> membra, bivalens nullabilis) -> SemanticTypus {
    redde finge Ordo {
        nomen: nomen,
        membra: membra,
        nullabilis: nullabilis
    } qua SemanticTypus
}

# Create a genus type
@ publica
@ publica
functio genusTypus(
    textus nomen,
    tabula<textus, SemanticTypus> agri,
    tabula<textus, SemanticTypus> methodi,
    tabula<textus, SemanticTypus> agriStatici,
    tabula<textus, SemanticTypus> methodiStatici,
    bivalens nullabilis
) -> SemanticTypus {
    redde finge Genus {
        nomen: nomen,
        agri: agri,
        methodi: methodi,
        agriStatici: agriStatici,
        methodiStatici: methodiStatici,
        nullabilis: nullabilis
    } qua SemanticTypus
}

# Create a pactum type
@ publica
@ publica
functio pactumTypus(textus nomen, tabula<textus, SemanticTypus> methodi, bivalens nullabilis) -> SemanticTypus {
    redde finge Pactum {
        nomen: nomen,
        methodi: methodi,
        nullabilis: nullabilis
    } qua SemanticTypus
}

# =============================================================================
# COMMON TYPE CONSTANTS
# =============================================================================

@ publicum
fixum TEXTUS = primitivumTypus("textus", falsum)

@ publicum
fixum NUMERUS = primitivumTypus("numerus", falsum)

@ publicum
fixum FRACTUS = primitivumTypus("fractus", falsum)

@ publicum
fixum DECIMUS = primitivumTypus("decimus", falsum)

@ publicum
fixum MAGNUS = primitivumTypus("magnus", falsum)

@ publicum
fixum BIVALENS = primitivumTypus("bivalens", falsum)

@ publicum
fixum NIHIL = primitivumTypus("nihil", falsum)

@ publicum
fixum VACUUM = primitivumTypus("vacuum", falsum)

@ publicum
fixum OCTETI = primitivumTypus("octeti", falsum)

@ publicum
fixum IGNOTUM = ignotumTypus(nihil)

# =============================================================================
# TYPE UTILITIES
# =============================================================================

# Check if two types are equal
@ publica
@ publica
functio typiAequales(SemanticTypus a, SemanticTypus b) -> bivalens {
    # Compare by variant tag and key fields
    discerne a {
        casu Primitivum ut pa {
            discerne b {
                casu Primitivum ut pb {
                    redde pa.nomen == pb.nomen
                }
            }
            redde falsum
        }

        casu Genericum ut ga {
            discerne b {
                casu Genericum ut gb {
                    si ga.nomen != gb.nomen {
                        redde falsum
                    }
                    si ga.parametri.longitudo() != gb.parametri.longitudo() {
                        redde falsum
                    }
                    # Check each type parameter
                    varia i = 0
                    ex ga.parametri pro t {
                        si non typiAequales(t, gb.parametri[i]) {
                            redde falsum
                        }
                        i += 1
                    }
                    redde verum
                }
            }
            redde falsum
        }

        casu Functio ut fa {
            discerne b {
                casu Functio ut fb {
                    si fa.asyncronum != fb.asyncronum {
                        redde falsum
                    }
                    si fa.parametriTypi.longitudo() != fb.parametriTypi.longitudo() {
                        redde falsum
                    }
                    si non typiAequales(fa.reditusTypus, fb.reditusTypus) {
                        redde falsum
                    }
                    # Check each parameter type
                    varia i = 0
                    ex fa.parametriTypi pro t {
                        si non typiAequales(t, fb.parametriTypi[i]) {
                            redde falsum
                        }
                        i += 1
                    }
                    redde verum
                }
            }
            redde falsum
        }

        casu Unio ut ua {
            discerne b {
                casu Unio ut ub {
                    si ua.typi.longitudo() != ub.typi.longitudo() {
                        redde falsum
                    }
                    varia i = 0
                    ex ua.typi pro t {
                        si non typiAequales(t, ub.typi[i]) {
                            redde falsum
                        }
                        i += 1
                    }
                    redde verum
                }
            }
            redde falsum
        }

        casu Ignotum {
            discerne b {
                casu Ignotum {
                    redde verum
                }
            }
            redde falsum
        }

        casu Usitatum ut usa {
            discerne b {
                casu Usitatum ut usb {
                    redde usa.nomen == usb.nomen
                }
            }
            redde falsum
        }

        casu Ordo ut oa {
            discerne b {
                casu Ordo ut ob {
                    redde oa.nomen == ob.nomen
                }
            }
            redde falsum
        }

        casu Genus ut gea {
            discerne b {
                casu Genus ut geb {
                    redde gea.nomen == geb.nomen
                }
            }
            redde falsum
        }

        casu Pactum ut paa {
            discerne b {
                casu Pactum ut pab {
                    redde paa.nomen == pab.nomen
                }
            }
            redde falsum
        }
    }

    redde falsum
}

# Check if a type is assignable to another type
@ publica
@ publica
functio assignabileAd(SemanticTypus fons, SemanticTypus scopus) -> bivalens {
    # Unknown is assignable to anything
    discerne fons {
        casu Ignotum {
            redde verum
        }
    }

    discerne scopus {
        casu Ignotum {
            redde verum
        }
    }

    # nihil is assignable to nullable types
    discerne fons {
        casu Primitivum ut p {
            si p.nomen == "nihil" {
                discerne scopus {
                    casu Primitivum ut sp {
                        redde sp.nullabilis
                    }
                    casu Genericum ut sg {
                        redde sg.nullabilis
                    }
                    casu Usitatum ut su {
                        redde su.nullabilis
                    }
                    casu Ordo ut so {
                        redde so.nullabilis
                    }
                    casu Genus ut sge {
                        redde sge.nullabilis
                    }
                    casu Pactum ut spa {
                        redde spa.nullabilis
                    }
                }
                redde falsum
            }
        }
    }

    # Numeric type promotion: numerus -> fractus, numerus -> decimus
    discerne fons {
        casu Primitivum ut pf {
            discerne scopus {
                casu Primitivum ut ps {
                    si estNumericum(pf.nomen) et estNumericum(ps.nomen) {
                        redde verum
                    }
                }
            }
        }
    }

    # Check if source is in target union
    discerne scopus {
        casu Unio ut u {
            ex u.typi pro t {
                si assignabileAd(fons, t) {
                    redde verum
                }
            }
            redde falsum
        }
    }

    # Source union must have all types assignable to target
    discerne fons {
        casu Unio ut u {
            ex u.typi pro t {
                si non assignabileAd(t, scopus) {
                    redde falsum
                }
            }
            redde verum
        }
    }

    # Otherwise check equality
    redde typiAequales(fons, scopus)
}

# Helper: check if type name is numeric
@ publica
functio estNumericum(textus nomen) -> bivalens {
    redde nomen inter ["numerus", "fractus", "decimus"]
}

# Format a type for error messages
@ publica
@ publica
functio formaTypum(SemanticTypus t) -> textus {
    discerne t {
        casu Primitivum ut p {
            varia resultatum = p.nomen
            si p.amplitudo != nihil {
                resultatum = scriptum("{}<{}>", resultatum, p.amplitudo)
            }
            si p.nullabilis {
                resultatum = scriptum("{}?", resultatum)
            }
            redde resultatum
        }

        casu Genericum ut g {
            # Build parameter list
            varia params = [] qua lista<textus>
            ex g.parametri pro typ {
                params.adde(formaTypum(typ))
            }
            varia resultatum = scriptum("{}<{}>", g.nomen, params.coniunge(", "))
            si g.nullabilis {
                resultatum = scriptum("{}?", resultatum)
            }
            redde resultatum
        }

        casu Functio ut f {
            # Build parameter list
            varia params = [] qua lista<textus>
            ex f.parametriTypi pro typ {
                params.adde(formaTypum(typ))
            }
            fixum asyncPraefix = f.asyncronum sic "futura " secus ""
            redde scriptum("{}({}) -> {}", asyncPraefix, params.coniunge(", "), formaTypum(f.reditusTypus))
        }

        casu Unio ut u {
            varia parts = [] qua lista<textus>
            ex u.typi pro typ {
                parts.adde(formaTypum(typ))
            }
            redde parts.coniunge(" | ")
        }

        casu Ignotum ut ig {
            si ig.ratio != nihil {
                redde scriptum("ignotum({})", ig.ratio)
            }
            redde "ignotum"
        }

        casu Usitatum ut u {
            si u.nullabilis {
                redde scriptum("{}?", u.nomen)
            }
            redde u.nomen
        }

        casu Ordo ut o {
            si o.nullabilis {
                redde scriptum("ordo {}?", o.nomen)
            }
            redde scriptum("ordo {}", o.nomen)
        }

        casu Genus ut g {
            si g.nullabilis {
                redde scriptum("genus {}?", g.nomen)
            }
            redde scriptum("genus {}", g.nomen)
        }

        casu Pactum ut p {
            si p.nullabilis {
                redde scriptum("pactum {}?", p.nomen)
            }
            redde scriptum("pactum {}", p.nomen)
        }
    }

    redde "ignotum"
}
