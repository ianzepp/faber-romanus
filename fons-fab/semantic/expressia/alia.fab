# Other Expression Resolution
#
# Handles: lambda, finge, cede (await), novum (new), conditional

ex "../resolvitor" importa Resolvitor
ex "../typi" importa SemanticTypus, IGNOTUM, VACUUM
ex "../typi" importa functioTypus, usitatumTypus, genericumTypus
ex "../scopus" importa ScopusSpecies, SymbolumSpecies
ex "../errores" importa cedeOutsideAsyncError
ex "../../ast/expressia" importa Expressia

# =============================================================================
# LAMBDA EXPRESSION RESOLUTION
# =============================================================================

# Resolve a lambda expression (pro x: x + 1)
@ publica
functio resolveLambda(Resolvitor r, Expressia lambdaExpr) -> SemanticTypus {
    fixum a = r.analyzator()

    discerne lambdaExpr {
        casu LambdaExpressia ut l {
            # Enter function scope for parameters
            a.intraScopum(ScopusSpecies.Functio)

            # Define parameters in scope
            ex l.parametra pro param {
                fixum paramTypus = IGNOTUM  # TODO: resolve param type annotation
                a.scopus.symbola[param.nomen] = {
                    nomen: param.nomen,
                    semanticTypus: paramTypus,
                    species: SymbolumSpecies.Parametrum,
                    mutabilis: falsum,
                    locus: param.locus
                }
            }

            # Resolve body expression
            fixum reditusTypus = r.expressia(l.corpus)

            # Exit function scope
            a.exiScopum()

            # Build function type
            varia paramTypi = [] qua lista<SemanticTypus>
            ex l.parametra pro param {
                paramTypi.adde(IGNOTUM)
            }

            redde functioTypus(paramTypi, reditusTypus, falsum, falsum)
        }
    }

    redde IGNOTUM
}

# =============================================================================
# FINGE EXPRESSION RESOLUTION
# =============================================================================

# Resolve a finge expression (tagged union construction)
@ publica
functio resolveFingeExpr(Resolvitor r, Expressia fingeExpr) -> SemanticTypus {
    discerne fingeExpr {
        casu FingeExpressia ut f {
            # Resolve all field values
            ex f.campi pro campo {
                r.expressia(campo.valor)
            }

            # The type comes from the qua clause (scopus)
            si nonnihil f.scopus {
                redde usitatumTypus(f.scopus.nomen, falsum)
            }

            # Otherwise use the variant name as the type
            redde usitatumTypus(f.variansNomen, falsum)
        }
    }

    redde IGNOTUM
}

# =============================================================================
# CEDE (AWAIT) EXPRESSION RESOLUTION
# =============================================================================

# Resolve a cede (await) expression
@ publica
functio resolveCedeExpr(Resolvitor r, Expressia cedeExpr) -> SemanticTypus {
    fixum a = r.analyzator()

    discerne cedeExpr {
        casu CedeExpressia ut c {
            fixum promissumTypus = r.expressia(c.argumentum)

            # Check we're in an async context
            si non a.currentFunctioAsync et non a.currentFunctioGenerator {
                fixum err = cedeOutsideAsyncError()
                a.error(err.textus, c.locus)
            }

            # Unwrap promissum<T> to T
            discerne promissumTypus {
                casu Genericum ut g {
                    si g.nomen == "promissum" et g.parametri.longitudo() > 0 {
                        redde g.parametri.primus()
                    }
                }
            }

            redde promissumTypus
        }
    }

    redde IGNOTUM
}

# =============================================================================
# NOVUM (NEW) EXPRESSION RESOLUTION
# =============================================================================

# Resolve a novum (new) expression
@ publica
functio resolveNovumExpr(Resolvitor r, Expressia novumExpr) -> SemanticTypus {
    discerne novumExpr {
        casu NovumExpressia ut n {
            # Resolve constructor arguments
            ex n.argumenta pro arg {
                r.expressia(arg)
            }

            # The type is the class being instantiated
            discerne n.vocatum {
                casu Nomen ut nom {
                    redde usitatumTypus(nom.valor, falsum)
                }
            }

            redde IGNOTUM
        }
    }

    redde IGNOTUM
}

# =============================================================================
# CONDITIONAL EXPRESSION RESOLUTION
# =============================================================================

# Resolve a ternary conditional expression
@ publica
functio resolveCondicio(Resolvitor r, Expressia condicioExpr) -> SemanticTypus {
    discerne condicioExpr {
        casu CondicioExpressia ut c {
            r.expressia(c.condicio)
            fixum consequensTypus = r.expressia(c.consequens)
            r.expressia(c.alternans)

            # Return the consequent type (simplification)
            redde consequensTypus
        }
    }

    redde IGNOTUM
}
