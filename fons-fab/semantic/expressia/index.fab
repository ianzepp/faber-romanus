# Expression Resolution - Main Dispatcher
#
# Routes expression AST nodes to their appropriate resolution functions.
# Each resolver returns the inferred SemanticTypus.
#
# Uses the Resolvitor pactum to break circular imports.

ex "../resolvitor" importa Resolvitor
ex "../typi" importa SemanticTypus, TEXTUS, NUMERUS, BIVALENS, NIHIL, IGNOTUM
ex "../typi" importa usitatumTypus, genericumTypus
ex "../../ast/expressia" importa Expressia

# Import resolvers - no circular dependency since they only use Resolvitor
ex "./primaria" importa resolveNomen, resolveLittera, resolveSeries, resolveObiectum
ex "./binaria" importa resolveBinaria
ex "./unaria" importa resolveUnaria
ex "./vocatio" importa resolveVocatio, resolveMembrum
ex "./alia" importa resolveLambda, resolveFingeExpr, resolveCedeExpr, resolveNovumExpr, resolveCondicio

# =============================================================================
# MAIN DISPATCHER
# =============================================================================

# Resolve any expression and return its semantic type
@ publica
functio resolveExpressia(Resolvitor r, Expressia expr) -> SemanticTypus {
    discerne expr {
        # Identifiers (variable references)
        casu Nomen {
            redde resolveNomen(r, expr)
        }

        # Literals (numbers, strings, booleans)
        casu Littera {
            redde resolveLittera(r, expr)
        }

        # Template literals (interpolated strings)
        casu LitteraExemplar {
            redde TEXTUS
        }

        # Binary expressions (+, -, *, /, ==, etc.)
        casu BinariaExpressia {
            redde resolveBinaria(r, expr)
        }

        # Unary expressions (!, -, non, etc.)
        casu UnariaExpressia {
            redde resolveUnaria(r, expr)
        }

        # Function calls
        casu VocatioExpressia {
            redde resolveVocatio(r, expr)
        }

        # Member access (obj.prop)
        casu MembrumExpressia {
            redde resolveMembrum(r, expr)
        }

        # Assignment (x = value)
        casu AssignatioExpressia ut as {
            redde resolveAssignatio(r, as)
        }

        # Await expression (cede)
        casu CedeExpressia {
            redde resolveCedeExpr(r, expr)
        }

        # New expression (novum)
        casu NovumExpressia {
            redde resolveNovumExpr(r, expr)
        }

        # Tagged union construction (finge)
        casu FingeExpressia {
            redde resolveFingeExpr(r, expr)
        }

        # Ternary conditional
        casu CondicioExpressia {
            redde resolveCondicio(r, expr)
        }

        # Range expression (1..10)
        casu AmbitusExpressia {
            redde genericumTypus("lista", [NUMERUS], falsum)
        }

        # Object literal { key: value }
        casu ObiectumExpressia {
            redde resolveObiectum(r, expr)
        }

        # Array literal [1, 2, 3]
        casu SeriesExpressia {
            redde resolveSeries(r, expr)
        }

        # Lambda expression (pro x: x + 1)
        casu LambdaExpressia {
            redde resolveLambda(r, expr)
        }

        # Self reference (ego/hoc)
        casu EgoExpressia {
            # ego type depends on enclosing class context
            redde IGNOTUM
        }

        # Type cast (expr qua Type)
        casu QuaExpressia ut q {
            r.expressia(q.expressia)
            # TODO: resolve type annotation
            redde IGNOTUM
        }

        # Type check (expr est Type)
        casu EstExpressia {
            redde BIVALENS
        }

        # Format string (scriptum)
        casu ScriptumExpressia ut s {
            ex s.argumenta pro arg {
                r.expressia(arg)
            }
            redde TEXTUS
        }

        # Read stdin (lege)
        casu LegeExpressia {
            redde TEXTUS
        }

        # Regex literal
        casu LitteraRegex {
            redde usitatumTypus("Regex", falsum)
        }
    }

    redde IGNOTUM
}

# =============================================================================
# HELPER RESOLVERS (inline for simple cases)
# =============================================================================

# Resolve assignment expression
@ publica
functio resolveAssignatio(Resolvitor r, Expressia assignatioExpr) -> SemanticTypus {
    # TODO: Check mutability, resolve target and value
    redde IGNOTUM
}
