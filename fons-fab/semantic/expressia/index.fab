# Expression Resolution - Main Dispatcher
#
# Routes expression AST nodes to their appropriate resolution functions.
# Each resolver returns the inferred SemanticTypus.
#
# Uses the Resolvitor pactum to break circular imports.

ex "../resolvitor" importa Resolvitor
ex "../typi" importa SemanticTypus, TEXTUS, NUMERUS, BIVALENS, NIHIL, IGNOTUM
ex "../typi" importa usitatumTypus, genericumTypus
ex "../../ast/expressia" importa Expressia

# Import resolvers - no circular dependency since they only use Resolvitor
ex "./primaria" importa resolveNomen, resolveLittera, resolveSeries, resolveObiectum
ex "./binaria" importa resolveBinaria
ex "./unaria" importa resolveUnaria
ex "./vocatio" importa resolveVocatio, resolveMembrum
ex "./alia" importa resolveLambda, resolveFingeExpr, resolveCedeExpr, resolveNovumExpr, resolveCondicio

# =============================================================================
# MAIN DISPATCHER
# =============================================================================

# Resolve any expression and return its semantic type
@ publica
@ publica
functio resolveExpressia(Resolvitor r, Expressia expr) -> SemanticTypus {
    discerne expr {
        # Identifiers (variable references)
        casu Nomen {
            redde resolveNomen(r, expr)
        }

        # Literals (numbers, strings, booleans)
        casu Littera {
            redde resolveLittera(r, expr)
        }

        # Template literals (interpolated strings)
        casu TemplateLittera {
            redde TEXTUS
        }

        # Binary expressions (+, -, *, /, ==, etc.)
        casu Binaria {
            redde resolveBinaria(r, expr)
        }

        # Unary expressions (!, -, non, etc.)
        casu Unaria {
            redde resolveUnaria(r, expr)
        }

        # Function calls
        casu Vocatio {
            redde resolveVocatio(r, expr)
        }

        # Member access (obj.prop)
        casu Membrum {
            redde resolveMembrum(r, expr)
        }

        # Assignment (x = value)
        casu Assignatio ut as {
            redde resolveAssignatio(r, as)
        }

        # Await expression (cede)
        casu Cede {
            redde resolveCedeExpr(r, expr)
        }

        # New expression (novum)
        casu Novum {
            redde resolveNovumExpr(r, expr)
        }

        # Tagged union construction (finge)
        casu Finge {
            redde resolveFingeExpr(r, expr)
        }

        # Ternary conditional
        casu Condicio {
            redde resolveCondicio(r, expr)
        }

        # Range expression (1..10)
        casu Tractus {
            redde genericumTypus("lista", [NUMERUS], falsum)
        }

        # Object literal { key: value }
        casu Obiectum {
            redde resolveObiectum(r, expr)
        }

        # Array literal [1, 2, 3]
        casu Series {
            redde resolveSeries(r, expr)
        }

        # Lambda expression (pro x: x + 1)
        casu Lambda {
            redde resolveLambda(r, expr)
        }

        # Self reference (ego/hoc)
        casu Ego {
            # ego type depends on enclosing class context
            redde IGNOTUM
        }

        # Type cast (expr qua Type)
        casu Qua ut q {
            r.expressia(q.expressia)
            # TODO: resolve type annotation
            redde IGNOTUM
        }

        # Type check (expr est Type)
        casu Est {
            redde BIVALENS
        }

        # Format string (scriptum)
        casu Scriptum ut s {
            ex s.argumenta pro arg {
                r.expressia(arg)
            }
            redde TEXTUS
        }

        # Read stdin (lege)
        casu Lege {
            redde TEXTUS
        }

        # Regex literal
        casu Regex {
            redde usitatumTypus("Regex", falsum)
        }
    }

    redde IGNOTUM
}

# =============================================================================
# HELPER RESOLVERS (inline for simple cases)
# =============================================================================

# Resolve assignment expression
@ publica
functio resolveAssignatio(Resolvitor r, Expressia assignatioExpr) -> SemanticTypus {
    # TODO: Check mutability, resolve target and value
    redde IGNOTUM
}
