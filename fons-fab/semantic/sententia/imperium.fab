# Control Flow Statement Analysis
#
# Handles: si, dum, ex/de...pro, elige, discerne, custodi

ex "../resolvitor" importa Resolvitor
ex "../typi" importa SemanticTypus, IGNOTUM
ex "../scopus" importa ScopusSpecies, SymbolumSpecies
ex "../../ast/sententia" importa Sententia

# =============================================================================
# CONDITIONAL
# =============================================================================

# Analyze si (if) statement
@ publica
functio analyzeSi(Resolvitor r, Sententia siStmt) -> vacuum {
    discerne siStmt {
        casu SiSententia ut s {
            # Analyze condition
            r.expressia(s.condicio)

            # Analyze consequent
            r.sententia(s.consequens)

            # Analyze alternate (sin/secus) if present
            si nonnihil s.alternans {
                r.sententia(s.alternans qua Sententia)
            }
        }
    }
}

# =============================================================================
# LOOPS
# =============================================================================

# Analyze dum (while) statement
@ publica
functio analyzeDum(Resolvitor r, Sententia dumStmt) -> vacuum {
    discerne dumStmt {
        casu DumSententia ut d {
            # Analyze condition
            r.expressia(d.condicio)

            # Analyze body
            r.sententia(d.corpus)
        }
    }
}

# Analyze iteratio (ex/de...pro) statement
@ publica
functio analyzeIteratio(Resolvitor r, Sententia iteratioStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne iteratioStmt {
        casu IteratioSententia ut i {
            # Analyze source expression
            fixum sourceTypus = r.expressia(i.iterabile)

            # Enter block scope for loop variable
            a.intraScopum(ScopusSpecies.Massa)

            # Infer loop variable type from source
            varia elemTypus = IGNOTUM qua SemanticTypus
            discerne sourceTypus {
                casu Genericum ut g {
                    si g.nomen == "lista" et g.parametri.longitudo() > 0 {
                        elemTypus = g.parametri.primus()
                    }
                }
            }

            # Define loop variable
            a.scopus.symbola[i.variabilis] = {
                nomen: i.variabilis,
                semanticTypus: elemTypus,
                species: SymbolumSpecies.Variabilis,
                mutabilis: falsum,
                locus: i.locus
            }

            # Analyze body
            r.sententia(i.corpus)

            # Exit scope
            a.exiScopum()
        }
    }
}

# Analyze in (context block) statement
@ publica
functio analyzeIn(Resolvitor r, Sententia inStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne inStmt {
        casu InSententia ut i {
            # Analyze source expression
            r.expressia(i.obiectum)

            # Enter scope for body
            a.intraScopum(ScopusSpecies.Massa)

            # Analyze body
            r.sententia(i.corpus)

            # Exit scope
            a.exiScopum()
        }
    }
}

# =============================================================================
# PATTERN MATCHING
# =============================================================================

# Analyze elige (switch) statement
@ publica
functio analyzeElige(Resolvitor r, Sententia eligeStmt) -> vacuum {
    discerne eligeStmt {
        casu EligeSententia ut e {
            # Analyze discriminant
            r.expressia(e.discriminans)

            # Analyze each case
            ex e.casus pro casus {
                # Analyze case test
                r.expressia(casus.condicio)

                # Analyze case body
                r.sententia(casus.consequens)
            }

            # Analyze default (aliter) if present
            si nonnihil e.praedefinitum {
                r.sententia(e.praedefinitum qua Sententia)
            }
        }
    }
}

# Analyze discerne (pattern match) statement
@ publica
functio analyzeDiscerne(Resolvitor r, Sententia discerneStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne discerneStmt {
        casu DiscerneSententia ut d {
            # Analyze discriminant
            fixum discTypus = r.expressia(d.discriminans)

            # Analyze each variant case
            ex d.casus pro casus {
                # Enter scope for pattern bindings
                a.intraScopum(ScopusSpecies.Massa)

                # Define bound variable if present
                ex casus.vincula pro vinculum {
                    a.scopus.symbola[vinculum] = {
                        nomen: vinculum,
                        semanticTypus: IGNOTUM,  # TODO: infer from variant
                        species: SymbolumSpecies.Variabilis,
                        mutabilis: falsum,
                        locus: casus.locus
                    }
                }

                # Analyze case body
                r.sententia(casus.consequens)

                a.exiScopum()
            }
        }
    }
}

# Analyze custodi (guard) statement
@ publica
functio analyzeCustodi(Resolvitor r, Sententia custodiStmt) -> vacuum {
    discerne custodiStmt {
        casu CustodiSententia ut c {
            # Analyze each guard clause
            ex c.clausulae pro clausula {
                # Analyze condition
                r.expressia(clausula.condicio)

                # Analyze body
                r.sententia(clausula.consequens)
            }
        }
    }
}
