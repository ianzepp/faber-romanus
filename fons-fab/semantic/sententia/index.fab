# Statement Analysis - Main Dispatcher
#
# Routes statement AST nodes to their appropriate analysis functions.

ex "../resolvitor" importa Resolvitor
ex "../../ast/sententia" importa Sententia

# Import analyzers - no circular dependency since they only use Resolvitor
ex "./declara" importa analyzeVariaDeclaratio, analyzeFunctioDeclaratio
ex "./declara" importa analyzeGenusDeclaratio, analyzePactumDeclaratio
ex "./declara" importa analyzeOrdoDeclaratio, analyzeDiscretioDeclaratio, analyzeTypusAlias
ex "./imperium" importa analyzeSi, analyzeDum, analyzeIteratio, analyzeIn
ex "./imperium" importa analyzeElige, analyzeDiscerne, analyzeCustodi
ex "./actio" importa analyzeRedde, analyzeIace, analyzeScribe, analyzeAdfirma
ex "./error" importa analyzeTempta, analyzeFac, analyzeCura

# =============================================================================
# MAIN DISPATCHER
# =============================================================================

# Analyze any statement
@ publica
@ publica
functio analyzeSententia(Resolvitor r, Sententia stmt) -> vacuum {
    discerne stmt {
        # Declarations
        si VariaDeclaratio {
            analyzeVariaDeclaratio(r, stmt)
        }

        si FunctioDeclaratio {
            analyzeFunctioDeclaratio(r, stmt)
        }

        si GenusDeclaratio {
            analyzeGenusDeclaratio(r, stmt)
        }

        si PactumDeclaratio {
            analyzePactumDeclaratio(r, stmt)
        }

        si OrdoDeclaratio {
            analyzeOrdoDeclaratio(r, stmt)
        }

        si DiscretioDeclaratio {
            analyzeDiscretioDeclaratio(r, stmt)
        }

        si TypusAlias {
            analyzeTypusAlias(r, stmt)
        }

        # Control flow
        si Si {
            analyzeSi(r, stmt)
        }

        si Dum {
            analyzeDum(r, stmt)
        }

        si Iteratio {
            analyzeIteratio(r, stmt)
        }

        si In {
            analyzeIn(r, stmt)
        }

        si Elige {
            analyzeElige(r, stmt)
        }

        si Discerne {
            analyzeDiscerne(r, stmt)
        }

        si Custodi {
            analyzeCustodi(r, stmt)
        }

        # Action statements
        si Redde {
            analyzeRedde(r, stmt)
        }

        si Iace {
            analyzeIace(r, stmt)
        }

        si Scribe {
            analyzeScribe(r, stmt)
        }

        si Adfirma {
            analyzeAdfirma(r, stmt)
        }

        # Error handling
        si Tempta {
            analyzeTempta(r, stmt)
        }

        si Fac {
            analyzeFac(r, stmt)
        }

        si Cura {
            analyzeCura(r, stmt)
        }

        # Block
        si Massa ut m {
            ex m.corpus pro s {
                r.sententia(s)
            }
        }

        # Expression statement
        si Expressia ut e {
            r.expressia(e.expressia)
        }

        # Rumpe/Perge - no analysis needed
        si Rumpe {
            # break - no semantic analysis needed
        }

        si Perge {
            # continue - no semantic analysis needed
        }

        # Imports - handled separately during predeclaration
        si Importa {
            # Imports are processed in predeclaration phase
        }
    }
}
