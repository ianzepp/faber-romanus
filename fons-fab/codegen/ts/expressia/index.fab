# TypeScript Expression Generator - Dispatch to expression handlers
#
# Routes expression AST nodes to their specific generators.
# Uses scriptum() for string formatting for consistency.

ex "../../../ast/expressia" importa Expressia, LitteraGenus, ObiectumProprietas
ex "../../../ast/typus" importa TypusAnnotatio
ex "../nucleus" importa TsGenerator
ex "../typus" importa genTypus

# =============================================================================
# EXPRESSION DISPATCH
# =============================================================================

# Generate TypeScript code for an expression
@ publica
@ publica
functio genExpressia(Expressia expr, TsGenerator g) -> textus {
    discerne expr {
        # Identifiers
        casu Nomen ut e {
            redde e.valor qua textus
        }

        casu EgoExpressia {
            redde "this"
        }

        # Literals
        casu Littera ut e {
            redde genLittera(e.species qua LitteraGenus, e.crudus qua textus)
        }

        casu LitteraExemplar ut e {
            redde genLitteraExemplar(e.partes qua lista<textus>, e.expressiae qua lista<Expressia>, g)
        }

        casu LitteraRegex ut e {
            g.features.usesRegex = verum
            redde scriptum("/{}/{}", e.forma, e.vexilla)
        }

        # Binary and unary
        casu BinariaExpressia ut e {
            redde scriptum("({} {} {})", genExpressia(e.sinister, g), e.signum, genExpressia(e.dexter, g))
        }

        casu UnariaExpressia ut e {
            redde scriptum("{}{}", e.signum, genExpressia(e.argumentum, g))
        }

        casu AssignatioExpressia ut e {
            redde scriptum("{} {} {}", genExpressia(e.sinister, g), e.signum, genExpressia(e.dexter, g))
        }

        casu CondicioExpressia ut e {
            redde scriptum("{} ? {} : {}", genExpressia(e.condicio, g), genExpressia(e.consequens, g), genExpressia(e.alternans, g))
        }

        casu AmbitusExpressia ut e {
            # Range expressions become array generation
            redde scriptum("[{}, {}]", genExpressia(e.initium, g), genExpressia(e.finis, g))
        }

        casu QuaExpressia ut e {
            redde scriptum("{} as {}", genExpressia(e.expressia, g), genTypus(e.scopus qua TypusAnnotatio, g))
        }

        casu EstExpressia ut e {
            redde genEstExpressia(e.expressia, e.scopus qua TypusAnnotatio, g)
        }

        casu CatenaExpressia ut e {
            # Collection DSL chains - TODO: implement properly
            redde genExpressia(e.fons, g)
        }

        casu PraefixumExpressia ut e {
            # Compile-time evaluation - in TS, just evaluate the expression
            redde genExpressia(e.corpus, g)
        }

        # Calls and member access
        casu VocatioExpressia ut e {
            varia args = [] qua lista<textus>
            ex (e.argumenta qua lista<Expressia>) pro arg {
                args.adde(genExpressia(arg, g))
            }
            fixum optMark = (e.optivum qua bivalens) sic "?." secus ""
            redde scriptum("{}{}({})", genExpressia(e.vocatum, g), optMark, args.coniunge(", "))
        }

        casu MembrumExpressia ut e {
            fixum obj = genExpressia(e.obiectum, g)
            si e.computatum qua bivalens {
                fixum idx = genExpressia(e.proprietas, g)
                si e.optivum qua bivalens {
                    redde scriptum("{}?.[{}]", obj, idx)
                }
                redde scriptum("{}[{}]", obj, idx)
            }
            # Dot access
            fixum prop = genExpressia(e.proprietas, g)
            si e.optivum qua bivalens {
                redde scriptum("{}?.{}", obj, prop)
            }
            si e.nonNullum qua bivalens {
                redde scriptum("{}!.{}", obj, prop)
            }
            redde scriptum("{}.{}", obj, prop)
        }

        casu NovumExpressia ut e {
            varia args = [] qua lista<textus>
            ex (e.argumenta qua lista<Expressia>) pro arg {
                args.adde(genExpressia(arg, g))
            }
            varia result = scriptum("new {}({})", genExpressia(e.vocatum, g), args.coniunge(", "))
            si nonnihil e.initor {
                result = scriptum("{} /* initor: {} */", result, genExpressia(e.initor, g))
            }
            redde result
        }

        casu CedeExpressia ut e {
            # cede maps to yield in generators, await in async functions
            si g.inFiunt {
                redde scriptum("yield respond.item({})", genExpressia(e.argumentum, g))
            }
            si g.inFient {
                redde scriptum("yield respond.item(await {})", genExpressia(e.argumentum, g))
            }
            si g.inGenerator {
                redde scriptum("yield {}", genExpressia(e.argumentum, g))
            }
            redde scriptum("await {}", genExpressia(e.argumentum, g))
        }

        casu ScriptumExpressia ut e {
            redde genScriptum(e.exemplar qua textus, e.argumenta qua lista<Expressia>, g)
        }

        casu LegeExpressia ut e {
            si (e.modus qua textus) == "line" {
                redde "await _readline()"
            }
            redde "await _read()"
        }

        casu AbExpressia ut e {
            redde scriptum("{}.{}", genExpressia(e.fons, g), genExpressia(e.transformatio, g))
        }

        # Collections
        casu SeriesExpressia ut e {
            varia items = [] qua lista<textus>
            ex (e.elementa qua lista<Expressia>) pro elem {
                items.adde(genExpressia(elem, g))
            }
            redde scriptum("[{}]", items.coniunge(", "))
        }

        casu ObiectumExpressia ut e {
            redde genObiectum(e.proprietates qua lista<ObiectumProprietas>, g)
        }

        casu DispersioElementum ut e {
            redde scriptum("...{}", genExpressia(e.argumentum, g))
        }

        # Lambda
        casu LambdaExpressia ut e {
            ex "../../../ast/expressia" importa LambdaParametrum
            varia params = [] qua lista<textus>
            ex (e.parametra qua lista<LambdaParametrum>) pro p {
                si nonnihil p.typus {
                    params.adde(scriptum("{}: {}", p.nomen, genTypus(p.typus qua TypusAnnotatio, g)))
                } secus {
                    params.adde(p.nomen)
                }
            }
            varia retType = ""
            si nonnihil e.typusReditus {
                retType = scriptum(": {}", genTypus(e.typusReditus qua TypusAnnotatio, g))
            }
            redde scriptum("({}){} => {}", params.coniunge(", "), retType, genExpressia(e.corpus, g))
        }

        # Discretio construction
        casu FingeExpressia ut e {
            # finge Click { x: 10 } qua Event -> { tag: 'Click', x: 10 }
            varia props = [] qua lista<textus>
            props.adde(scriptum("tag: '{}'", e.variansNomen))
            ex (e.campi qua lista<ObiectumProprietas>) pro campo {
                fixum key = genExpressia(campo.clavis, g)
                fixum val = genExpressia(campo.valor, g)
                props.adde(scriptum("{}: {}", key, val))
            }
            redde scriptum("{{ {} }}", props.coniunge(", "))
        }
    }

    # Fallback - should not reach here
    redde "/* unknown expression */"
}

# =============================================================================
# LITERAL HELPERS
# =============================================================================

# Generate literal value
@ publica
functio genLittera(LitteraGenus species, textus crudus) -> textus {
    si species == LitteraGenus.Verum {
        redde "true"
    }
    si species == LitteraGenus.Falsum {
        redde "false"
    }
    si species == LitteraGenus.Nihil {
        redde "null"
    }
    # Numerus, Fractus, Textus all pass through raw value
    redde crudus
}

# Generate template literal
@ publica
functio genLitteraExemplar(lista<textus> partes, lista<Expressia> expressiae, TsGenerator g) -> textus {
    varia result = "`"
    varia i = 0
    ex partes pro pars {
        result = result + pars
        si i < expressiae.longitudo() {
            result = result + "${" + genExpressia(expressiae[i], g) + "}"
        }
        i += 1
    }
    result = result + "`"
    redde result
}

# =============================================================================
# COMPLEX EXPRESSION HELPERS
# =============================================================================

# Generate est (type check) expression
@ publica
functio genEstExpressia(Expressia expr, TypusAnnotatio scopus, TsGenerator g) -> textus {
    fixum val = genExpressia(expr, g)

    # Primitive type checks use typeof
    si scopus.nomen == "textus" {
        redde scriptum("typeof {} === 'string'", val)
    }
    si scopus.nomen == "numerus" aut scopus.nomen == "fractus" {
        redde scriptum("typeof {} === 'number'", val)
    }
    si scopus.nomen == "bivalens" {
        redde scriptum("typeof {} === 'boolean'", val)
    }
    si scopus.nomen == "nihil" {
        redde scriptum("{} === null", val)
    }

    # User-defined types use instanceof
    redde scriptum("{} instanceof {}", val, scopus.nomen)
}

# Generate scriptum (format string) expression
@ publica
functio genScriptum(textus exemplar, lista<Expressia> argumenta, TsGenerator g) -> textus {
    # Convert scriptum("Hello, {}!", name) to template literal
    # Simple approach: replace {} with ${arg} in sequence
    varia result = "`"
    varia argIndex = 0
    varia i = 0

    dum i < exemplar.longitudo() {
        fixum c = exemplar[i]
        si c == "{" et i + 1 < exemplar.longitudo() et exemplar[i + 1] == "}" {
            # Found {} placeholder
            si argIndex < argumenta.longitudo() {
                result = result + "${" + genExpressia(argumenta[argIndex], g) + "}"
                argIndex += 1
            }
            i = i + 2
        } secus {
            result = result + c
            i += 1
        }
    }

    result = result + "`"
    redde result
}

# Generate object literal
@ publica
functio genObiectum(lista<ObiectumProprietas> proprietates, TsGenerator g) -> textus {
    si proprietates.longitudo() == 0 {
        redde "{}"
    }

    varia props = [] qua lista<textus>
    ex proprietates pro prop {
        si prop.brevitas {
            # Shorthand: { name } -> { name }
            props.adde(genExpressia(prop.clavis, g))
        } sin prop.computatum {
            # Computed: { [expr]: value }
            props.adde(scriptum("[{}]: {}", genExpressia(prop.clavis, g), genExpressia(prop.valor, g)))
        } secus {
            # Normal: { key: value }
            props.adde(scriptum("{}: {}", genExpressia(prop.clavis, g), genExpressia(prop.valor, g)))
        }
    }

    redde scriptum("{{ {} }}", props.coniunge(", "))
}
