/// Variable Declaration Parsers
///
/// Variable declarations, destructuring patterns, and related constructs.
///
/// GRAMMAR:
///   varDecl := ('varia' | 'fixum' | 'figendum' | 'variandum') typeAnnotation? IDENTIFIER ('=' expression)?
///   arrayPattern := '[' arrayPatternElement (',' arrayPatternElement)* ']'
///   objectPattern := '{' patternProperty (',' patternProperty)* '}'
///
/// LATIN VOCABULARY:
/// - varia = variable (let it vary)
/// - fixum = fixed (const)
/// - figendum = to be fixed (const + await)
/// - variandum = to be varied (let + await)
/// - ceteri = the rest (rest pattern)
/// - omissum = omitted/skipped (placeholder _)

ex "../resolvitor" importa Resolvitor, Expressia, TypusAnnotatio
ex "../../ast/positio" importa Locus
ex "../../ast/lexema" importa SymbolumGenus
ex "../errores" importa ParserErrorCodice

/// Nomen - identifier AST node
genus Nomen {
    Locus locus
    textus valor
}

/// VariaGenus - variable declaration kind
ordo VariaGenus {
    Varia,
    Fixum,
    Figendum,
    Variandum
}

/// ObiectumFormaProprietas - object destructuring property
genus ObiectumFormaProprietas {
    Locus locus
    Nomen clavis
    Nomen valor
    bivalens residuum
}

/// ObiectumForma - object destructuring pattern
genus ObiectumForma {
    Locus locus
    lista<ObiectumFormaProprietas> proprietates
}

/// SeriesFormaElementum - array destructuring element
genus SeriesFormaElementum {
    Locus locus
    Nomen nomen
    bivalens omissum
    bivalens residuum
}

/// SeriesForma - array destructuring pattern
genus SeriesForma {
    Locus locus
    lista<SeriesFormaElementum> elementa
}

/// VariaSententia - variable declaration AST node
genus VariaSententia {
    Locus locus
    VariaGenus modus
    Nomen? nomen
    SeriesForma? seriesForma
    TypusAnnotatio? adnotatio
    Expressia? initium
}

/// Parse an identifier (simple name reference)
functio parseNomen(Resolvitor r) -> Nomen {
    fixum p = r.parser()
    fixum symbolum = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    redde {
        locus: symbolum.locus,
        valor: symbolum.valor
    } qua Nomen
}

/// Parse identifier or keyword (for import specifiers, property names)
/// Keywords like 'scribe' can be valid identifiers in some contexts
functio parseNomenVelVerbum(Resolvitor r) -> Nomen {
    fixum p = r.parser()
    fixum s = p.specta(0)

    si s.species === SymbolumGenus.Nomen aut s.species === SymbolumGenus.Verbum {
        p.procede()
        redde {
            locus: s.locus,
            valor: s.valor
        } qua Nomen
    }

    // Error: expected identifier
    p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("got '{}'", s.valor))
    p.procede()
    redde {
        locus: s.locus,
        valor: s.valor
    } qua Nomen
}

/// Parse object destructuring pattern
///
/// GRAMMAR: objectPattern := '{' patternProperty (',' patternProperty)* '}'
///
/// Examples:
///   { nomen, aetas }              -> extract nomen and aetas
///   { nomen: localName }          -> rename nomen to localName
///   { nomen, ceteri rest }        -> extract nomen, collect rest in 'rest'
functio parseObiectumForma(Resolvitor r) -> ObiectumForma {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    // Expect opening brace
    p.expecta(SymbolumGenus.UncusSin, ParserErrorCodice.ExpectaturUncusSin)

    varia proprietates = [] qua lista<ObiectumFormaProprietas>

    // Parse properties until closing brace
    dum non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
        fixum propLocus = p.specta(0).locus

        // Check for rest pattern: ceteri restName
        varia residuum = falsum
        si p.congruetVerbum("ceteri") {
            residuum = verum
        }

        // Parse key identifier
        fixum clavis = parseNomenVelVerbum(r)

        // Default value is same as key (shorthand)
        varia valor = clavis

        // Check for rename: { nomen: localName }
        // Not valid with ceteri rest pattern
        si p.congruet(SymbolumGenus.Colon) et non residuum {
            valor = parseNomenVelVerbum(r)
        }

        proprietates.adde({
            locus: propLocus,
            clavis: clavis,
            valor: valor,
            residuum: residuum
        } qua ObiectumFormaProprietas)

        // Expect comma or closing brace
        si non p.proba(SymbolumGenus.UncusDex) {
            p.expecta(SymbolumGenus.Virgula, ParserErrorCodice.ExpectaturVirgula)
        }
    }

    // Expect closing brace
    p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)

    redde {
        locus: locus,
        proprietates: proprietates
    } qua ObiectumForma
}

/// Parse array destructuring pattern
///
/// GRAMMAR: arrayPattern := '[' arrayPatternElement (',' arrayPatternElement)* ']'
///
/// Examples:
///   [a, b, c]              -> extract first three elements
///   [first, ceteri rest]   -> extract first, collect rest
///   [_, second, _]         -> skip first and third
functio parseSeriesForma(Resolvitor r) -> SeriesForma {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    // Expect opening bracket
    p.expecta(SymbolumGenus.QuadratusSin, ParserErrorCodice.ExpectaturQuadratusSin)

    varia elementa = [] qua lista<SeriesFormaElementum>

    // Parse elements until closing bracket
    dum non p.proba(SymbolumGenus.QuadratusDex) et non p.estFinis() {
        fixum elemLocus = p.specta(0).locus

        // Check for rest pattern: ceteri restName
        varia residuum = falsum
        si p.congruetVerbum("ceteri") {
            residuum = verum
        }

        // Check for skip pattern: _
        si non residuum et p.proba(SymbolumGenus.Nomen) et p.specta(0).valor === "_" {
            p.procede()  // consume '_'
            elementa.adde({
                locus: elemLocus,
                nomen: { locus: elemLocus, valor: "_" } qua Nomen,
                omissum: verum,
                residuum: falsum
            } qua SeriesFormaElementum)
        } secus {
            // Regular binding or rest binding
            fixum nomen = parseNomen(r)
            elementa.adde({
                locus: elemLocus,
                nomen: nomen,
                omissum: falsum,
                residuum: residuum
            } qua SeriesFormaElementum)
        }

        // Expect comma or closing bracket
        si non p.proba(SymbolumGenus.QuadratusDex) {
            p.expecta(SymbolumGenus.Virgula, ParserErrorCodice.ExpectaturVirgula)
        }
    }

    // Expect closing bracket
    p.expecta(SymbolumGenus.QuadratusDex, ParserErrorCodice.ExpectaturQuadratusDex)

    redde {
        locus: locus,
        elementa: elementa
    } qua SeriesForma
}

/// Parse variable declaration
///
/// GRAMMAR: varDecl := ('varia'|'fixum'|'figendum'|'variandum') type? name ('=' expr)?
///
/// Supports:
/// - Type inference: fixum x = 42
/// - Type-first: fixum numerus x = 42
/// - Array destructuring: fixum [a, b] = coords
functio parseVariaSententia(Resolvitor r) -> VariaSententia {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    // Get declaration kind from keyword
    fixum verbum = p.specta(0).verbum
    varia modus = VariaGenus.Varia

    elige verbum {
        si "varia" { modus = VariaGenus.Varia }
        si "fixum" { modus = VariaGenus.Fixum }
        si "figendum" { modus = VariaGenus.Figendum }
        si "variandum" { modus = VariaGenus.Variandum }
    }

    // Consume the keyword
    p.procede()

    // -------------------------------------------------------------------------
    // Determine what follows: type, name, or destructuring pattern
    // -------------------------------------------------------------------------
    varia adnotatio = nihil qua TypusAnnotatio?
    varia nomen = nihil qua Nomen?
    varia seriesForma = nihil qua SeriesForma?

    si p.proba(SymbolumGenus.QuadratusSin) {
        // Array destructuring: fixum [a, b] = arr
        seriesForma = parseSeriesForma(r)
    } sin p.estTypusNomen(p.specta(0)) {
        // Builtin type: fixum numerus x = 42
        adnotatio = r.adnotatio()
        nomen = parseNomen(r)
    } sin p.proba(SymbolumGenus.Nomen) et p.specta(1).species === SymbolumGenus.Nomen {
        // Two identifiers: first is type, second is name
        // Handles user-defined types: fixum UserId id = 42
        adnotatio = r.adnotatio()
        nomen = parseNomen(r)
    } secus {
        // Just a name (type inference): fixum x = 42
        nomen = parseNomen(r)
    }

    // -------------------------------------------------------------------------
    // Parse optional initializer
    // -------------------------------------------------------------------------
    varia initium = nihil qua Expressia?

    si p.congruet(SymbolumGenus.Aequale) {
        initium = r.expressia()
    }

    redde {
        locus: locus,
        modus: modus,
        nomen: nomen,
        seriesForma: seriesForma,
        adnotatio: adnotatio,
        initium: initium
    } qua VariaSententia
}
