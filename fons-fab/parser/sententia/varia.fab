# Variable Declaration Parsers
#
# Variable declarations, destructuring patterns, and related constructs.
#
# GRAMMAR:
#   varDecl := ('varia' | 'fixum' | 'figendum' | 'variandum') typeAnnotation? IDENTIFIER ('=' expression)?
#   arrayPattern := '[' arrayPatternElement (',' arrayPatternElement)* ']'
#   objectPattern := '{' patternProperty (',' patternProperty)* '}'
#
# LATIN VOCABULARY:
# - varia = variable (let it vary)
# - fixum = fixed (const)
# - figendum = to be fixed (const + await)
# - variandum = to be varied (let + await)
# - ceteri = the rest (rest pattern)
# - omissum = omitted/skipped (placeholder _)

ex "../resolvitor" importa Resolvitor
ex "../../ast/positio" importa Locus
ex "../../ast/expressia" importa Expressia
ex "../../ast/sententia" importa Sententia, VariaGenus
ex "../../ast/typus" importa TypusAnnotatio
ex "../../ast/lexema" importa SymbolumGenus
ex "../errores" importa ParserErrorCodice

# Parse an identifier (simple name reference)
@ publica
functio parseNomen(Resolvitor r) -> textus {
    fixum p = r.parser()
    fixum symbolum = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    redde symbolum.valor
}

# Parse identifier or keyword (for import specifiers, property names)
# Keywords like 'scribe' can be valid identifiers in some contexts
@ publica
functio parseNomenVelVerbum(Resolvitor r) -> textus {
    fixum p = r.parser()
    fixum s = p.specta(0)

    si s.species === SymbolumGenus.Nomen aut s.species === SymbolumGenus.Verbum {
        p.procede()
        redde s.valor
    }

    # Error: expected identifier
    p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("got '{}'", s.valor))
    p.procede()
    redde s.valor
}

# Parse variable declaration
#
# GRAMMAR: varDecl := ('varia'|'fixum'|'figendum'|'variandum') type? name ('=' expr)?
#
# Supports:
# - Type inference: fixum x = 42
# - Type-first: fixum numerus x = 42
# - Array destructuring: fixum [a, b] = coords (TODO)
@ publica
functio parseVariaSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    # Get declaration kind from keyword
    fixum verbum = p.specta(0).verbum
    varia species = VariaGenus.Varia

    elige verbum {
        casu "varia" { species = VariaGenus.Varia }
        casu "fixum" { species = VariaGenus.Fixum }
        casu "figendum" { species = VariaGenus.Figendum }
        casu "variandum" { species = VariaGenus.Variandum }
    }

    # Consume the keyword
    p.procede()

    # -------------------------------------------------------------------------
    # Determine what follows: type, name, or destructuring pattern
    # -------------------------------------------------------------------------
    varia adnotatio = nihil qua TypusAnnotatio?
    varia nomen = ""

    # TODO: Handle array destructuring [a, b] = arr

    si p.estTypusNomen(p.specta(0)) {
        # Builtin type: fixum numerus x = 42
        adnotatio = r.adnotatio()
        nomen = parseNomen(r)
    } sin p.proba(SymbolumGenus.Nomen) et p.specta(1).species === SymbolumGenus.Nomen {
        # Two identifiers: first is type, second is name
        # Handles user-defined types: fixum UserId id = 42
        adnotatio = r.adnotatio()
        nomen = parseNomen(r)
    } secus {
        # Just a name (type inference): fixum x = 42
        nomen = parseNomen(r)
    }

    # -------------------------------------------------------------------------
    # Parse optional initializer
    # -------------------------------------------------------------------------
    varia valor = nihil qua Expressia?

    si p.congruet(SymbolumGenus.Aequum) {
        valor = r.expressia()
    }

    redde finge VariaSententia {
        locus: locus,
        species: species,
        nomen: nomen,
        typus: adnotatio,
        valor: valor
    } qua Sententia
}
