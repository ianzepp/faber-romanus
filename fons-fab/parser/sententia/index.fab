/// Statement Dispatcher
///
/// Central dispatcher for parsing statements based on leading keyword.
/// Handles comment attachment and error recovery.
///
/// STATUS: Resolvitor conversion in progress
/// BLOCKED: Same type system issue as expression parsers.
///          Statement types need to be variants of Sententia discretio.
///
/// GRAMMAR:
///   statement := importDecl | varDecl | funcDecl | typeAliasDecl | ifStmt
///              | whileStmt | forStmt | returnStmt | throwStmt | tryStmt
///              | blockStmt | exprStmt | ...
///
/// LATIN VOCABULARY:
/// - sententia = statement (sentence/thought)
/// - declara = declare
/// - imperium = control (command)

ex "../resolvitor" importa Resolvitor, Sententia, Expressia, MassaSententia
ex "../../ast/positio" importa Locus
ex "../../ast/lexema" importa SymbolumGenus
ex "../errores" importa ParserErrorCodice

// Import statement parsers from submodules
// These are defined in actio.fab, error.fab, massa.fab, varia.fab
// TODO: Add proper imports once those modules export their functions

/// Parse a statement with comment attachment
///
/// Entry point for statement parsing. Collects comments before
/// parsing, then attaches them to the resulting statement.
functio parseSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    
    // Collect any leading comments before parsing
    p.colligeNotas()

    // Parse the statement via Resolvitor
    // The actual dispatch will be done by ResolvitorImpl
    redde r.sententia()
}

/// Attach pending comments to a statement (stub)
///
/// Collects leading comments that were buffered before the statement,
/// and trailing comments that appear on the same line after.
functio adiungNotae(Resolvitor r, Sententia s) -> Sententia {
    // TODO: Implement comment attachment
    redde s
}

// TODO: Implement parseSententiaSineNotis once type system issue is resolved
// This is the main dispatcher that checks for keywords and routes to
// appropriate parsers (parseVariaSententia, parseTemptaSententia, etc.)
