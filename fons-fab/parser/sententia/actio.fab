/// Action Statement Parsers
///
/// Simple action statements: redde, rumpe, perge, iace, scribe.
/// These are the smallest, most self-contained statement parsers.
///
/// GRAMMAR:
///   returnStmt := 'redde' expression?
///   breakStmt := 'rumpe'
///   continueStmt := 'perge'
///   throwStmt := ('iace' | 'mori') expression
///   outputStmt := ('scribe' | 'vide' | 'mone') expression (',' expression)*
///
/// LATIN VOCABULARY:
/// - redde = return (give back)
/// - rumpe = break
/// - perge = continue (proceed)
/// - iace = throw
/// - mori = die/panic
/// - scribe = write/log
/// - vide = see/debug
/// - mone = warn

ex "../resolvitor" importa Resolvitor, Expressia
ex "../../ast/positio" importa Locus
ex "../../ast/lexema" importa SymbolumGenus
ex "../errores" importa ParserErrorCodice

/// ReddeSententia - return statement AST node
genus ReddeSententia {
    Locus locus
    Expressia? argumentum
}

/// RumpeSententia - break statement AST node
genus RumpeSententia {
    Locus locus
}

/// PergeSententia - continue statement AST node
genus PergeSententia {
    Locus locus
}

/// IaceSententia - throw/panic statement AST node
genus IaceSententia {
    Locus locus
    bivalens fatalis
    Expressia argumentum
}

/// ScribeGradus - output level enum
ordo ScribeGradus {
    Scribe,
    Vide,
    Mone
}

/// ScribeSententia - output statement AST node
genus ScribeSententia {
    Locus locus
    ScribeGradus gradus
    lista<Expressia> argumenta
}

/// Parse return statement
///
/// GRAMMAR: returnStmt := 'redde' expression?
///
/// Return value is optional - bare 'redde' returns void.
/// Doesn't consume expression if next token is closing brace.
functio parseReddeSententia(Resolvitor r) -> ReddeSententia {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    // Consume 'redde' keyword
    p.expectaVerbum("redde", ParserErrorCodice.ExpectaturRedde)

    // Check if there's a return value
    // Don't parse expression if we hit closing brace or end
    varia argumentum = nihil qua Expressia?

    si non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
        argumentum = r.expressia()
    }

    redde {
        locus: locus,
        argumentum: argumentum
    } qua ReddeSententia
}

/// Parse break statement
///
/// GRAMMAR: breakStmt := 'rumpe'
///
/// Exits the innermost loop.
functio parseRumpeSententia(Resolvitor r) -> RumpeSententia {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    // Consume 'rumpe' keyword (already validated by caller)
    p.procede()

    redde {
        locus: locus
    } qua RumpeSententia
}

/// Parse continue statement
///
/// GRAMMAR: continueStmt := 'perge'
///
/// Skips to next loop iteration.
functio parsePergeSententia(Resolvitor r) -> PergeSententia {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    // Consume 'perge' keyword (already validated by caller)
    p.procede()

    redde {
        locus: locus
    } qua PergeSententia
}

/// Parse throw/panic statement
///
/// GRAMMAR: throwStmt := ('iace' | 'mori') expression
///
/// Two severity levels:
/// - iace (throw): recoverable, can be caught
/// - mori (die): fatal/panic, unrecoverable
functio parseIaceSententia(Resolvitor r, bivalens fatalis) -> IaceSententia {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    // Consume keyword (iace or mori, already validated by caller)
    p.procede()

    // Parse the error expression
    fixum argumentum = r.expressia()

    redde {
        locus: locus,
        fatalis: fatalis,
        argumentum: argumentum
    } qua IaceSententia
}

/// Parse output statement (scribe/vide/mone)
///
/// GRAMMAR: outputStmt := ('scribe' | 'vide' | 'mone') expression (',' expression)*
///
/// Maps to console output:
/// - scribe → console.log
/// - vide → console.debug
/// - mone → console.warn
functio parseScribeSententia(Resolvitor r, ScribeGradus gradus) -> ScribeSententia {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    // Consume keyword (already validated by caller)
    p.procede()

    // Parse first argument (required)
    varia argumenta = [] qua lista<Expressia>
    argumenta.adde(r.expressia())

    // Parse additional comma-separated arguments
    dum p.congruet(SymbolumGenus.Virgula) {
        argumenta.adde(r.expressia())
    }

    redde {
        locus: locus,
        gradus: gradus,
        argumenta: argumenta
    } qua ScribeSententia
}
