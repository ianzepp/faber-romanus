/// Action Statement Parsers
///
/// Simple action statements: redde, rumpe, perge, iace, scribe.
/// These are the smallest, most self-contained statement parsers.
///
/// GRAMMAR:
///   returnStmt := 'redde' expression?
///   breakStmt := 'rumpe'
///   continueStmt := 'perge'
///   throwStmt := ('iace' | 'mori') expression
///   outputStmt := ('scribe' | 'vide' | 'mone') expression (',' expression)*
///
/// LATIN VOCABULARY:
/// - redde = return (give back)
/// - rumpe = break
/// - perge = continue (proceed)
/// - iace = throw
/// - mori = die/panic
/// - scribe = write/log
/// - vide = see/debug
/// - mone = warn

ex "../resolvitor" importa Resolvitor
ex "../../ast/positio" importa Locus
ex "../../ast/expressia" importa Expressia
ex "../../ast/sententia" importa Sententia, ScribeGradus
ex "../../ast/lexema" importa SymbolumGenus
ex "../errores" importa ParserErrorCodice

/// Parse return statement
///
/// GRAMMAR: returnStmt := 'redde' expression?
///
/// Return value is optional - bare 'redde' returns void.
/// Doesn't consume expression if next token is closing brace.
functio parseReddeSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    // Consume 'redde' keyword
    p.expectaVerbum("redde", ParserErrorCodice.ExpectaturRedde)

    // Check if there's a return value
    // Don't parse expression if we hit closing brace or end
    varia valor = nihil qua Expressia?

    si non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
        valor = r.expressia()
    }

    redde finge ReddeSententia {
        locus: locus,
        valor: valor
    } qua Sententia
}

/// Parse break statement
///
/// GRAMMAR: breakStmt := 'rumpe'
///
/// Exits the innermost loop.
functio parseRumpeSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    // Consume 'rumpe' keyword (already validated by caller)
    p.procede()

    redde finge RumpeSententia {
        locus: locus
    } qua Sententia
}

/// Parse continue statement
///
/// GRAMMAR: continueStmt := 'perge'
///
/// Skips to next loop iteration.
functio parsePergeSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    // Consume 'perge' keyword (already validated by caller)
    p.procede()

    redde finge PergeSententia {
        locus: locus
    } qua Sententia
}

/// Parse throw/panic statement
///
/// GRAMMAR: throwStmt := ('iace' | 'mori') expression
///
/// Two severity levels:
/// - iace (throw): recoverable, can be caught
/// - mori (die): fatal/panic, unrecoverable
functio parseIaceSententia(Resolvitor r, bivalens fatale) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    // Consume keyword (iace or mori, already validated by caller)
    p.procede()

    // Parse the error expression
    fixum argumentum = r.expressia()

    redde finge IaceSententia {
        locus: locus,
        fatale: fatale,
        argumentum: argumentum
    } qua Sententia
}

/// Parse output statement (scribe/vide/mone)
///
/// GRAMMAR: outputStmt := ('scribe' | 'vide' | 'mone') expression (',' expression)*
///
/// Maps to console output:
/// - scribe → console.log
/// - vide → console.debug
/// - mone → console.warn
functio parseScribeSententia(Resolvitor r, ScribeGradus gradus) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    // Consume keyword (already validated by caller)
    p.procede()

    // Parse first argument (required)
    varia argumenta = [] qua lista<Expressia>
    argumenta.adde(r.expressia())

    // Parse additional comma-separated arguments
    dum p.congruet(SymbolumGenus.Virgula) {
        argumenta.adde(r.expressia())
    }

    redde finge ScribeSententia {
        locus: locus,
        gradus: gradus,
        argumenta: argumenta
    } qua Sententia
}
