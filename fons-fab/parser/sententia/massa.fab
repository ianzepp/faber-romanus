/// Block and Program Parsers
///
/// Top-level program parsing and block statement handling.
///
/// GRAMMAR:
///   program := statement*
///   blockStmt := '{' statement* '}'
///   exprStmt := expression
///
/// LATIN VOCABULARY:
/// - programma = program
/// - massa = block/mass (a body of statements)
/// - sententia = statement
/// - expressia = expression

ex "../resolvitor" importa Resolvitor, Expressia, Sententia, MassaSententia
ex "../../ast/positio" importa Locus
ex "../../ast/lexema" importa SymbolumGenus
ex "../errores" importa ParserErrorCodice

/// Programma - top-level program AST node
genus Programma {
    Locus locus
    lista<Sententia> corpus
}

/// ExpressiaSententia - expression statement AST node
genus ExpressiaSententia {
    Locus locus
    Expressia expressia
}

/// Parse a block statement
///
/// GRAMMAR: blockStmt := '{' statement* '}'
///
/// Consumes opening brace, parses statements until closing brace.
/// Handles optional semicolons between statements.
functio parseMassaSententia(Resolvitor r) -> MassaSententia {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    // Expect opening brace
    p.expecta(SymbolumGenus.UncusSin, ParserErrorCodice.ExpectaturUncusSin)

    varia corpus = [] qua lista<Sententia>

    // Parse statements until closing brace or end
    dum non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
        // Skip optional semicolons between statements
        dum p.congruet(SymbolumGenus.Semicolon) {
            // Continue skipping
        }

        // Check again after skipping semicolons
        si p.proba(SymbolumGenus.UncusDex) aut p.estFinis() {
            rumpe
        }

        // Parse the next statement
        corpus.adde(r.sententia())
    }

    // Expect closing brace
    p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)

    redde {
        locus: locus,
        corpus: corpus
    } qua MassaSententia
}

/// Parse an expression statement
///
/// GRAMMAR: exprStmt := expression
///
/// Wraps a standalone expression as a statement.
functio parseExpressiaSententia(Resolvitor r) -> ExpressiaSententia {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus
    fixum expressia = r.expressia()

    redde {
        locus: locus,
        expressia: expressia
    } qua ExpressiaSententia
}

/// Parse top-level program
///
/// GRAMMAR: program := statement*
///
/// Parses statements until end of input.
/// Uses error recovery to handle malformed statements.
functio parseProgramma(Resolvitor r) -> Programma {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus
    varia corpus = [] qua lista<Sententia>

    // Parse statements until end of input
    dum non p.estFinis() {
        // Skip optional semicolons between statements
        dum p.congruet(SymbolumGenus.Semicolon) {
            // Continue skipping
        }

        // Check again after skipping
        si p.estFinis() {
            rumpe
        }

        // Try to parse statement with error recovery
        tempta {
            corpus.adde(r.sententia())
        } cape e {
            // Error recovery: skip to next statement boundary
            p.synchrona()
        }
    }

    redde {
        locus: locus,
        corpus: corpus
    } qua Programma
}
