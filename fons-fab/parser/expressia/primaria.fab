# Primary Expression Parsers
#
# Terminals and grouping: literals, identifiers, parenthesized expressions,
# arrays, objects, lambdas.
#
# GRAMMAR:
#   primary := IDENTIFIER | NUMBER | STRING | TEMPLATE_STRING
#            | 'ego' | 'verum' | 'falsum' | 'nihil'
#            | '(' expression ')' | arrayLiteral | objectLiteral
#            | lambdaExpression
#
# LATIN VOCABULARY:
# - primaria = primary
# - littera = literal
# - nomen = identifier/name
# - ego = self/this
# - verum = true
# - falsum = false
# - nihil = null

ex "../resolvitor" importa Resolvitor
ex "../../ast/positio" importa Locus
ex "../../ast/expressia" importa Expressia, LitteraGenus, ObiectumProprietas, LambdaParametrum
ex "../../ast/typus" importa TypusAnnotatio
ex "../../ast/lexema" importa SymbolumGenus
ex "../errores" importa ParserErrorCodice

# Parse primary expression
#
# Handles terminals: literals, identifiers, ego, grouped expressions.
# Currently a partial implementation - covers the most common cases.
@ publica
functio parsePrimaria(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum sym = p.specta(0)
    fixum locus = sym.locus

    # Numeric literal
    si sym.species == SymbolumGenus.Numerus {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Numerus,
            crudus: sym.valor
        } qua Expressia
    }

    # Float literal
    si sym.species == SymbolumGenus.Fractus {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Fractus,
            crudus: sym.valor
        } qua Expressia
    }

    # String literal
    si sym.species == SymbolumGenus.Textus {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Textus,
            crudus: sym.valor
        } qua Expressia
    }

    # Boolean: verum
    si sym.species == SymbolumGenus.Verum {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Verum,
            crudus: "verum"
        } qua Expressia
    }

    # Boolean: falsum
    si sym.species == SymbolumGenus.Falsum {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Falsum,
            crudus: "falsum"
        } qua Expressia
    }

    # Null: nihil
    si sym.species == SymbolumGenus.Nihil {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Nihil,
            crudus: "nihil"
        } qua Expressia
    }

    # Identifier
    si sym.species == SymbolumGenus.Nomen {
        p.procede()
        redde finge Nomen {
            locus: locus,
            valor: sym.valor
        } qua Expressia
    }

    # Self reference: ego
    si p.probaVerbum("ego") {
        p.procede()
        redde finge EgoExpressia {
            locus: locus
        } qua Expressia
    }

    # Grouped expression: ( expr )
    si sym.species == SymbolumGenus.ParensSin {
        p.procede()
        fixum expr = r.expressia()
        p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)
        redde expr
    }

    # Array literal: [ ... ]
    si sym.species == SymbolumGenus.AngulusSin {
        redde parseSeriesExpressia(r)
    }

    # Object literal: { ... }
    si sym.species == SymbolumGenus.UncusSin {
        redde parseObiectumExpressia(r)
    }

    # Lambda: pro x: expr
    si p.probaVerbum("pro") {
        redde parseLambdaExpressia(r)
    }

    # Fallback: report error and return placeholder
    p.renuncia(ParserErrorCodice.ExpectaturExpressia, locus)
    redde finge Nomen {
        locus: locus,
        valor: ""
    } qua Expressia
}

# Parse array literal
#
# GRAMMAR: arrayLiteral := '[' (expression (',' expression)*)? ']'
@ publica
functio parseSeriesExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expecta(SymbolumGenus.AngulusSin, ParserErrorCodice.ExpectaturAngulusSin)

    varia elementa = [] qua lista<Expressia>

    si non p.proba(SymbolumGenus.AngulusDex) {
        elementa.adde(r.expressia())

        dum p.congruet(SymbolumGenus.Virgula) {
            # Allow trailing comma
            si p.proba(SymbolumGenus.AngulusDex) {
                rumpe
            }
            elementa.adde(r.expressia())
        }
    }

    p.expecta(SymbolumGenus.AngulusDex, ParserErrorCodice.ExpectaturAngulusDex)

    redde finge SeriesExpressia {
        locus: locus,
        elementa: elementa
    } qua Expressia
}

# Parse object literal
#
# GRAMMAR: objectLiteral := '{' (property (',' property)*)? '}'
#          property := (IDENTIFIER | STRING) ':' expression
#                    | '[' expr ']' ':' expression  # computed key
#                    | IDENTIFIER                    # shorthand { name } = { name: name }
#                    | 'sparge' expression          # spread: sparge obj
#
# Examples:
#   {}
#   { name: "Alice" }
#   { name: "Alice", age: 30 }
#   { name }                      # shorthand
#   { [key]: value }              # computed
#   { sparge base, extra: 1 }    # spread
@ publica
functio parseObiectumExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expecta(SymbolumGenus.UncusSin, ParserErrorCodice.ExpectaturUncusSin)

    varia proprietates = [] qua lista<ObiectumProprietas>

    # Parse properties until closing brace
    si non p.proba(SymbolumGenus.UncusDex) {
        fac {
            fixum propLocus = p.locusActualis()

            # Check for spread: sparge expr
            si p.probaVerbum("sparge") {
                p.procede()
                fixum argumentum = r.expressia()

                # Add as DispersioElementum property
                # WHY: We wrap spread in ObiectumProprietas with special marker
                #      by using the spread expression as both key and value
                proprietates.adde({
                    locus: propLocus,
                    clavis: argumentum,
                    valor: argumentum,
                    brevitas: falsum,
                    computatum: falsum
                } qua ObiectumProprietas)
            } secus {
                # Parse the key
                varia clavis = nihil qua Expressia?
                varia computatum = falsum

                # Computed property: [expr]
                si p.congruet(SymbolumGenus.AngulusSin) {
                    clavis = r.expressia()
                    p.expecta(SymbolumGenus.AngulusDex, ParserErrorCodice.ExpectaturAngulusDex)
                    computatum = verum
                }
                # String key: "name"
                sin p.proba(SymbolumGenus.Textus) {
                    fixum strSym = p.procede()
                    clavis = finge Littera {
                        locus: strSym.locus,
                        species: LitteraGenus.Textus,
                        crudus: strSym.valor
                    } qua Expressia
                }
                # Identifier key: name
                secus {
                    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
                    clavis = finge Nomen {
                        locus: nomenSym.locus,
                        valor: nomenSym.valor
                    } qua Expressia
                }

                # Check for colon (value follows) or shorthand
                si p.congruet(SymbolumGenus.Colon) {
                    # key: value
                    fixum valor = r.expressia()

                    proprietates.adde({
                        locus: propLocus,
                        clavis: clavis,
                        valor: valor,
                        brevitas: falsum,
                        computatum: computatum
                    } qua ObiectumProprietas)
                } secus {
                    # Shorthand: { name } means { name: name }
                    # Only valid for identifier keys
                    proprietates.adde({
                        locus: propLocus,
                        clavis: clavis,
                        valor: clavis,
                        brevitas: verum,
                        computatum: falsum
                    } qua ObiectumProprietas)
                }
            }
        } dum p.congruet(SymbolumGenus.Virgula) et non p.proba(SymbolumGenus.UncusDex)
    }

    p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)

    redde finge ObiectumExpressia {
        locus: locus,
        proprietates: proprietates
    } qua Expressia
}

# Parse lambda expression
#
# GRAMMAR:
#   lambdaExpr := 'pro' params? ('->' type)? ':' expression
#   params := IDENTIFIER (',' IDENTIFIER)*
#
# Examples:
#   pro: 42                       # zero params
#   pro x: x * 2                  # single param
#   pro x, y: x + y               # multiple params
#   pro x -> numerus: x * 2       # with return type
#
# Note: Block form (pro x { ... }) requires Sententia in corpus,
#       which this AST doesn't support yet. Expression form only.
@ publica
functio parseLambdaExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'pro'
    p.expectaVerbum("pro", ParserErrorCodice.ExpectaturPro)

    varia parametra = [] qua lista<LambdaParametrum>

    # Check for immediate : or -> (zero-param lambda)
    si non p.proba(SymbolumGenus.Colon) et non p.proba(SymbolumGenus.Sagitta) {
        # Parse parameters until we hit : or ->
        fac {
            fixum paramLocus = p.locusActualis()
            fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)

            parametra.adde({
                locus: paramLocus,
                nomen: nomenSym.valor,
                typus: nihil
            } qua LambdaParametrum)
        } dum p.congruet(SymbolumGenus.Virgula)
    }

    # Optional return type: -> Type
    varia typusReditus = nihil qua TypusAnnotatio?
    si p.congruet(SymbolumGenus.Sagitta) {
        typusReditus = r.adnotatio()
    }

    # Expression body: : expr
    p.expecta(SymbolumGenus.Colon, ParserErrorCodice.ExpectaturColon)
    fixum corpus = r.expressia()

    redde finge LambdaExpressia {
        locus: locus,
        parametra: parametra,
        corpus: corpus,
        typusReditus: typusReditus
    } qua Expressia
}
