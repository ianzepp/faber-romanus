/// Unary and Postfix Expression Parsers
///
/// Prefix operators: non, -, ~, cede, novum, etc.
/// Postfix operators: qua (type cast), call, member access
///
/// STATUS: Resolvitor conversion in progress
/// BLOCKED: Same type system issue as binaria.fab
///
/// GRAMMAR:
///   unary := ('non' | '-' | '~' | 'nulla' | 'nonnulla' | ...) unary | cast
///   cast := call ('qua' typeAnnotation)*
///   call := primary (callSuffix | memberSuffix | ...)*
///
/// LATIN VOCABULARY:
/// - unaria = unary
/// - non = not
/// - cede = yield/await
/// - novum = new
/// - qua = as (type cast)

ex "../resolvitor" importa Resolvitor, Expressia, TypusAnnotatio, MassaSententia
ex "../../ast/positio" importa Locus
ex "../../ast/lexema" importa SymbolumGenus
ex "../errores" importa ParserErrorCodice

/// UnariaExpressia - unary expression AST node
genus UnariaExpressia {
    Locus locus
    textus signum
    Expressia argumentum
    bivalens praefixum
}

/// CedeExpressia - await expression AST node
genus CedeExpressia {
    Locus locus
    Expressia argumentum
}

/// QuaExpressia - type cast expression AST node
genus QuaExpressia {
    Locus locus
    Expressia expressia
    TypusAnnotatio adnotatio
}

/// VocatioExpressia - function call expression AST node
genus VocatioExpressia {
    Locus locus
    Expressia vocans
    lista<Expressia> argumenta
}

/// MembrumExpressia - member access expression AST node
genus MembrumExpressia {
    Locus locus
    Expressia obiectum
    Expressia proprietas
    bivalens computatum
    bivalens optionale
}

// TODO: Implement once type system issue is resolved

/// Parse unary expression (stub)
functio parseUnaria(Resolvitor r) -> Expressia {
    redde r.expressia()
}

/// Parse type cast expression (stub)
functio parseQua(Resolvitor r) -> Expressia {
    redde r.expressia()
}

/// Parse call/member expression (stub)
functio parseVocatio(Resolvitor r) -> Expressia {
    redde r.expressia()
}
