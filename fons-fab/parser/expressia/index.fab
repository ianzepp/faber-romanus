/// Expression Parser Entry Point
///
/// Top-level expression parsing using precedence climbing.
/// Entry point delegates to assignment (lowest precedence).
///
/// PRECEDENCE HIERARCHY (lowest to highest):
/// 1. Assignment (=, +=, -=, etc.)
/// 2. Ternary (? : or sic/secus)
/// 3. Logical OR (|| or aut) / Nullish (?? or vel)
/// 4. Logical AND (&& or et)
/// 5. Equality (==, !=, ===, !==, est)
/// 6. Comparison (<, >, <=, >=)
/// 7. Bitwise OR (|)
/// 8. Bitwise XOR (^)
/// 9. Bitwise AND (&)
/// 10. Shift (<<, >>)
/// 11. Range (.., ante, usque)
/// 12. Additive (+, -)
/// 13. Multiplicative (*, /, %)
/// 14. Unary (non, -, ~, cede, novum, etc.)
/// 15. Cast (qua)
/// 16. Call/Member (., [], ())
/// 17. Primary (literals, identifiers, grouping)
///
/// LATIN VOCABULARY:
/// - expressia = expression
/// - assignatio = assignment
/// - condicio = condition
/// - binaria = binary
/// - unaria = unary
/// - primaria = primary

ex "../resolvitor" importa Resolvitor, Expressia

/// Parse an expression (entry point)
///
/// Top-level expression delegates to assignment (lowest precedence).
/// All expression parsing flows through this function.
///
/// NOTE: This calls r.expressia() which will eventually route through
/// the ResolvitorImpl to parseAssignatio in binaria.fab.
/// For now, this file just provides the entry point signature.
functio parseExpressia(Resolvitor r) -> Expressia {
    // Delegate to the expression pipeline via Resolvitor
    // The actual chain is: expressia -> assignatio -> condicio -> ... -> primaria
    redde r.expressia()
}
