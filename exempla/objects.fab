// Objects in Faber Romanus
//
// Object features:
// - Object literals: { key: value }
// - Property access: obj.key
// - Destructuring: fixum { a, b } = obj
// - With blocks: cum obj { ... }
// - Genus (struct): genus name { fields, methods }

// =============================================================================
// OBJECT LITERALS
// =============================================================================

// Object literal - anonymous structure
fixum persona = { nomen: "Marcus", aetas: 30, activus: verum }

scribe persona.nomen
scribe persona.aetas

// Object destructuring - extract properties into variables
fixum { nomen, aetas } = persona
scribe nomen
scribe aetas

// Destructuring with rename
fixum { nomen: userName, aetas: userAge } = persona
scribe userName
scribe userAge

// Mutable destructuring
varia { activus: isActive } = persona
isActive = falsum

// With block (cum) - set properties in context
fixum config = { host: "", port: 0 }
cum config {
    host = "localhost"
    port = 8080
}

scribe config.host
scribe config.port

// =============================================================================
// GENUS (STRUCT)
// =============================================================================
// genus declarations support:
// - Field defaults using `:` (declarative "has value")
// - Instantiation via `novum Type` or `novum Type cum { ... }`
// - Auto-merge: compiler merges defaults + cum overrides
// - Optional `creo()` hook runs after merge (ego already set)
// - Computed fields using `=>`
// - Methods with `ego` self-reference

// Basic genus - fields without defaults
genus punctum {
    numerus x
    numerus y
}

// Genus with default field values
// No creo needed - compiler handles merging defaults with overrides
genus civis {
    textus nomen: "Incognitus"
    numerus aetas: 0
    bivalens activus: verum
}

// Genus with methods
// Methods can reference ego (self) for instance data
genus salutator {
    textus nomen: "Mundus"

    functio saluta() -> textus {
        redde "Salve, " + ego.nomen + "!"
    }
}

// Mixed required and optional fields
genus liber {
    textus titulus              // required - no default
    textus auctor               // required - no default
    numerus annus: 0            // optional - defaults to 0
    bivalens lectus: falsum     // optional - defaults to falsum
}

// Genus with creo() hook + computed property
// creo() takes no args - ego already has merged values
// Use creo() for validation, clamping, or derived state
genus rectangulum {
    numerus latitudo: 1
    numerus altitudo: 1
    publicus numerus area => ego.latitudo * ego.altitudo

    functio creo() {
        // Enforce minimum dimensions
        si ego.latitudo < 1 {
            ego.latitudo = 1
        }
        si ego.altitudo < 1 {
            ego.altitudo = 1
        }
    }
}

// =============================================================================
// GENUS INSTANTIATION + METHODS
// =============================================================================

// Instantiation with defaults
fixum incognitus = novum civis
scribe incognitus.nomen

// Override specific fields via `cum { ... }`
fixum claudia = novum civis cum { nomen: "Claudia", aetas: 28 }
scribe claudia.nomen
scribe claudia.aetas

// Instantiate salutator and call a method using `ego`
fixum sal = novum salutator
fixum salRoma = novum salutator cum { nomen: "Roma" }
scribe sal.saluta()
scribe salRoma.saluta()

// Use constructor + computed property
fixum quadratum = novum rectangulum
fixum poster = novum rectangulum cum { latitudo: 5, altitudo: 3 }
scribe quadratum.area
scribe poster.area
