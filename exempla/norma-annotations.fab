# Stdlib Annotations Example
#
# Demonstrates the four annotation types used to define standard library
# methods with cross-target codegen support.
#
# These annotations are primarily for stdlib authors. User code typically
# does not need them, but library authors may find them useful for providing
# optimized implementations across multiple targets.
#
# NOTE: This file demonstrates annotation syntax only. The functions are
# declared with @ externa since they have no bodies - actual implementations
# come from the target language runtime or @ subsidia files.

# =============================================================================
# @ innatum - Native Type Mapping
# =============================================================================
# Maps a Faber genus to native types in each target language.

@ innatum ts "Array", py "list", zig "Lista", rs "Vec", cpp "std::vector"
genus ExemplarLista { }

@ innatum ts "Map", py "dict", zig "Tabula", rs "HashMap"
genus ExemplarTabula { }

# =============================================================================
# @ subsidia - External Implementation Files
# =============================================================================
# Specifies implementation files for targets where inline codegen is complex.

@ innatum ts "Array", zig "Lista"
@ subsidia zig "subsidia/zig/lista.zig"
genus ExemplarListaExterna { }

# =============================================================================
# @ radix - Morphology Declaration
# =============================================================================
# Declares the verb stem and valid conjugation forms.

# Full morphology: imperative (mutates) + participle (returns new)
@ radix filtr, imperativus, perfectum
@ externa
functio filtraExemplar()

# Imperative only (mutate-only operation)
@ radix purg, imperativus
@ externa
functio purgaExemplar()

# Participle only (always returns new)
@ radix mapp, perfectum
@ externa
functio mappataExemplar()

# =============================================================================
# @ verte - Codegen Transformation
# =============================================================================
# Defines how method calls compile to target code.

# Simple rename: method name maps directly
@ radix add, imperativus
@ verte ts "push"
@ verte py "append"
@ verte rs "push"
@ verte cpp "push_back"
@ verte zig (ego, elem, alloc) -> "§.adde(§, §)"
@ externa
functio addeExemplar()

# Template form: § placeholders filled positionally
@ verte ts (ego, elem) -> "[...§, §]"
@ verte py (ego, elem) -> "[*§, §]"
@ verte zig (ego, elem, alloc) -> "§.addita(§, §)"
@ externa
functio additaExemplar()

# Properties (no morphology - read-only accessors)
@ verte ts (ego) -> "§.length"
@ verte py (ego) -> "len(§)"
@ verte zig (ego) -> "§.longitudo()"
@ externa
functio longitudoExemplar() fit numerus

# =============================================================================
# Combined Example: Full Method Definition
# =============================================================================

@ innatum ts "Array", py "list", zig "Lista"
@ subsidia zig "subsidia/zig/lista.zig"
genus ExemplarListaCompleta { }

@ radix ordin, imperativus, perfectum
@ verte ts "sort"
@ verte py "sort"
@ verte zig (ego) -> "§.ordina()"
@ externa
functio ordinaExemplar()

@ verte ts (ego) -> "[...§].sort()"
@ verte py (ego) -> "sorted(§)"
@ verte zig (ego, alloc) -> "§.ordinata(§)"
@ externa
functio ordinataExemplar()
