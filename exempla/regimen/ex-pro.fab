// =============================================================================
// REGIMEN - For-Each Loop (ex...pro)
// =============================================================================
//
// The ex...pro construct iterates over collections.
// Source-first syntax: "from items, for each item"
//
// GRAMMAR:
// ex <collection> pro <item> { <body> }
// ex <start>..<end> pro <item> { <body> }         // range (exclusive)
// ex <start> ante <end> pro <item> { <body> }     // range (explicit exclusive)
// ex <start> usque <end> pro <item> { <body> }    // range (inclusive)
// ex <start>..<end> per <step> pro <item> { }     // range with step
//
// ETYMOLOGY:
// ex: "out of, from" (source preposition)
// pro: "for each" (distributive preposition)
// per: "through, by" (step increment)
//
// WHY SOURCE-FIRST:
// "ex items pro item" reads naturally in Latin word order
// Makes the data source prominent (what you're iterating)
// More explicit than "for item in items"

// =============================================================================
// ARRAY ITERATION
// =============================================================================

fixum numbers = [1, 2, 3, 4, 5]

ex numbers pro n {
    scribe n
}

// String array
fixum names = ["Marcus", "Julia", "Claudia"]

ex names pro name {
    scribe scriptum("Salve, {}", name)
}

// =============================================================================
// RANGE EXPRESSIONS
// =============================================================================

// Basic range (0 to 4, end is exclusive)
ex 0..5 pro i {
    scribe i  // 0, 1, 2, 3, 4
}

// Inclusive range with usque ("up to")
ex 0 usque 5 pro i {
    scribe i  // 0, 1, 2, 3, 4, 5
}

// Explicit exclusive with ante ("before")
ex 0 ante 5 pro i {
    scribe i  // 0, 1, 2, 3, 4 (same as ..)
}

// Range with step
ex 0..10 per 2 pro i {
    scribe i  // 0, 2, 4, 6, 8
}

// Inclusive range with step
ex 0 usque 10 per 2 pro i {
    scribe i  // 0, 2, 4, 6, 8, 10
}

// Countdown with step
ex 10..0 per -1 pro i {
    scribe i
}

// =============================================================================
// OPERATIONS ON ITEMS
// =============================================================================

fixum values = [10, 20, 30, 40, 50]

// Double each value
ex values pro v {
    fixum doubled = v * 2
    scribe doubled
}

// Filter and process (when conditionals work)
fixum scores = [85, 92, 78, 95, 88]

ex scores pro score {
    si score >= 90 {
        scribe score, "is an A"
    }
}

// =============================================================================
// NESTED LOOPS
// =============================================================================

fixum rows = [1, 2, 3]
fixum cols = ["A", "B", "C"]

ex rows pro row {
    ex cols pro col {
        scribe row, col
    }
}

// Multiplication table
ex 1..5 pro i {
    ex 1..5 pro j {
        scribe i, "Ã—", j, "=", i * j
    }
}

// =============================================================================
// EX-PRO IN FUNCTIONS
// =============================================================================

functio sumArray(numerus[] nums) -> numerus {
    varia numerus total = 0

    ex nums pro n {
        total = total + n
    }

    redde total
}

scribe sumArray([1, 2, 3, 4, 5])
scribe sumArray([10, 20, 30])

// Find maximum value
functio maxValue(numerus[] nums) -> numerus {
    varia numerus max = nums[0]

    ex nums pro n {
        si n > max {
            max = n
        }
    }

    redde max
}

scribe maxValue([5, 12, 8, 20, 3])

// =============================================================================
// ONE-LINER EX-PRO
// =============================================================================

// Simple iteration with ergo
fixum items = [1, 2, 3]
ex items pro item {
    scribe item
}

// =============================================================================
// COMPARISON WITH DUM
// =============================================================================

// Use ex-pro for iterating known collections:
fixum data = [10, 20, 30]
ex data pro value {
    scribe value
}

// Use dum for condition-based loops:
// varia i = 0
// dum i < data.length {
//     scribe data[i]
//     i = i + 1
// }

// ex-pro is clearer and less error-prone for collection iteration
