// =============================================================================
// REGIMEN - Clausura (Closures/Lambdas)
// =============================================================================
//
// Clausura: Latin for "closure" (from claudere, to close)
//
// GRAMMAR:
// pro <params>: <expr>                  // expression lambda (shorthand)
// pro <params> redde <expr>             // expression lambda (explicit)
// pro <params> { <body> }               // block lambda
// pro { <body> }                        // zero-param lambda
// (<params>) => <expr>                  // arrow function (JS-style)
//
// ETYMOLOGY:
// pro: "for" - same keyword as iteration (ex items pro x { })
// redde: "return" (give back)
// :    "is defined as" - shorthand, mirrors object literal syntax { x: 42 }

// =============================================================================
// EXPRESSION LAMBDAS (pro x: expr)
// =============================================================================

// Single parameter - expression lambda with : shorthand
fixum double = pro x: x * 2
scribe double(5)  // 10

// Multiple parameters
fixum add = pro a, b: a + b
scribe add(3, 4)  // 7

// Zero parameters - expression form
fixum getAnswer = pro: 42
scribe getAnswer()  // 42

// Explicit redde form (equivalent, more verbose)
fixum triple = pro x redde x * 3
scribe triple(4)  // 12

// =============================================================================
// BLOCK LAMBDAS (pro x { })
// =============================================================================

// Block lambda with single parameter
fixum classify = pro n {
    si n < 0 {
        redde "negative"
    }
    si n == 0 {
        redde "zero"
    }
    redde "positive"
}

scribe classify(-5)  // "negative"
scribe classify(0)   // "zero"
scribe classify(10)  // "positive"

// Block lambda with multiple parameters
fixum compare = pro a, b {
    si a > b { redde 1 }
    si a < b { redde -1 }
    redde 0
}

scribe compare(5, 3)  // 1
scribe compare(2, 7)  // -1
scribe compare(4, 4)  // 0

// Zero-param block lambda
fixum greet = pro {
    scribe "Salve!"
}

greet()

// =============================================================================
// ARROW FUNCTIONS (JS-style)
// =============================================================================

// Single expression
fixum square = (x) => x * x
scribe square(5)  // 25

// Multiple parameters
fixum multiply = (a, b) => a * b
scribe multiply(6, 7)  // 42

// Block body
fixum abs = (n) => {
    si n < 0 {
        redde -n
    }
    redde n
}

scribe abs(-10)  // 10

// =============================================================================
// CURRYING
// =============================================================================

// Curried add function - : shorthand shines here
fixum curriedAdd = pro x: pro y: x + y
fixum addFive = curriedAdd(5)
scribe addFive(3)  // 8

// Curried multiplier
fixum multiplier = pro factor: pro x: x * factor
fixum timesTwo = multiplier(2)
fixum timesThree = multiplier(3)

scribe timesTwo(7)    // 14
scribe timesThree(7)  // 21

// =============================================================================
// CLOSURES (capturing outer scope)
// =============================================================================

// Closures capture variables from enclosing scope
// Note: Returning lambdas requires function type annotations (future feature)

// Immediate closure - captures outer variable
varia outerCount = 0
fixum incrementOuter = pro {
    outerCount = outerCount + 1
    scribe outerCount
}

incrementOuter()  // 1
incrementOuter()  // 2
incrementOuter()  // 3

// Closure capturing function parameter
functio createGreeter(textus prefix) {
    // The lambda captures 'prefix' from the enclosing scope
    fixum greet = pro name: prefix + ", " + name + "!"
    scribe greet("Marcus")
    scribe greet("Julia")
}

createGreeter("Salve")  // "Salve, Marcus!" "Salve, Julia!"
createGreeter("Ave")    // "Ave, Marcus!" "Ave, Julia!"

// =============================================================================
// LAMBDAS AS CALLBACKS
// =============================================================================

// Higher-order function taking a callback
functio applyTwice(f, x) {
    redde f(f(x))
}

scribe applyTwice(pro x: x + 1, 5)   // 7
scribe applyTwice(pro x: x * 2, 3)   // 12

// Conditional callback
functio applyIf(condition, f, x) {
    si condition {
        redde f(x)
    }
    redde x
}

scribe applyIf(verum, pro x: x * 10, 5)   // 50
scribe applyIf(falsum, pro x: x * 10, 5)  // 5

// =============================================================================
// SYNTAX COMPARISON
// =============================================================================

// All three syntaxes compile to JavaScript arrow functions:

fixum fn1 = pro x: x * 2           // Colon shorthand (preferred)
fixum fn2 = pro x redde x * 2      // Explicit redde (teaching)
fixum fn3 = (x) => x * 2           // Arrow syntax (JS-familiar)

// When to use which:
// - pro x: expr       Preferred for expression lambdas
// - pro x redde expr  For emphasis or teaching
// - pro x { }         Block lambdas with multiple statements
// - pro { }           Zero-param callbacks
// - (x) => expr       JS-familiar alternative
