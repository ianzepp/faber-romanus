// =============================================================================
// REGIMEN - For-In Loop (de...pro)
// =============================================================================
//
// The de...pro construct iterates over object keys.
// Extracts keys from an object for iteration.
//
// GRAMMAR:
// de <object> pro <key> { <body> }
// de <object> pro <key> ergo <statement>  // one-liner
//
// ETYMOLOGY:
// de: "from, concerning" (extraction preposition)
// pro: "for each" (distributive preposition)
//
// WHY "de":
// "de" means "from" or "concerning" - we're extracting keys FROM the object
// Contrasts with "in" (into) which is for mutation blocks
// Read-only semantics: we're reading keys, not modifying the object
//
// COMPARISON:
// ex items pro item { }  -- for-of: iterate VALUES
// de obj pro key { }     -- for-in: iterate KEYS

// =============================================================================
// BASIC KEY ITERATION
// =============================================================================

fixum persona = { nomen: "Marcus", aetas: 30, urbs: "Roma" }

// Iterate over all keys
de persona pro clavis {
    scribe clavis
}

// Access values using the key
de persona pro clavis {
    scribe scriptum("{}: {}", clavis, persona[clavis])
}

// =============================================================================
// OBJECT INSPECTION
// =============================================================================

fixum config = {
    host: "localhost",
    port: 8080,
    secure: verum,
    timeout: 5000
}

// List all configuration keys
scribe "Configuration options:"
de config pro key {
    scribe scriptum("  - {}", key)
}

// =============================================================================
// DE-PRO IN FUNCTIONS
// =============================================================================

functio countKeys(objectum obj) -> numerus {
    varia numerus count = 0
    de obj pro k {
        count = count + 1
    }
    redde count
}

scribe countKeys({ a: 1, b: 2, c: 3 })

// Clone object (demonstration - direct property access)
fixum original = { x: 10, y: 20 }
fixum copy = { x: original.x, y: original.y }
scribe copy.x
scribe copy.y

// =============================================================================
// ONE-LINER FORM
// =============================================================================

fixum data = { alpha: 1, beta: 2, gamma: 3 }

// Print all keys with ergo
de data pro k ergo scribe k

// =============================================================================
// DE VS EX
// =============================================================================

// Use `ex` for VALUES (arrays, iterables)
fixum numbers = [1, 2, 3, 4, 5]
ex numbers pro n {
    scribe n  // 1, 2, 3, 4, 5
}

// Use `de` for KEYS (objects)
fixum obj = { a: 1, b: 2, c: 3 }
de obj pro key {
    scribe key  // "a", "b", "c"
}

// To get values from an object, combine de with subscript access
de obj pro key {
    scribe obj[key]  // 1, 2, 3
}

// =============================================================================
// NESTED OBJECTS
// =============================================================================

fixum nested = {
    server: { host: "localhost", port: 3000 },
    database: { url: "postgres://...", timeout: 5000 }
}

// Iterate top-level keys
de nested pro section {
    scribe scriptum("Section: {}", section)
    de nested[section] pro key {
        scribe scriptum("  {}: {}", key, nested[section][key])
    }
}
