// =============================================================================
// REGIMEN - Assertions (adfirma)
// =============================================================================
//
// The adfirma statement asserts that a condition must be true.
// If false, throws an error. Use for invariants and debugging.
//
// GRAMMAR:
// adfirma <condition>
// adfirma <condition>, <message>
//
// ETYMOLOGY:
// adfirma: "affirm! assert!" (imperative of adfirmare - to strengthen, assert)
//
// WHY "adfirma":
// Expresses affirmation/assertion more directly than "assert"
// Imperative form fits statement-as-command pattern

// =============================================================================
// BASIC ASSERTIONS
// =============================================================================

fixum x = 10

// Assert without message
adfirma x > 0

// Assert with message
adfirma x < 100, "x must be less than 100"

scribe "Assertions passed"

// =============================================================================
// ASSERTIONS IN FUNCTIONS
// =============================================================================

functio divide(numerus a, numerus b) -> numerus {
    adfirma b != 0, "divisor cannot be zero"
    redde a / b
}

scribe divide(10, 2)

// Assert preconditions
functio sqrt(numerus n) -> numerus {
    adfirma n >= 0, "cannot take square root of negative number"
    redde n
}

scribe sqrt(16)

// =============================================================================
// MULTIPLE ASSERTIONS
// =============================================================================

functio processRange(numerus start, numerus end, numerus step) -> numerus {
    adfirma start >= 0, "start must be non-negative"
    adfirma end > start, "end must be greater than start"
    adfirma step > 0, "step must be positive"

    fixum count = end - start / step
    redde count
}

scribe processRange(0, 100, 10)

// =============================================================================
// INVARIANT CHECKS
// =============================================================================

functio calculatePercentage(numerus part, numerus whole) -> numerus {
    adfirma whole > 0, "whole must be positive"
    adfirma part >= 0, "part must be non-negative"
    adfirma part <= whole, "part cannot exceed whole"

    fixum percentage = part / whole * 100

    adfirma percentage >= 0, "percentage invariant failed"
    adfirma percentage <= 100, "percentage invariant failed"

    redde percentage
}

scribe calculatePercentage(25, 100)
scribe calculatePercentage(50, 200)

// =============================================================================
// POST-CONDITION ASSERTIONS
// =============================================================================

functio clamp(numerus value, numerus min, numerus max) -> numerus {
    adfirma min <= max, "min must be <= max"

    varia numerus result = value

    si result < min {
        result = min
    }

    si result > max {
        result = max
    }

    adfirma result >= min, "postcondition: result >= min"
    adfirma result <= max, "postcondition: result <= max"

    redde result
}

// Post-condition: result must be in range
scribe clamp(5, 0, 10)
scribe clamp(-5, 0, 10)
scribe clamp(15, 0, 10)

// =============================================================================
// ARRAY ASSERTIONS
// =============================================================================

functio getFirst(lista<numerus> items) -> numerus {
    adfirma nonnulla items, "array cannot be empty"
    redde items[0]
}

scribe getFirst([1, 2, 3])

// =============================================================================
// WHEN TO USE ADFIRMA
// =============================================================================

// GOOD: Check invariants and preconditions during development
functio factorial(numerus n) -> numerus {
    adfirma n >= 0, "factorial only defined for non-negative integers"

    si n == 0 || n == 1 {
        redde 1
    }

    varia numerus result = 1
    varia numerus i = 2

    dum i <= n {
        result = result * i
        i = i + 1
    }

    adfirma result > 0, "factorial result must be positive"
    redde result
}

scribe factorial(5)
scribe factorial(0)

// BAD: Don't use for expected runtime conditions (use si + error handling)
// Instead of:
// adfirma userInput != "", "input required"
// Use:
// si userInput == "" { iace "input required" }

// adfirma is for programmer errors (bugs)
// Error handling is for runtime errors (bad input, network failures, etc.)

// =============================================================================
// ASSERTION VS GUARD
// =============================================================================

// custodi: for validation with fallback/recovery
functio processAge(numerus age) -> textus {
    custodi {
        si age < 0 {
            redde "Invalid age"
        }
    }

    redde "Age: " + age
}

// adfirma: for invariants that should never fail
functio processValidAge(numerus age) -> textus {
    adfirma age >= 0, "age must be non-negative"
    redde "Age: " + age
}

scribe processAge(-5)
scribe processValidAge(25)
