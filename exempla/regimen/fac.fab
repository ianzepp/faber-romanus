// =============================================================================
// REGIMEN - Blocks (fac) and Lambdas (pro)
// =============================================================================
//
// Two keywords serve different purposes:
// - fac { } creates block scope (for error handling, grouping)
// - pro x { } creates lambdas/closures (for callbacks, higher-order functions)
//
// GRAMMAR:
// fac { <body> }                          // block scope
// fac { <body> } cape <id> { <handler> }  // block with error handling
// pro <params> fit <expr>                 // expression lambda
// pro <params> { <body> }                 // block lambda
// pro { <body> }                          // zero-param lambda
//
// ETYMOLOGY:
// fac: imperative of "facere" (to do/make) - "do!"
// pro: "for" - same keyword as iteration (ex items pro x { })
// fit: "becomes" (passive of fieri)
//
// WHY "pro" for lambdas:
// Aligns with iteration: "ex items pro x { }" and "pro x { }" both use pro
// Reads naturally: "for x, becomes x times 2" or "for x, do { ... }"

// =============================================================================
// STUBS for examples (would be defined elsewhere in real code)
// =============================================================================
functio riskyOperation() {}
functio handleClick(e) {}
functio getData(id) { redde id }
functio process(data) { redde data }
functio display(result) {}
functio logError(e) {}
functio openDatabase() { }
functio doWork(conn) {}
functio fetchData() { }
varia button = nihil
varia users = []
varia items = []

// =============================================================================
// PART 1: BLOCK SCOPE (fac)
// =============================================================================

// -----------------------------------------------------------------------------
// Block Scope - Explicit scoping without conditions
// -----------------------------------------------------------------------------

// Simple block scope
fac {
    varia temp = "scoped"
    scribe temp
}
// temp is not visible here

// Block scope for grouping related operations
fac {
    varia a = 10
    varia b = 20
    varia sum = a + b
    scribe "Sum:", sum
}

// Block with error handling (like try-catch but cleaner)
fac {
    riskyOperation()
} cape error {
    scribe "Caught:", error
}

// Scoped setup/teardown
fac {
    varia connection = openDatabase()
    doWork(connection)
    connection.close()
}

// =============================================================================
// PART 2: EXPRESSION LAMBDAS (pro x fit expr)
// =============================================================================

// Single parameter - expression lambda
fixum double = pro x fit x * 2
scribe double(5)  // 10

// Multiple parameters
fixum add = pro a, b fit a + b
scribe add(3, 4)  // 7

// Zero parameters - expression form
fixum getAnswer = pro fit 42
scribe getAnswer()  // 42

// =============================================================================
// PART 3: BLOCK LAMBDAS (pro x { })
// =============================================================================

// Block lambda with single parameter
fixum processUser = pro user {
    si user.aetas < 18 {
        redde falsum
    }
    redde user.activus
}

// Block lambda with multiple parameters
fixum compare = pro a, b {
    si a > b { redde 1 }
    si a < b { redde -1 }
    redde 0
}

// Zero-param block lambda
fixum greet = pro {
    scribe "Hello!"
}

// =============================================================================
// PART 4: LAMBDAS WITH COLLECTIONS
// =============================================================================

fixum numbers = [1, 2, 3, 4, 5]

// Expression lambdas - clean for simple transforms
fixum evens = numbers.filtrata(pro n fit n % 2 == 0)
fixum doubled = numbers.mappata(pro n fit n * 2)
fixum sum = numbers.reducta(pro acc, n fit acc + n, 0)

// Block lambdas - for complex logic
fixum processed = numbers.filtrata(pro n {
    si n < 0 { redde falsum }
    si n > 100 { redde falsum }
    redde n % 2 == 0
})

// -----------------------------------------------------------------------------
// Nested Lambdas (Currying)
// -----------------------------------------------------------------------------

// Curried add function
fixum curriedAdd = pro x fit pro y fit x + y
fixum addFive = curriedAdd(5)
scribe addFive(3)  // 8

// =============================================================================
// PART 5: EVENT HANDLERS AND CALLBACKS
// =============================================================================

// Zero-param callbacks - block form is cleaner
button.addEventListener("click", pro {
    scribe "Button clicked!"
})

// With event parameter
button.addEventListener("click", pro e {
    handleClick(e)
})

// Promise chains - expression form for one-liners
fetchData()
    .then(pro data fit process(data))
    .then(pro result fit display(result))
    .catch(pro error fit logError(error))

// Promise with block for complex handling
fetchData()
    .then(pro data {
        si data.error {
            iace data.error
        }
        redde process(data)
    })
    .cape(pro error {
        logError(error)
        redde nihil
    })

// =============================================================================
// PART 6: COMPARISON WITH ARROW FUNCTIONS
// =============================================================================

// Both syntaxes are valid and compile to the same JavaScript:

// Arrow function syntax (JS-familiar)
fixum arrowDouble = (x) => x * 2

// Pro lambda syntax (Latin-aligned)
fixum proDouble = pro x fit x * 2

// Arrow with block body
fixum arrowComplex = (x) => {
    si x < 0 { redde -x }
    redde x
}

// Pro with block body
fixum proComplex = pro x {
    si x < 0 { redde -x }
    redde x
}

// When to use which:
// - pro x fit expr: Short expression lambdas, Latin style
// - pro x { }: Block lambdas with multiple statements
// - pro { }: Zero-param callbacks
// - (x) => expr: JS-familiar alternative
// - fac { } cape: Block scope with error handling

// =============================================================================
// PART 7: IDIOMATIC USAGE
// =============================================================================

// Filtering - expression lambda reads well
users.filtrata(pro u fit u.active)

// Mapping - expression lambda reads well
items.mappata(pro i fit i.price * 1.1)

// Complex filtering - block lambda for clarity
users.filtrata(pro user {
    si user.aetas < 18 { redde falsum }
    si non user.verified { redde falsum }
    redde user.active
})

// Event handlers - zero-param block lambda
button.onClick(pro { scribe "clicked" })
conn.onClose(pro { cleanup() })
conn.onError(pro err { logError(err) })

// Higher-order functions returning lambdas
fixum multiplier = pro factor fit pro x fit x * factor
fixum double = multiplier(2)
fixum triple = multiplier(3)

