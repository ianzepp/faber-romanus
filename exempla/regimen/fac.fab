// =============================================================================
// REGIMEN - Do Block and Lambda (fac)
// =============================================================================
//
// The fac keyword serves two purposes:
// 1. Block scope: fac { } creates an explicit scope boundary
// 2. Lambda: fac x fit expr creates anonymous functions
//
// GRAMMAR:
// fac { <body> }                          // block scope
// fac { <body> } cape <id> { <handler> }  // block with error handling
// fac <params> fit <expr>                 // sync lambda
// fac <params> fiet <expr>                // async lambda
//
// ETYMOLOGY:
// fac: imperative of "facere" (to do/make) - "do!"
// fit: "becomes" (passive of fieri)
// fiet: "will become" (future of fieri)
//
// WHY "fac fit":
// Reads naturally: "do x, becoming x times 2"
// Latin verb forms encode sync/async without symbols

// =============================================================================
// STUBS for examples (would be defined elsewhere in real code)
// =============================================================================
functio riskyOperation() {}
functio handleClick(e) {}
functio getData(id) { redde id }
functio process(data) { redde data }
functio display(result) {}
functio logError(e) {}
functio openDatabase() { }
functio doWork(conn) {}
functio fetchData() { }
varia button = nihil
varia users = []
varia items = []

// =============================================================================
// PART 1: WHAT WORKS
// =============================================================================

// -----------------------------------------------------------------------------
// Block Scope - Explicit scoping without conditions
// -----------------------------------------------------------------------------

// Simple block scope
fac {
    varia temp = "scoped"
    scribe temp
}
// temp is not visible here

// Block scope for grouping related operations
fac {
    varia a = 10
    varia b = 20
    varia sum = a + b
    scribe "Sum:", sum
}

// Block with error handling (like try-catch but cleaner)
fac {
    riskyOperation()
} cape error {
    scribe "Caught:", error
}

// -----------------------------------------------------------------------------
// Lambda Expressions - Anonymous functions
// -----------------------------------------------------------------------------

// Single parameter
fixum double = fac x fit x * 2
scribe double(5)  // 10

// Multiple parameters
fixum add = fac a, b fit a + b
scribe add(3, 4)  // 7

// Zero parameters
fixum getAnswer = fac fit 42
scribe getAnswer()  // 42

// Async lambda with fiet
fixum fetchUser = fac id fiet getData(id)

// -----------------------------------------------------------------------------
// Lambdas with Collections
// -----------------------------------------------------------------------------

fixum numbers = [1, 2, 3, 4, 5]

// Filter with fac lambda
fixum evens = numbers.filtrata(fac n fit n % 2 == 0)

// Map with fac lambda
fixum doubled = numbers.mappata(fac n fit n * 2)

// Reduce with fac lambda
fixum sum = numbers.reducta(fac acc, n fit acc + n, 0)

// Sort with fac lambda
fixum sorted = numbers.ordinata(fac a, b fit b - a)  // descending

// -----------------------------------------------------------------------------
// Nested Lambdas (Currying)
// -----------------------------------------------------------------------------

// Curried add function
fixum curriedAdd = fac x fit fac y fit x + y
fixum addFive = curriedAdd(5)
scribe addFive(3)  // 8

// Triple nesting (please don't)
fixum triple = fac x fit fac y fit fac z fit x + y + z

// =============================================================================
// PART 2: WHAT WORKS BUT PROBABLY SHOULDN'T
// =============================================================================

// -----------------------------------------------------------------------------
// Deeply nested lambdas that parse but hurt to read
// -----------------------------------------------------------------------------

// This parses fine. Reading it is another matter.
fixum chaos = fac a fit fac b fit fac c fit fac d fit a + b + c + d
// "do a becoming do b becoming do c becoming do d becoming a plus b plus c plus d"

// Lambda returning lambda returning lambda
fixum inception = fac x fit fac fit fac y fit x + y
// inception(10)()(5) = 15... but why?

// -----------------------------------------------------------------------------
// Ternary inside lambda - CURRENTLY BROKEN
// -----------------------------------------------------------------------------

// This SHOULD work but doesn't parse correctly yet:
// fixum sign = fac x fit sic x > 0 1 secum -1
// Error: Unexpected token 'sic'
//
// The lambda body parser needs precedence work to handle ternary.
// Same issue affects arrow functions:
// fixum sign = (x) => sic x > 0 1 secum -1
//
// Workaround: use full function declaration
functio sign(x) -> numerus {
    si x > 0 { redde 1 }
    redde -1
}

// -----------------------------------------------------------------------------
// Lambda as immediate invocation - CURRENTLY BROKEN
// -----------------------------------------------------------------------------

// IIFE doesn't parse correctly:
// fixum result = (fac x fit x * x)(5)  // should be 25
// Parses as: fac x fit (x * x)(5) - lambda body eats the invocation
//
// Workaround: use arrow function for IIFE
fixum result = ((x) => x * x)(5)  // 25

// =============================================================================
// PART 3: WHAT UNFORTUNATELY DOESN'T WORK
// =============================================================================

// -----------------------------------------------------------------------------
// Keywords as identifiers
// -----------------------------------------------------------------------------

// This fails - 'fac' is a keyword, not a valid parameter name
// fac fac fit fac + fac
// Error: Expected identifier, got 'fac'

// Same with 'fit'
// fac fit fit fit
// Error: Multiple parse errors

// 'fit' after expression doesn't chain
// fac x fit x fit y fit y
// Parses as: fac x fit (x fit y fit y) - and "x fit" isn't valid

// -----------------------------------------------------------------------------
// Block body for lambdas
// -----------------------------------------------------------------------------

// No block body syntax - only expressions
// fac x fit { redde x * 2 }
// The { } would be parsed as object literal, not block

// For complex logic, use full function declaration:
// functio complex(x) -> numerus {
//     si x < 0 { redde -x }
//     redde x
// }

// Or use arrow function with block:
// (x) => { redde x * 2 }

// -----------------------------------------------------------------------------
// Type annotations on fac parameters
// -----------------------------------------------------------------------------

// No type syntax for fac parameters
// fac numerus x fit x * 2    // doesn't work
// fac x: numerus fit x * 2   // doesn't work

// For typed lambdas, use arrow function:
// (numerus x) => x * 2

// -----------------------------------------------------------------------------
// Implicit return in blocks
// -----------------------------------------------------------------------------

// fac blocks don't return values
// fixum x = fac { 42 }  // doesn't assign 42

// Use lambda for expression results:
// fixum x = (fac fit 42)()  // works but ugly

// =============================================================================
// PART 4: COMPARISON WITH ARROW FUNCTIONS
// =============================================================================

// Both syntaxes are valid and compile to the same JavaScript:

// Arrow function syntax
fixum arrowDouble = (x) => x * 2

// Fac lambda syntax
fixum facDouble = fac x fit x * 2

// Arrow with block body
fixum arrowComplex = (x) => {
    si x < 0 { redde -x }
    redde x
}

// Fac doesn't support block body - use arrow for complex logic

// When to use which:
// - fac x fit expr: Short, readable lambdas in Latin style
// - (x) => expr: When you need types or block bodies
// - fac { } cape: Scoped error handling
// - (x) => { }: Complex multi-statement functions

// =============================================================================
// PART 5: IDIOMATIC USAGE
// =============================================================================

// Filtering - fac reads well
users.filtrata(fac u fit u.active)

// Mapping - fac reads well
items.mappata(fac i fit i.price * 1.1)

// Sorting by property
items.ordinata(fac a, b fit a.date - b.date)

// Event handlers
button.addEventListener("click", fac e fit handleClick(e))

// Promise chains
fetchData()
    .then(fac data fit process(data))
    .then(fac result fit display(result))
    .catch(fac error fit logError(error))  // .catch not .cape (JS method)

// Scoped setup/teardown
fac {
    varia connection = openDatabase()
    doWork(connection)
    connection.close()
}
