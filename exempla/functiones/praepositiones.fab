// =============================================================================
// PRAEPOSITIONES - Ownership Prepositions for Systems Targets
// =============================================================================
//
// Latin prepositions annotate ownership semantics for systems targets
// (Rust, Zig). These are optional and have no effect on TypeScript/Python.
//
// PREPOSITIONS:
// de = borrowed, read-only (&T in Rust, []const u8 in Zig)
// in = mutable borrow (&mut T in Rust, *T in Zig)
// (none) = owned value (T in Rust, allocator-managed in Zig)
//
// GRAMMAR:
// parameter: (de | in)? <type> <name>
// return:    fit (de | in)? <type>
//            -> (de | in)? <type>
//
// WHY PREPOSITIONS:
// - Natural Latin syntax ("de textus" = "concerning the string")
// - Maps directly to Rust/Zig borrow semantics
// - Accessible to non-systems programmers

// =============================================================================
// BORROWED PARAMETERS (de)
// =============================================================================

// "de" indicates a borrowed, read-only parameter
// The caller retains ownership; the function only reads the value.
// Rust: &str, Zig: []const u8

functio greet(de textus name) -> textus {
    redde "Salve, " + name + "!"
}

scribe greet("Marcus")  // "Salve, Marcus!"

// Multiple borrowed parameters
functio compara(de textus a, de textus b) -> bivalens {
    redde a == b
}

scribe compara("alpha", "alpha")  // verum
scribe compara("alpha", "beta")   // falsum

// Borrowed list - reads elements without consuming the list
functio summa(de lista<numerus> numeri) -> numerus {
    varia total = 0
    ex numeri pro n {
        total = total + n
    }
    redde total
}

scribe summa([1, 2, 3, 4, 5])  // 15

// =============================================================================
// MUTABLE PARAMETERS (in)
// =============================================================================

// "in" indicates a mutable borrow
// The function can modify the value in place.
// Rust: &mut T, Zig: *T

// Mutates the counter in place
functio incrementa(in numerus counter) {
    counter = counter + 1
}

// Conceptual: list mutation would use stdlib methods
// functio adde(in lista<numerus> items, numerus value) {
//     items.adde(value)
// }

// =============================================================================
// BORROWED RETURN TYPES
// =============================================================================

// Return types can use "de" to indicate borrowed returns.
// The returned value borrows from one of the input parameters.
// Only valid for sync functions (fit, not fiet).

// Return borrowed reference tied to input lifetime
functio first(de lista<textus> items) fit de textus {
    redde items[0]
}

scribe first(["alpha", "beta", "gamma"])  // "alpha"

// Using arrow syntax for borrowed return
functio last(de lista<numerus> items) -> de numerus {
    redde items[items.length - 1]
}

// Returning the longer of two strings (borrowed)
functio longer(de textus a, de textus b) fit de textus {
    // Would compare lengths; simplified here
    redde a
}

// =============================================================================
// MIXED OWNERSHIP
// =============================================================================

// Combining borrowed and owned parameters
// "source" is borrowed (de), "suffix" is owned (consumed)
functio appendCopy(de textus source, textus suffix) -> textus {
    redde source + suffix
}

scribe appendCopy("Salve ", "Mundus")  // "Salve Mundus"

// =============================================================================
// OWNERSHIP IN GENUS METHODS
// =============================================================================

genus Persona {
    textus nomen
    numerus aetas

    // Method with borrowed self (implicit de ego)
    functio describe() -> textus {
        redde ego.nomen + " (" + ego.aetas + ")"
    }

    // Method that borrows a string parameter
    functio saluta(de textus otherNomen) -> textus {
        redde ego.nomen + " salutat " + otherNomen
    }
}

fixum marcus = novum Persona { nomen: "Marcus", aetas: 30 }
fixum julia = novum Persona { nomen: "Julia", aetas: 25 }

scribe marcus.describe()
scribe marcus.saluta(julia.nomen)

// =============================================================================
// TARGET BEHAVIOR
// =============================================================================

// TypeScript/Python: Prepositions are parsed but have no effect.
// All values are passed by reference (JS) or copy-on-write.

// Rust: Generates proper borrow annotations (&, &mut, owned)
// Zig: Generates pointer types and const slices

// See consilia/codegen/rust.md and consilia/codegen/zig.md for details.
