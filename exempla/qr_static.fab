// QR Static Stream - Steganographic QR codes hidden in XOR'd noise frames
//
// Each frame is random static. XOR all N frames together to reveal a QR code.
// This is a port of the Python qr_static.py to Faber Romanus.

ex norma importa series, seriesAb, fortuitus, pavimentum

// Generate a single frame of binary noise (0 or 1 per cell)
functio generateNoiseFrame(numerus rows, numerus cols) -> numerus[][] {
    fixum frame = []

    ex series(rows) pro i {
        fixum row = []
        ex series(cols) pro j {
            fixum bit = pavimentum(fortuitus() * 2)
            row.push(bit)
        }

        frame.push(row)
    }

    redde frame
}

// Random 0 or 1
// XOR two matrices together (element-wise)
// Since we only have 0 and 1, XOR is equivalent to (a + b) % 2
functio xorMatrices(a, b) -> numerus[][] {
    fixum result = []
    fixum rows = a.length

    ex series(rows) pro i {
        fixum row = []
        fixum cols = a[i].length

        ex series(cols) pro j {
            fixum xored = a[i][j] + b[i][j] % 2
            row.push(xored)
        }

        result.push(row)
    }

    redde result
}

// Encode a QR matrix into N frames of noise
// XOR of all returned frames equals the original QR matrix
functio encode(qrMatrix, numerus nFrames) -> numerus[][][] {
    si nFrames < 2 {
        iace "Need at least 2 frames"
    }

    fixum rows = qrMatrix.length
    fixum cols = qrMatrix[0].length

    fixum frames = []
    ex series(nFrames - 1) pro i {
        frames.push(generateNoiseFrame(rows, cols))
    }

    varia accumulated = qrMatrix

    ex frames pro frame {
        accumulated = xorMatrices(accumulated, frame)
    }

    frames.push(accumulated)
    redde frames
}

// Generate N-1 random frames
// Compute final frame: QR XOR all previous frames
// Decode frames by XORing them all together
functio decode(frames) -> numerus[][] {
    si frames.length == 0 {
        iace "No frames to decode"
    }

    varia result = frames[0]

    ex seriesAb(1, frames.length, 1) pro i {
        result = xorMatrices(result, frames[i])
    }

    redde result
}

// Helper to print a matrix
functio printMatrix(m) {
    ex m pro row {
        varia line = ""
        ex row pro cell {
            si cell == 1 {
                line = line + "#"
            }
            aliter {
                line = line + "."
            }
        }

        scribe line
    }
}

// Demo: encode and decode a simple pattern
functio demo() {
    fixum testPattern = [[1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1]]

    scribe "Original pattern:"
    printMatrix(testPattern)

    fixum frames = encode(testPattern, 4)
    scribe "Encoded into " + frames.length + " frames"

    ex series(frames.length) pro i {
        scribe "Frame " + i + ":"
        printMatrix(frames[i])
    }

    fixum recovered = decode(frames)
    scribe "Recovered pattern:"
    printMatrix(recovered)
}

// Simple 4x4 test pattern (checkerboard)
// Encode into 4 frames
// Show each frame
// Decode
// Run the demo
demo()
