// =============================================================================
// TYPI - Primitive Types
// =============================================================================
//
// Faber's type system uses Latin names for primitive types.
// Type-first syntax: the type precedes the identifier.
//
// PRIMITIVE TYPES:
// textus    - string ("woven, texture")
// numerus   - integer ("count, quantity")
// fractus   - float ("broken, fractional")
// decimus   - decimal ("tenth, decimal") - arbitrary precision
// bivalens  - boolean ("two-valued")
// nihil     - null literal ("nothing")
// vacuum    - void type ("empty, vacant")
// octeti    - bytes ("octets") - raw binary data
//
// GRAMMAR:
// fixum <type> <name> = <value>
// functio name(<type> param) -> <type> { }
//
// WHY TYPE-FIRST:
// - Mirrors Latin's flexible word order
// - Makes type constraints prominent
// - Consistent with other declarations

// =============================================================================
// TEXTUS (String)
// =============================================================================

// String literals with type annotation
fixum textus greeting = "Salve, Mundus!"
fixum textus name = "Marcus Aurelius"
fixum textus empty = ""

scribe greeting
scribe name

// String in function parameters
functio welcome(textus userName) -> textus {
    redde scriptum("Welcome, {}!", userName)
}

scribe welcome("Julia")

// String concatenation
fixum textus first = "Hello"
fixum textus second = "World"
fixum textus combined = scriptum("{} {}", first, second)

scribe combined

// =============================================================================
// NUMERUS (Number)
// =============================================================================

// Numeric literals
fixum numerus age = 30
fixum numerus count = 100
fixum numerus pi = 3.14159
fixum numerus negative = -42

scribe age
scribe pi

// Numeric function
functio double(numerus n) -> numerus {
    redde n * 2
}

scribe double(21)
scribe double(100)

// Arithmetic
fixum numerus a = 10
fixum numerus b = 20
fixum numerus sum = a + b
fixum numerus product = a * b

scribe sum
scribe product

// =============================================================================
// FRACTUS (Float)
// =============================================================================

// Floating-point numbers for scientific calculations
// WHY: "fractus" means "broken, fractional" - the root of "fraction"
fixum fractus piPrecise = 3.14159265359
fixum fractus euler = 2.71828
fixum fractus golden = 1.618033988749

scribe piPrecise
scribe euler

// Fractus in function parameters
functio circleArea(fractus radius) -> fractus {
    redde 3.14159 * radius * radius
}

scribe circleArea(5.0)
scribe circleArea(2.5)

// =============================================================================
// DECIMUS (Decimal)
// =============================================================================

// Arbitrary-precision decimal for financial calculations
// WHY: "decimus" means "tenth, decimal" - exact decimal representation
// Unlike fractus, decimus avoids floating-point precision errors
fixum decimus price = 19.99
fixum decimus taxRate = 0.0825
fixum decimus balance = 1000.00

scribe price
scribe taxRate

// Decimus in function parameters
functio calculateTotal(decimus amount, decimus tax) -> decimus {
    redde amount + (amount * tax)
}

scribe calculateTotal(100.00, 0.08)

// =============================================================================
// OCTETI (Bytes)
// =============================================================================

// Raw binary data as byte arrays
// WHY: "octeti" means "octets, groups of eight" - the 8-bit byte
// Distinct from textus: octeti has no encoding, textus is UTF-8
typus Buffer = octeti

// Function accepting bytes
functio processData(octeti data) -> numerus {
    redde data.longitudo
}

// =============================================================================
// BIVALENS (Boolean)
// =============================================================================

// Boolean literals
fixum bivalens isActive = verum
fixum bivalens isDone = falsum
fixum bivalens hasPermission = verum

scribe isActive
scribe isDone

// Boolean function
functio negate(bivalens value) -> bivalens {
    si value {
        redde falsum
    }
    redde verum
}

scribe negate(verum)
scribe negate(falsum)

// Boolean expressions
fixum bivalens result = verum et falsum
scribe result

// =============================================================================
// VACUUM (Void)
// =============================================================================

// Functions without return type have implicit vacuum return
functio logMessage(textus msg) {
    scribe msg
}

logMessage("This function returns vacuum")

// Explicit vacuum return type
functio doSomething() -> vacuum {
    scribe "Doing something..."
}

doSomething()

// =============================================================================
// TYPE INFERENCE
// =============================================================================

// Type can be inferred from value
fixum inferredString = "Hello"
fixum inferredNumber = 42
fixum inferredBoolean = verum

scribe inferredString
scribe inferredNumber
scribe inferredBoolean

// Explicit types are clearer for documentation
fixum textus documentedString = "Explicit type"
fixum numerus documentedNumber = 100

// =============================================================================
// MIXED TYPES IN FUNCTIONS
// =============================================================================

functio describe(textus name, numerus age, bivalens active) -> textus {
    fixum status = active ? "active" : "inactive"
    redde scriptum("{} is {} years old ({})", name, age, status)
}

scribe describe("Marcus", 30, verum)

// Multiple return types (when union types are supported)
// For now, we remove the mismatched returns
functio getValue(bivalens returnString) -> textus {
    si returnString {
        redde "text value"
    }
    redde "42"
}

scribe getValue(verum)
scribe getValue(falsum)

// =============================================================================
// TYPE CONVERSION (when supported)
// =============================================================================

// String to number
fixum textus numStr = "123"
// fixum numerus num = parseInt(numStr)

// Number to string
fixum numerus value = 42
// fixum textus strValue = value + ""  // Type conversion not yet supported

scribe value

// =============================================================================
// CASE INSENSITIVITY
// =============================================================================

// Types are case-insensitive (Latin had no case distinction)
fixum textus lower = "lowercase type"
// fixum TEXTUS upper = "uppercase type"
// fixum Textus mixed = "mixed case type"

// Convention: use lowercase for consistency
fixum numerus standardStyle = 100
