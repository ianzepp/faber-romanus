// =============================================================================
// EVENTUS - Event Streams (ausculta)
// =============================================================================
//
// The ausculta expression creates an async iterator from an event stream.
// It complements emitte (push) with pull-based consumption.
//
// GRAMMAR:
// ausculta <event-name>
//
// ETYMOLOGY:
// ausculta: "listen!" (imperative of auscultare - to listen attentively)
// Root of medical term "auscultation" (listening to body sounds)
//
// WHY "ausculta":
// - Imperative verb form matches other keywords
// - Implies attentive, continuous listening (not one-shot)
// - Distinguished from "audi" (general hearing) by implying focused attention

// =============================================================================
// BASIC USAGE
// =============================================================================

// Create an event stream
fixum stream = ausculta "userAction"

// Consume with async iteration (fiet = async "becomes")
ex stream fiet event {
    scribe "Received:", event
}

// =============================================================================
// INLINE FORM
// =============================================================================

// No intermediate variable needed
ex ausculta "notification" fiet notif {
    scribe "Notification:", notif.message
}

// =============================================================================
// PUSH + PULL TOGETHER
// =============================================================================

// Producer: pushes events
functio producer() {
    varia i = 0
    dum i < 10 {
        emitte "tick", { count: i }
        i = i + 1
    }
}

// Consumer: pulls events as stream
futura functio consumer() {
    ex ausculta "tick" fiet tick {
        scribe "Tick:", tick.count
    }
}

// =============================================================================
// EVENT-DRIVEN LOOP
// =============================================================================

futura functio commandLoop() {
    scribe "Waiting for commands..."

    ex ausculta "command" fiet cmd {
        elige cmd.type {
            si "start" {
                scribe "Starting..."
                start()
            }
            si "stop" {
                scribe "Stopping..."
                rumpe
            }
            aliter {
                scribe "Unknown command:", cmd.type
            }
        }
    }

    scribe "Command loop ended"
}

// =============================================================================
// MULTIPLE STREAMS
// =============================================================================

futura functio monitor() {
    // Create multiple streams
    fixum errors = ausculta "error"
    fixum warnings = ausculta "warning"
    fixum info = ausculta "info"

    // Process each stream (in practice, would use select/merge)
    ex errors fiet err {
        mone "ERROR:", err.message
    }
}

// =============================================================================
// WITH GENUS
// =============================================================================

genus EventProcessor {
    fixum eventName: textus

    functio creo(eventName: textus) {
        ego.eventName = eventName
    }

    futura functio process() {
        fixum stream = ausculta ego.eventName

        ex stream fiet event {
            ego.handleEvent(event)
        }
    }

    functio handleEvent(event) {
        scribe "Processing:", event
    }
}

fixum processor = novum EventProcessor("dataUpdate")

// =============================================================================
// COMPARISON: EMITTE VS AUSCULTA
// =============================================================================

// emitte: PUSH - fire and forget
// - Statement (no return value)
// - Synchronous
// - Decoupled from listeners
emitte "userLogin", { userId: 42 }

// ausculta: PULL - subscribe and iterate
// - Expression (returns AsyncIterator)
// - Asynchronous (use with fiet)
// - Creates dedicated listener
fixum loginStream = ausculta "userLogin"

// =============================================================================
// NOTES ON ASYNC ITERATION
// =============================================================================

// The fiet keyword indicates async iteration:
// - fit  = sync iteration (for...of)
// - fiet = async iteration (for await...of)

// ausculta returns fluxus<T> (AsyncIterator), so use fiet:
ex ausculta "data" fiet item {
    scribe item
}

// Regular arrays use fit:
fixum items = [1, 2, 3]
ex items fit item {
    scribe item
}
