// =============================================================================
// GENUS - Methods
// =============================================================================
//
// genus declarations can include methods - functions that operate on instances.
// Methods access instance data via the ego keyword (self-reference).
//
// GRAMMAR:
// genus <Name> {
//   <type> <field>
//   functio <method>() { ... }
// }
//
// SELF-REFERENCE:
// ego - refers to the current instance (like `this` or `self`)
//
// ETYMOLOGY:
// ego: "I, self" (first-person pronoun)
//
// WHY "ego":
// Latin for "I" or "self" - the speaking instance
// More explicit than `this`

// =============================================================================
// BASIC METHODS
// =============================================================================

genus salutator {
    textus name: "Mundus"

    functio saluta() -> textus {
        redde "Salve, " + ego.name + "!"
    }
}

fixum greeter = novum salutator
scribe greeter.saluta()

fixum customGreeter = novum salutator {
    name: "Roma"
}

scribe customGreeter.saluta()

// =============================================================================
// METHODS WITH PARAMETERS
// =============================================================================

genus calculator {
    numerus value: 0

    functio adde(numerus n) -> numerus {
        redde ego.value + n
    }

    functio multiplica(numerus n) -> numerus {
        redde ego.value * n
    }
}

fixum calc = novum calculator {
    value: 10
}

scribe calc.adde(5)
scribe calc.multiplica(3)

// =============================================================================
// METHODS THAT MODIFY STATE
// =============================================================================

genus counter {
    numerus count: 0

    functio increment() {
        ego.count = ego.count + 1
    }

    functio decrement() {
        ego.count = ego.count - 1
    }

    functio reset() {
        ego.count = 0
    }

    functio getValue() -> numerus {
        redde ego.count
    }
}

varia c = novum counter

scribe c.getValue()

c.increment()
scribe c.getValue()

c.increment()
c.increment()
scribe c.getValue()

c.decrement()
scribe c.getValue()

c.reset()
scribe c.getValue()

// =============================================================================
// MULTIPLE FIELDS WITH METHODS
// =============================================================================

genus rectangle {
    numerus width: 1
    numerus height: 1

    functio area() -> numerus {
        redde ego.width * ego.height
    }

    functio perimeter() -> numerus {
        redde 2 * (ego.width + ego.height)
    }

    functio isSquare() -> bivalens {
        redde ego.width == ego.height
    }
}

fixum square = novum rectangle {
    width: 5,
    height: 5
}

scribe square.area()
scribe square.perimeter()
scribe square.isSquare()

fixum rect = novum rectangle {
    width: 10,
    height: 5
}

scribe rect.area()
scribe rect.isSquare()

// =============================================================================
// METHODS CALLING OTHER METHODS
// =============================================================================

genus circle {
    numerus radius: 1

    functio diameter() -> numerus {
        redde ego.radius * 2
    }

    functio circumference() -> numerus {
        redde ego.diameter() * 3.14159
    }

    functio area() -> numerus {
        redde 3.14159 * ego.radius * ego.radius
    }
}

fixum c1 = novum circle {
    radius: 5
}

scribe c1.diameter()
scribe c1.circumference()
scribe c1.area()

// =============================================================================
// VALIDATION METHODS
// =============================================================================

genus usuario {
    textus name
    textus email
    numerus age: 0

    functio isValid() -> bivalens {
        si nulla ego.name {
            redde falsum
        }

        si nulla ego.email {
            redde falsum
        }

        si ego.age < 0 {
            redde falsum
        }

        redde verum
    }

    functio isAdult() -> bivalens {
        redde ego.age >= 18
    }
}

fixum user1 = novum usuario {
    name: "Marcus",
    email: "marcus@roma.com",
    age: 30
}

scribe user1.isValid()
scribe user1.isAdult()

fixum user2 = novum usuario {
    name: "Julia",
    email: "julia@roma.com",
    age: 16
}

scribe user2.isAdult()

// =============================================================================
// METHODS WITH CONDITIONALS
// =============================================================================

genus account {
    numerus balance: 0

    functio deposit(numerus amount) -> numerus {
        si amount > 0 {
            ego.balance = ego.balance + amount
        }
        redde ego.balance
    }

    functio withdraw(numerus amount) -> numerus {
        si amount > 0 et amount <= ego.balance {
            ego.balance = ego.balance - amount
        }
        redde ego.balance
    }

    functio getBalance() -> numerus {
        redde ego.balance
    }
}

varia acc = novum account

scribe acc.deposit(100)
scribe acc.deposit(50)
scribe acc.withdraw(30)
scribe acc.getBalance()

// =============================================================================
// STRING METHODS
// =============================================================================

genus persona {
    textus firstName
    textus lastName

    functio fullName() -> textus {
        redde ego.firstName + " " + ego.lastName
    }

    functio greet() -> textus {
        redde "Salve, my name is " + ego.fullName()
    }
}

fixum person = novum persona {
    firstName: "Marcus",
    lastName: "Aurelius"
}

scribe person.fullName()
scribe person.greet()

// =============================================================================
// COMPARING INSTANCES
// =============================================================================

genus point {
    numerus x
    numerus y

    functio equals(point other) -> bivalens {
        redde ego.x == other.x et ego.y == other.y
    }

    functio distanceFrom(point other) -> numerus {
        fixum dx = ego.x - other.x
        fixum dy = ego.y - other.y
        redde dx * dx + dy * dy
    }
}

fixum p1 = novum point { x: 0, y: 0 }
fixum p2 = novum point { x: 3, y: 4 }
fixum p3 = novum point { x: 0, y: 0 }

scribe p1.equals(p2)
scribe p1.equals(p3)
scribe p1.distanceFrom(p2)
