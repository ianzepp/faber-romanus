// =============================================================================
// EGO - Self-Reference Keyword
// =============================================================================
//
// "ego" (Latin: "I") is the self-reference keyword, equivalent to "this" in
// JavaScript or "self" in Python/Rust.
//
// GRAMMAR:
// ego                    // reference to current instance
// ego.<field>            // access instance field
// ego.<method>()         // call instance method
//
// ETYMOLOGY:
// ego: "I, myself" (Latin first-person pronoun)
//
// WHY "ego":
// - Literally means "I" in Latin
// - Root of "ego" in English (psychological term)
// - More expressive than generic "this" or "self"

// =============================================================================
// ACCESSING FIELDS
// =============================================================================

genus Persona {
    textus nomen: ""
    numerus aetas: 0

    // ego.field accesses instance data
    functio describe() -> textus {
        redde ego.nomen + " est " + ego.aetas + " annorum"
    }
}

fixum marcus = novum Persona { nomen: "Marcus", aetas: 30 }
scribe marcus.describe()  // "Marcus est 30 annorum"

// =============================================================================
// CALLING METHODS
// =============================================================================

genus Counter {
    numerus value: 0

    functio increment() {
        ego.value = ego.value + 1
    }

    functio add(numerus n) {
        ego.value = ego.value + n
    }

    // Method calling another method via ego
    functio addTwice(numerus n) {
        ego.add(n)
        ego.add(n)
    }

    functio getValue() -> numerus {
        redde ego.value
    }
}

fixum counter = novum Counter()
counter.increment()
counter.increment()
counter.addTwice(5)
scribe counter.getValue()  // 12

// =============================================================================
// METHOD CHAINING
// =============================================================================

genus Builder {
    textus result: ""

    functio append(textus s) -> Builder {
        ego.result = ego.result + s
        redde ego  // return self for chaining
    }

    functio appendLine(textus s) -> Builder {
        ego.result = ego.result + s + "\n"
        redde ego
    }

    functio build() -> textus {
        redde ego.result
    }
}

fixum text = novum Builder()
    .append("Salve, ")
    .appendLine("Mundus!")
    .append("Vale!")
    .build()

scribe text

// =============================================================================
// EGO IN CONDITIONALS
// =============================================================================

genus Rectangle {
    numerus width: 0
    numerus height: 0

    functio area() -> numerus {
        redde ego.width * ego.height
    }

    functio isSquare() -> bivalens {
        redde ego.width == ego.height
    }

    functio isLargerThan(Rectangle other) -> bivalens {
        redde ego.area() > other.area()
    }
}

fixum rect1 = novum Rectangle { width: 10, height: 10 }
fixum rect2 = novum Rectangle { width: 5, height: 8 }

scribe rect1.isSquare()           // verum
scribe rect2.isSquare()           // falsum
scribe rect1.isLargerThan(rect2)  // verum

// =============================================================================
// EGO WITH NESTED ACCESS
// =============================================================================

genus Node {
    textus value: ""
    Node? next: nihil

    functio append(textus v) {
        si ego.next est nihil {
            ego.next = novum Node { value: v }
        } aliter {
            ego.next.append(v)
        }
    }

    functio print() {
        scribe ego.value
        si ego.next non est nihil {
            ego.next.print()
        }
    }
}

fixum list = novum Node { value: "first" }
list.append("second")
list.append("third")
list.print()

// =============================================================================
// PRIVATE FIELDS AND EGO
// =============================================================================

genus BankAccount {
    privatus numerus balance: 0

    functio deposit(numerus amount) {
        si amount > 0 {
            ego.balance = ego.balance + amount
        }
    }

    functio withdraw(numerus amount) -> bivalens {
        si amount > ego.balance {
            redde falsum
        }
        ego.balance = ego.balance - amount
        redde verum
    }

    functio getBalance() -> numerus {
        redde ego.balance
    }
}

fixum account = novum BankAccount()
account.deposit(100)
account.withdraw(30)
scribe account.getBalance()  // 70
