// =============================================================================
// ERRORES - Throw Statement (iace)
// =============================================================================
//
// The iace keyword throws errors/exceptions.
//
// GRAMMAR:
// iace <message>
// iace <errorObject>
//
// ETYMOLOGY:
// iace: "throw! cast!" (imperative of iacere - to throw, hurl)
//
// WHY "iace":
// Literally means "throw" in Latin
// Active imperative fits error-throwing semantics
// More expressive than generic "throw"

// =============================================================================
// BASIC THROW
// =============================================================================

// Throw string message
functio fail() {
    iace "Operation failed"
}

// Catch it
tempta {
    fail()
}
cape err {
    scribe "Caught:", err
}

// =============================================================================
// THROW WITH CONDITIONS
// =============================================================================

functio validate(value) {
    si value < 0 {
        iace "Value must be non-negative"
    }

    si value > 100 {
        iace "Value must be <= 100"
    }

    scribe "Valid:", value
}

tempta {
    validate(50)
    validate(-10)
}
cape err {
    scribe "Validation error:", err
}

// =============================================================================
// THROW IN GUARDS
// =============================================================================

functio processAge(age) {
    custodi {
        si age < 0 {
            iace "Age cannot be negative"
        }
        si age > 150 {
            iace "Age is unrealistic"
        }
    }

    scribe "Age:", age
}

tempta {
    processAge(200)
}
cape err {
    scribe "Error:", err
}

// =============================================================================
// THROW IN SWITCH
// =============================================================================

functio handleStatus(status) {
    elige status {
        si "success" {
            scribe "OK"
        }
        si "warning" {
            scribe "Warning"
        }
        si "error" {
            iace "Status is error"
        }
        aliter {
            iace "Unknown status: " + status
        }
    }
}

tempta {
    handleStatus("success")
    handleStatus("error")
}
cape err {
    scribe "Status error:", err
}

// =============================================================================
// THROW ERROR OBJECTS
// =============================================================================

// Throw error instance (when Error constructor exists)
functio createError() {
    iace novum Error("Custom error message")
}

tempta {
    createError()
}
cape err {
    scribe "Caught error object:", err
}

// =============================================================================
// EARLY EXIT WITH THROW
// =============================================================================

functio mustBePositive(n) -> numerus {
    si n <= 0 {
        iace "Must be positive"
    }

    redde n * 2
}

tempta {
    scribe mustBePositive(10)
    scribe mustBePositive(-5)
}
cape err {
    scribe "Error:", err
}

// =============================================================================
// MULTIPLE THROWS
// =============================================================================

functio complexValidation(value) {
    si nulla value {
        iace "Value is null"
    }

    si value < 0 {
        iace "Value is negative"
    }

    si value == 0 {
        iace "Value is zero"
    }

    si value > 1000 {
        iace "Value too large"
    }

    redde value
}

tempta {
    scribe complexValidation(500)
}
cape err {
    scribe "Validation failed:", err
}

// =============================================================================
// THROW IN LOOPS
// =============================================================================

functio processUntilError(items) {
    ex items pro item {
        si item < 0 {
            iace "Negative item found"
        }

        scribe "Processing:", item
    }
}

tempta {
    processUntilError([1, 2, 3, -1, 5])
}
cape err {
    scribe "Processing stopped:", err
}

// =============================================================================
// RETHROW PATTERN
// =============================================================================

functio innerFunction() {
    iace "Inner error"
}

functio outerFunction() {
    tempta {
        innerFunction()
    }
    cape err {
        scribe "Caught in outer, rethrowing"
        iace err
    }
}

tempta {
    outerFunction()
}
cape err {
    scribe "Final catch:", err
}

// =============================================================================
// THROW VS RETURN
// =============================================================================

// With return (normal flow):
functio normalFlow(x) -> numerus {
    si x < 0 {
        redde -1
    }

    redde x * 2
} // Error indicator

scribe normalFlow(10)
scribe normalFlow(-5)

// With throw (exceptional flow):
functio exceptionalFlow(x) -> numerus {
    si x < 0 {
        iace "Negative not allowed"
    }

    redde x * 2
}

tempta {
    scribe exceptionalFlow(10)
    scribe exceptionalFlow(-5)
}
cape err {
    scribe "Error:", err
}

// =============================================================================
// WHEN TO USE IACE
// =============================================================================

// GOOD: Exceptional conditions
functio divide(a, b) -> numerus {
    si b == 0 {
        iace "Division by zero"
    }

    redde a / b
}

// GOOD: Invalid state
functio requireInitialized(state) {
    si nulla state {
        iace "Not initialized"
    }
}

// GOOD: Unrecoverable errors
varia requiredDependency = verum

functio criticalOperation() {
    si nulla requiredDependency {
        iace "Critical dependency missing"
    }
}

// BAD: Expected conditions (use return codes)
// functio find(items, target) {
// ex items pro item {
// si item == target {
// redde item
// }
// }
// iace "Not found"  // Don't do this
// }

// Instead:
functio findItem(items, target) {
    ex items pro item {
        si item == target {
            redde item
        }
    }
} // Return nothing for "not found"

// Use iace for:
// - Programming errors (bugs)
// - Invalid states
// - Unrecoverable conditions

// Use return values for:
// - Expected outcomes (success/failure)
// - Optional results
// - Normal control flow

// =============================================================================
// ERROR MESSAGES
// =============================================================================

// Good error messages are:
// - Descriptive
// - Include context
// - Suggest fixes

functio goodErrorMessages(value, context) {
    si value < 0 {
        iace "Invalid value: " + value + " (must be >= 0) in " + context
    }
}

tempta {
    goodErrorMessages(-5, "user input")
}
cape err {
    scribe err
}
