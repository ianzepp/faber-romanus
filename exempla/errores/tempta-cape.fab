// =============================================================================
// ERRORES - Try/Catch/Finally (tempta/cape/demum)
// =============================================================================
//
// Error handling uses tempta/cape/demum for try/catch/finally blocks.
//
// GRAMMAR:
// tempta { <body> }
// cape <errorName> { <handler> }
// demum { <cleanup> }
//
// ETYMOLOGY:
// tempta: "try! attempt!" (imperative of temptare - to try, test)
// cape: "catch! seize!" (imperative of capere - to catch, capture)
// demum: "finally, at last" (temporal adverb)
//
// WHY LATIN:
// - tempta conveys "attempt" more actively than "try"
// - cape means "seize" - capturing the error
// - demum expresses finality

// =============================================================================
// BASIC TEMPTA-CAPE
// =============================================================================

tempta {
    scribe "Attempting operation..."
    // Some code that might throw
    scribe "Success"
}
cape erratum {
    scribe "Caught error:", erratum
}

// =============================================================================
// CAPE WITH ERROR VARIABLE
// =============================================================================

tempta {
    iace "Something went wrong"
}
cape err {
    scribe "Error:", err
}

// =============================================================================
// TEMPTA-CAPE-DEMUM
// =============================================================================

tempta {
    scribe "Opening resource..."
    iace "Failed to open"
}
cape err {
    scribe "Error occurred:", err
}
demum {
    scribe "Cleanup: closing resource"
}

// =============================================================================
// DEMUM WITHOUT CAPE
// =============================================================================

// demum runs whether or not an error occurs
tempta {
    scribe "Operation"
}
demum {
    scribe "Always runs"
}

// =============================================================================
// ERROR HANDLING IN FUNCTIONS
// =============================================================================

functio riskyOperation(value) -> numerus {
    tempta {
        si value < 0 {
            iace "Negative value not allowed"
        }

        redde value * 2
    }
    cape err {
        scribe "Error in riskyOperation:", err
        redde 0
    }
}

scribe riskyOperation(10)
scribe riskyOperation(-5)

// =============================================================================
// RETHROWING ERRORS
// =============================================================================

functio validator(x) {
    tempta {
        si x < 0 {
            iace "Validation failed"
        }
    }
    cape err {
        scribe "Caught and rethrowing:", err
        iace err  // Rethrow the error
    }
}

// =============================================================================
// NESTED TEMPTA BLOCKS
// =============================================================================

tempta {
    scribe "Outer try"

    tempta {
        scribe "Inner try"
        iace "Inner error"
    }
    cape inner {
        scribe "Caught inner:", inner
    }

    scribe "After inner"
}
cape outer {
    scribe "Outer catch:", outer
}

// =============================================================================
// CLEANUP PATTERN
// =============================================================================

functio processFile(filename) {
    varia file = nihil

    tempta {
        scribe "Opening file:", filename
        // file = open(filename)

        si filename == "" {
            iace "Empty filename"
        }

        scribe "Processing..."
    }
    cape err {
        scribe "Error processing file:", err
    }
    demum {
        si nonnulla file {
            scribe "Closing file"
            // file.close()
        }
    }
}

processFile("data.txt")
processFile("")

// =============================================================================
// MULTIPLE ERROR TYPES (future)
// =============================================================================

// Future: catch specific error types
// tempta {
//     riskyOperation()
// }
// cape ValidationError err {
//     handleValidationError(err)
// }
// cape NetworkError err {
//     handleNetworkError(err)
// }
// cape err {
//     handleGenericError(err)
// }

// =============================================================================
// RETURNING FROM TEMPTA
// =============================================================================

functio safeDivide(a, b) -> numerus {
    tempta {
        si b == 0 {
            iace "Division by zero"
        }

        redde a / b
    }
    cape err {
        scribe "Error:", err
        redde 0
    }
}

scribe safeDivide(10, 2)
scribe safeDivide(10, 0)

// =============================================================================
// DEMUM WITH RETURN
// =============================================================================

functio withCleanup() -> textus {
    tempta {
        scribe "Starting"
        redde "success"
    }
    cape err {
        redde "error"
    }
    demum {
        scribe "Cleanup runs before return"
    }
}

scribe withCleanup()

// =============================================================================
// PRACTICAL PATTERNS
// =============================================================================

// Resource management
functio connectDatabase(url) {
    varia connection = nihil

    tempta {
        scribe "Connecting to:", url

        si nulla url {
            iace "Invalid URL"
        }

        // connection = database.connect(url)
        scribe "Connected"
    }
    cape err {
        scribe "Connection failed:", err
    }
    demum {
        si nonnulla connection {
            scribe "Disconnecting"
            // connection.close()
        }
    }
}

connectDatabase("postgres://localhost")
connectDatabase("")

// =============================================================================
// WHEN TO USE TEMPTA-CAPE
// =============================================================================

// GOOD: Handling expected runtime errors
functio parseNumber(str) -> numerus {
    tempta {
        // return parseInt(str)
        redde 0
    }
    cape err {
        redde 0
    }
}

// GOOD: Resource cleanup
functio withResource() {
    tempta {
        // allocate resource
        scribe "Using resource"
    }
    demum {
        // free resource
        scribe "Cleanup"
    }
}

// BAD: Control flow (use conditionals instead)
// tempta {
//     si condition { iace "error" }
// }
// cape err {
//     // Don't use exceptions for normal control flow
// }

// Use tempta-cape for exceptional conditions
// Use si-aliter for expected conditions
